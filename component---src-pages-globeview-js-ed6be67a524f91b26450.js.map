{"version":3,"sources":["webpack:///component---src-pages-globeview-js-ed6be67a524f91b26450.js","webpack:///./~/d3-dispatch/build/d3-dispatch.js?a489","webpack:///./~/d3-drag/build/d3-drag.js?153e","webpack:///./~/d3-ease/build/d3-ease.js","webpack:///./~/d3-geo/dist/d3-geo.js?6692","webpack:///./~/d3-timer/build/d3-timer.js?2468","webpack:///./~/d3-transition/build/d3-transition.js","webpack:///./~/d3-zoom/build/d3-zoom.js","webpack:///./~/topojson-client/dist/topojson-client.js?e619","webpack:///./~/uuid/index.js?7e8f*","webpack:///./~/uuid/lib/bytesToUuid.js?3068*","webpack:///./~/uuid/lib/rng-browser.js?945e*","webpack:///./~/uuid/v1.js?f9c7*","webpack:///./~/uuid/v4.js?42e7*","webpack:///./src/components/Challenges/GlobeChartView/GlobeViewChart.js","webpack:///./src/components/Challenges/GlobeChartView/GlobeViewContainer.js","webpack:///./src/components/Challenges/GlobeChartView/MeteorPoint.js","webpack:///./src/components/Challenges/GlobeChartView/MeteorToolTip.js","webpack:///./src/components/Challenges/GlobeChartView/WorldMap.js","webpack:///./src/components/Challenges/GlobeChartView/globe-style.module.css","webpack:///./src/pages/globeview.js"],"names":["webpackJsonp","68","module","exports","__webpack_require__","global","factory","this","dispatch","t","i","n","arguments","length","_","Error","Dispatch","parseTypenames","typenames","types","trim","split","map","name","indexOf","slice","hasOwnProperty","type","get","c","value","set","callback","noop","concat","push","prototype","constructor","on","typename","T","copy","call","that","args","Array","apply","Object","defineProperty","190","d3Dispatch","d3Selection","nopropagation","event","stopImmediatePropagation","yesdrag","view","noclick","root","document","documentElement","selection","select","noevent","setTimeout","style","MozUserSelect","__noselect","DragEvent","target","subject","id","active","x","y","dx","dy","dispatch$$1","identifier","defaultFilter","button","defaultContainer","parentNode","defaultSubject","d","defaultTouchable","preventDefault","nodrag","constant","drag","mousedowned","filter","touchable","touchstarted","touchmoved","touchended","touchending","gesture","beforestart","container","mouse","mousemoved","mouseupped","mousemoving","mousedownx","clientX","mousedowny","clientY","clickDistance2","gestures","touches","changedTouches","touch","clearTimeout","point","s","p","sublisteners","listeners","customEvent","p0","clickDistance","Math","sqrt","dragDisable","dragEnable","362","linear","quadIn","quadOut","quadInOut","cubicIn","cubicOut","cubicInOut","sinIn","cos","halfPi","sinOut","sin","sinInOut","pi","expIn","pow","expOut","expInOut","circleIn","circleOut","circleInOut","bounceIn","bounceOut","b1","b0","b3","b2","b4","b6","b5","b7","b8","b9","bounceInOut","exponent","polyIn","custom","e","polyOut","polyInOut","PI","overshoot","backIn","backOut","backInOut","tau","amplitude","period","elasticIn","a","asin","max","elasticOut","elasticInOut","easeLinear","easeQuad","easeQuadIn","easeQuadOut","easeQuadInOut","easeCubic","easeCubicIn","easeCubicOut","easeCubicInOut","easePoly","easePolyIn","easePolyOut","easePolyInOut","easeSin","easeSinIn","easeSinOut","easeSinInOut","easeExp","easeExpIn","easeExpOut","easeExpInOut","easeCircle","easeCircleIn","easeCircleOut","easeCircleInOut","easeBounce","easeBounceIn","easeBounceOut","easeBounceInOut","easeBack","easeBackIn","easeBackOut","easeBackInOut","easeElastic","easeElasticIn","easeElasticOut","easeElasticInOut","191","d3Array","adder","Adder","reset","add","b","bv","av","acos","haversin","streamGeometry","geometry","stream","streamGeometryType","streamLine","coordinates","closed","coordinate","lineStart","lineEnd","streamPolygon","polygonStart","polygonEnd","geoStream","object","streamObjectType","areaRingStart","areaStream","areaPointFirst","areaRingEnd","areaPoint","lambda00","phi00","lambda","phi","radians","lambda0","cosPhi0","quarterPi","sinPhi0","dLambda","sdLambda","adLambda","cosPhi","sinPhi","k","u","v","areaRingSum","atan2","area","areaSum","spherical","cartesian","cartesianDot","cartesianCross","cartesianAddInPlace","cartesianScale","vector","cartesianNormalizeInPlace","l","boundsPoint","ranges","range$1","lambda0$1","lambda1","phi0","phi1","linePoint","normal","equatorial","inflection","phii","delta","lambda2","sign$$1","lambdai","degrees","antimeridian","abs","angle","boundsLineStart","boundsStream","boundsLineEnd","boundsRingPoint","deltaSum","lambda00$1","phi00$1","boundsRingStart","boundsRingEnd","epsilon","rangeCompare","rangeContains","range$$1","bounds","feature","merged","deltaMax","Infinity","sort","NaN","centroidPoint","centroidPointCartesian","z","W0","X0","Y0","Z0","centroidLineStart","centroidStream","centroidLinePointFirst","x0","y0","z0","centroidLinePoint","w","W1","X1","Y1","Z1","centroidLineEnd","centroidRingStart","centroidRingPointFirst","centroidRingEnd","centroidRingPoint","lambda00$2","phi00$2","cx","cy","cz","m","X2","Y2","Z2","centroid","epsilon2","compose","invert","rotationIdentity","rotateRadians","deltaLambda","deltaPhi","deltaGamma","rotationLambda","rotationPhiGamma","forwardRotationLambda","rotation","cosDeltaPhi","sinDeltaPhi","cosDeltaGamma","sinDeltaGamma","rotate","forward","circleStream","radius","direction","t0","t1","cosRadius","sinRadius","step","circleRadius","circle","ring","center","r","precision","clipBuffer","line","lines","rejoin","pop","shift","result","pointEqual","Intersection","points","other","entry","o","clipRejoin","segments","compareIntersection","startInside","interpolate","clip","forEach","segment","p1","link","start","current","isSubject","array","polygonContains","polygon","winding","sum","point0","j","sinPhi1","cosPhi1","point1","absDelta","arc","intersection","phiArc","pointVisible","clipLine","sink","pointLine","pointRing","ringSink","ringStart","ringEnd","clean","ringSegments","ringBuffer","polygonStarted","validSegment","merge","sphere","clipAntimeridianLine","sign0","sign1","clipAntimeridianIntersect","sinLambda0Lambda1","atan","clipAntimeridianInterpolate","from","to","clipCircle","visible","cr","c0","v0","v00","point2","smallRadius","code","intersect","notHemisphere","two","pa","pb","n1","n2","n2n2","n1n2","determinant","c1","c2","n1xn2","A","B","uu","t2","q","polar","meridian","q1","x1","y1","ax","ay","bx","by","clipRectangle","a1","corner","comparePoint","ca","cb","activeStream","polygonInside","a0","bufferStream","cleanInside","clipStream","first","v_","x_","y_","x__","y__","v__","clipMin","min","clipMax","extent","cache","cacheStream","lengthLineStart","lengthStream","lengthPointFirst","lengthLineEnd","lambda0$2","sinPhi0$1","cosPhi0$1","lengthPoint","cosDelta","sinDelta","lengthSum","distance","containsGeometry","containsGeometryType","containsPoint","containsLine","ab","ao","ob","containsPolygon","ringRadians","pointRadians","contains","containsObjectType","graticuleX","range","graticuleY","graticule","ceil","DX","X","DY","Y","outline","reverse","extentMajor","extentMinor","stepMajor","stepMinor","graticule10","cy0","sy0","cy1","sy1","kx0","ky0","kx1","ky1","identity","areaRingStart$1","areaStream$1","areaPointFirst$1","areaPoint$1","x00","x0$1","y00","y0$1","areaRingSum$1","areaRingEnd$1","boundsPoint$1","x0$2","y0$2","centroidPoint$1","X0$1","Y0$1","Z0$1","centroidLineStart$1","centroidStream$1","centroidPointFirstLine","centroidPointLine","x0$3","y0$3","X1$1","Y1$1","Z1$1","centroidLineEnd$1","centroidRingStart$1","centroidPointFirstRing","centroidRingEnd$1","centroidPointRing","x00$1","y00$1","X2$1","Y2$1","Z2$1","PathContext","context","_context","lengthPointFirst$1","lengthStream$1","lengthPoint$1","x00$2","x0$4","y00$2","y0$4","lengthSum$1","PathString","_string","circle$1","index","projection","path","pointRadius","contextStream","projectionStream","measure","boundsStream$1","transform","methods","transformer","TransformStream","key","fit","fitBounds","clipExtent","scale","translate","fitExtent","h","fitSize","size","fitWidth","width","fitHeight","height","resample","project","delta2","resample$1","resampleNone","resampleLineTo","depth","d2","phi2","x2","y2","dx2","dy2","dz","cosMinDistance","resampleStream","maxDepth","ringPoint","a00","b00","c00","transformRotate","scaleTranslate","transform$$1","scaleTranslateRotate","alpha","cosAlpha","sinAlpha","ai","bi","ci","fi","projectionMutator","projectAt","projectRotateTransform","recenter","projectTransform","projectResample","theta","preclip","clipAntimeridian","postclip","transformRadians","undefined","clipAngle","conicProjection","parallels","cylindricalEqualAreaRaw","conicEqualAreaRaw","r0","r0y","sign","conicEqualArea","albers","multiplex","streams","albersUsa","lower48Point","alaskaPoint","hawaiiPoint","lower48","alaska","hawaii","pointStream","azimuthalRaw","azimuthalInvert","sc","cc","azimuthalEqualArea","azimuthalEqualAreaRaw","azimuthalEquidistant","azimuthalEquidistantRaw","mercatorRaw","log","tan","mercator","mercatorProjection","reclip","tany","conicConformalRaw","f","fy","conicConformal","equirectangularRaw","equirectangular","conicEquidistantRaw","gy","g","nx","conicEquidistant","gnomonicRaw","gnomonic","scaleTranslate$1","kx","ky","tx","ty","identity$1","sx","sy","reflectX","reflectY","naturalEarth1Raw","phi4","naturalEarth1","orthographicRaw","orthographic","stereographicRaw","stereographic","transverseMercatorRaw","transverseMercator","temp","valueOf","exp","Feature","FeatureCollection","features","Sphere","Point","MultiPoint","LineString","MultiLineString","Polygon","MultiPolygon","GeometryCollection","geometries","areaRing","areaSum$1","_radius","_line","_point","closePath","moveTo","lineTo","lengthRing","_circle","join","cxcy","geoArea","geoBounds","geoCentroid","geoCircle","geoClipAntimeridian","geoClipCircle","geoClipExtent","geoClipRectangle","geoContains","geoDistance","geoGraticule","geoGraticule10","geoInterpolate","geoLength","geoPath","geoAlbers","geoAlbersUsa","geoAzimuthalEqualArea","geoAzimuthalEqualAreaRaw","geoAzimuthalEquidistant","geoAzimuthalEquidistantRaw","geoConicConformal","geoConicConformalRaw","geoConicEqualArea","geoConicEqualAreaRaw","geoConicEquidistant","geoConicEquidistantRaw","geoEquirectangular","geoEquirectangularRaw","geoGnomonic","geoGnomonicRaw","geoIdentity","geoProjection","geoProjectionMutator","geoMercator","geoMercatorRaw","geoNaturalEarth1","geoNaturalEarth1Raw","geoOrthographic","geoOrthographicRaw","geoStereographic","geoStereographicRaw","geoTransverseMercator","geoTransverseMercatorRaw","geoRotation","geoTransform","192","now","clockNow","setFrame","clearNow","clock","clockSkew","Timer","_call","_time","_next","timer","delay","time","restart","timerFlush","frame","taskHead","wake","clockLast","timeout","nap","poke","pokeDelay","taskTail","sleep","interval","clearInterval","setInterval","performance","Date","window","requestAnimationFrame","bind","TypeError","stop","timeout$1","elapsed","interval$1","total","tick","368","d3Timer","d3Interpolate","d3Color","d3Ease","init","node","schedule","state","CREATED","STARTING","__transition","create","self","SCHEDULED","schedules","STARTED","RUNNING","ENDED","__data__","group","tween","duration","ease","ENDING","tweenRemove","tween0","tween1","splice","tweenFunction","tweenValue","transition","_id","each","attrRemove","removeAttribute","attrRemoveNS","fullname","removeAttributeNS","space","local","attrConstant","interpolate$$1","value1","value00","interpolate0","value0","getAttribute","attrConstantNS","getAttributeNS","attrFunction","value10","attrFunctionNS","attrTweenNS","setAttributeNS","_value","attrTween","setAttribute","delayFunction","delayConstant","durationFunction","durationConstant","easeConstant","every","onFunction","listener","on0","on1","sit","removeFunction","parent","removeChild","styleRemove","removeProperty","styleRemoveEnd","styleConstant","styleFunction","styleTween","priority","setProperty","textConstant","textContent","textFunction","Transition","groups","parents","_groups","_parents","_name","newId","inherit","timing","defaultTiming","emptyOn","emptyTween","interrupt","empty","selection_interrupt","transition_tween","interpolateNumber","color","interpolateRgb","interpolateString","transition_attr","namespace","interpolateTransformSvg","transition_attrTween","transition_delay","transition_duration","transition_ease","transition_filter","match","matcher","subgroups","subgroup","transition_merge","groups0","groups1","m0","m1","merges","group0","group1","transition_on","transition_remove","transition_select","selector","subnode","transition_selectAll","selectorAll","child","children","Selection","transition_selection","transition_style","interpolateTransformCss","transition_styleTween","transition_text","transition_transition","id0","id1","selection_prototype","selectAll","nodes","attr","text","remove","selection_transition","369","d3Drag","d3Transition","ZoomEvent","Transform","__zoom","defaultExtent","SVGElement","ownerSVGElement","baseVal","clientWidth","clientHeight","defaultTransform","defaultWheelDelta","deltaY","deltaMode","defaultConstrain","translateExtent","dx0","invertX","dx1","dy0","invertY","dy1","applyX","applyY","location","rescaleX","domain","rescaleY","toString","zoom","property","wheeled","dblclicked","scaleExtent","end","Gesture","wheelidled","wheel","wheelDelta","wheelDelay","constrain","moved","k1","shiftKey","started","touch0","touch1","touchstarting","touchDelay","l0","l1","dp","dl","interpolateZoom","collection","scaleBy","scaleTo","k0","translateBy","translateTo","emit","zoomTransform","zoomIdentity","226","feature$1","topology","bbox","properties","arcs","transformPoint","meshArcs","object$$1","extractArcs","stitch","extract0","geomsByArc","geom","extract1","extract2","extract3","geoms","planarRingArea","mergeArcs","objects","extract","polygonsByArc","polygons","neighbors","ki","input","output","bboxPoint","bboxGeometry","ends","flush","fragmentByEnd","fragmentByStart","stitchedArcs","fragments","emptyIndex","fg","unshift","gf","mesh","bisect","lo","hi","mid","indexesByArc","geometryType","indexes","ij","ik","untransform","round","quantize","quantizePoint","quantizeGeometry","quantizeArc","box","floor","inputs","outputs","71","v1","v4","uuid","34","bytesToUuid","buf","offset","bth","byteToHex","substr","35","getRandomValues","crypto","msCrypto","rnds8","Uint8Array","rnds","random","109","options","_nodeId","clockseq","_clockseq","seedBytes","rng","msecs","getTime","nsecs","_lastNSecs","dt","_lastMSecs","tl","tmh","110","ii","289","_interopRequireDefault","obj","__esModule","default","_classCallCheck","instance","Constructor","_possibleConstructorReturn","ReferenceError","_inherits","subClass","superClass","enumerable","writable","configurable","setPrototypeOf","__proto__","_react","_react2","_d3Zoom","_d3Selection","_propTypes","_propTypes2","_WorldMap","_WorldMap2","GlobeViewChart","_Component","_temp","_this","_ret","_len","_key","onZoomHandler","setState","showToolTipInfo","showToolTip","props","hideToolTipInfo","hideToolTip","componentDidMount","worldmap","render","_this2","_props","globeData","meteorsInfo","svgWidth","svgHeight","createElement","ref","el","viewBox","preserveAspectRatio","world","meteorfall","pointEnter","pointExit","Component","propTypes","number","func","arrayOf","shape","dpath","string","fillInfo","date","fillOp","latitude","longitude","mass","meteorClass","290","_d3Geo","_topojsonClient","_Utilities","_Utilities2","_index","_index2","_GlobeViewChart","_GlobeViewChart2","_MeteorToolTip","_MeteorToolTip2","_globeStyleModule","_globeStyleModule2","GlobeViewContainer","isLoading","isError","isToolTipActive","meteorInfo","chartWidth","chartHeight","meteors","globeMap","mapData","meteorData","setChartWidth","setChartDimensions","currentWidth","currentHeight","chartContainer","getBoundingClientRect","innerWidth","innerHeight","updateMap","_this$state","updatedMap","meteorPoints","parseInt","year","recclass","calculateRadius","Number","reclong","reclat","activateToolTip","disableToolTip","handlePreloadShutdown","addEventListener","storedMap","JSON","parse","getStorageData","meteorsData","fetchData","fetchDataMeteor","componentWillUnmount","removeEventListener","_state","_this3","fetch","then","response","json","setStorageData","catch","err","console","stringify","_this4","pathsGlobe","countries","formattedMap","_this5","_state2","className","globeTitle","chartName","turnDownPreload","containerGlobe","data","291","MeteorPoint","_PureComponent","onEnter","_this$props","meteorPointEnter","meteorname","meteorclass","dateofhit","datefell","substring","meteormass","rectangleLat","toFixed","rectangleLong","onExit","meteorPointExit","circleId","fill","fillOpacity","circleFill","stroke","circleArea","onMouseOver","onFocus","onMouseOut","onBlur","PureComponent","292","showMeteorInfo","tooltipText","showMeteorData","MeteorToolTip","_ref","containerToolTip","293","_uuid","_uuid2","_MeteorPoint","_MeteorPoint2","WorldMap","onPointHover","onPointLeave","parsedWorld","strokeWidth","254","325","_reactHelmet","_reactHelmet2","_GlobeViewContainer","_GlobeViewContainer2","GlobeGraphPage","title","meta","content"],"mappings":"AAAAA,cAAc,iBAERC,GACA,SAAUC,EAAQC,EAASC,ICFjC,SAAAC,EAAAC,GACAA,EAAAH,IAGCI,KAAA,SAAAJ,GAA4B,YAI7B,SAAAK,KACA,OAA8CC,GAA9CC,EAAA,EAAAC,EAAAC,UAAAC,OAAAC,KAAkDJ,EAAAC,IAAOD,EAAA,CACzD,KAAAD,EAAAG,UAAAF,GAAA,KAAAD,IAAAK,GAAA,SAAAC,OAAA,iBAAAN,EACAK,GAAAL,MAEA,UAAAO,GAAAF,GAGA,QAAAE,GAAAF,GACAP,KAAAO,IAGA,QAAAG,GAAAC,EAAAC,GACA,MAAAD,GAAAE,OAAAC,MAAA,SAAAC,IAAA,SAAAb,GACA,GAAAc,GAAA,GAAAb,EAAAD,EAAAe,QAAA,IAEA,IADAd,GAAA,IAAAa,EAAAd,EAAAgB,MAAAf,EAAA,GAAAD,IAAAgB,MAAA,EAAAf,IACAD,IAAAU,EAAAO,eAAAjB,GAAA,SAAAM,OAAA,iBAAAN,EACA,QAAYkB,KAAAlB,EAAAc,UA6CZ,QAAAK,GAAAD,EAAAJ,GACA,OAAAM,GAAAnB,EAAA,EAAAC,EAAAgB,EAAAd,OAAqCH,EAAAC,IAAOD,EAC5C,IAAAmB,EAAAF,EAAAjB,IAAAa,SACA,MAAAM,GAAAC,MAKA,QAAAC,GAAAJ,EAAAJ,EAAAS,GACA,OAAAtB,GAAA,EAAAC,EAAAgB,EAAAd,OAAkCH,EAAAC,IAAOD,EACzC,GAAAiB,EAAAjB,GAAAa,SAAA,CACAI,EAAAjB,GAAAuB,EAAAN,IAAAF,MAAA,EAAAf,GAAAwB,OAAAP,EAAAF,MAAAf,EAAA,GACA,OAIA,MADA,OAAAsB,GAAAL,EAAAQ,MAAmCZ,OAAAO,MAAAE,IACnCL,EAhFA,GAAAM,IAAYH,MAAA,aAuBZd,GAAAoB,UAAA5B,EAAA4B,WACAC,YAAArB,EACAsB,GAAA,SAAAC,EAAAP,GACA,GAEAvB,GAFAK,EAAAP,KAAAO,EACA0B,EAAAvB,EAAAsB,EAAA,GAAAzB,GAEAJ,GAAA,EACAC,EAAA6B,EAAA3B,MAGA,OAAAD,UAAAC,OAAA,IAOA,SAAAmB,GAAA,kBAAAA,GAAA,SAAAjB,OAAA,qBAAAiB,EACA,QAAAtB,EAAAC,GACA,GAAAF,GAAA8B,EAAAC,EAAA9B,IAAAiB,KAAAb,EAAAL,GAAAsB,EAAAjB,EAAAL,GAAA8B,EAAAhB,KAAAS,OACA,UAAAA,EAAA,IAAAvB,IAAAK,KAAAL,GAAAsB,EAAAjB,EAAAL,GAAA8B,EAAAhB,KAAA,KAGA,OAAAhB,MAZA,OAAAG,EAAAC,GAAA,IAAAF,GAAA8B,EAAAC,EAAA9B,IAAAiB,QAAAlB,EAAAmB,EAAAd,EAAAL,GAAA8B,EAAAhB,OAAA,MAAAd,KAcAgC,KAAA,WACA,GAAAA,MAAiB3B,EAAAP,KAAAO,CACjB,QAAAL,KAAAK,GAAA2B,EAAAhC,GAAAK,EAAAL,GAAAgB,OACA,WAAAT,GAAAyB,IAEAC,KAAA,SAAAf,EAAAgB,GACA,IAAAhC,EAAAC,UAAAC,OAAA,YAAAF,GAAAF,EAAAmC,EAAA,GAAAC,OAAAlC,GAAAD,EAAA,EAAkFA,EAAAC,IAAOD,EAAAkC,EAAAlC,GAAAE,UAAAF,EAAA,EACzF,KAAAH,KAAAO,EAAAY,eAAAC,GAAA,SAAAZ,OAAA,iBAAAY,EACA,KAAAlB,EAAAF,KAAAO,EAAAa,GAAAjB,EAAA,EAAAC,EAAAF,EAAAI,OAA+CH,EAAAC,IAAOD,EAAAD,EAAAC,GAAAoB,MAAAgB,MAAAH,EAAAC,IAEtDE,MAAA,SAAAnB,EAAAgB,EAAAC,GACA,IAAArC,KAAAO,EAAAY,eAAAC,GAAA,SAAAZ,OAAA,iBAAAY,EACA,QAAAlB,GAAAF,KAAAO,EAAAa,GAAAjB,EAAA,EAAAC,EAAAF,EAAAI,OAAmDH,EAAAC,IAAOD,EAAAD,EAAAC,GAAAoB,MAAAgB,MAAAH,EAAAC,KAuB1DzC,EAAAK,WAEAuC,OAAAC,eAAA7C,EAAA,cAA8C2B,OAAA,ODYxCmB,IACA,SAAU/C,EAAQC,EAASC,IExGjC,SAAAC,EAAAC,GACAA,EAAAH,EAAAC,EAAA,IAAAA,EAAA,MAGCG,KAAA,SAAAJ,EAAA+C,EAAAC,GAAmD,YAEpD,SAAAC,KACAD,EAAAE,MAAAC,2BAmBA,QAAAC,GAAAC,EAAAC,GACA,GAAAC,GAAAF,EAAAG,SAAAC,gBACAC,EAAAV,EAAAW,OAAAN,GAAAlB,GAAA,sBACAmB,KACAI,EAAAvB,GAAA,aAAAyB,GAAA,GACAC,WAAA,WAA2BH,EAAAvB,GAAA,oBAAoC,IAE/D,iBAAAoB,GACAG,EAAAvB,GAAA,0BAEAoB,EAAAO,MAAAC,cAAAR,EAAAS,iBACAT,GAAAS,YAUA,QAAAC,GAAAC,EAAA1C,EAAA2C,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GACAtE,KAAA8D,SACA9D,KAAAoB,OACApB,KAAA+D,UACA/D,KAAAuE,WAAAP,EACAhE,KAAAiE,SACAjE,KAAAkE,IACAlE,KAAAmE,IACAnE,KAAAoE,KACApE,KAAAqE,KACArE,KAAAO,EAAA+D,EASA,QAAAE,KACA,OAAA5B,EAAAE,MAAA2B,OAGA,QAAAC,KACA,MAAA1E,MAAA2E,WAGA,QAAAC,GAAAC,GACA,aAAAA,GAAsBX,EAAAtB,EAAAE,MAAAoB,EAAAC,EAAAvB,EAAAE,MAAAqB,GAA+CU,EAGrE,QAAAC,KACA,sBAAA9E,MArEA,GAAAwD,GAAA,WACAZ,EAAAE,MAAAiC,iBACAnC,EAAAE,MAAAC,4BAGAiC,EAAA,SAAA/B,GACA,GAAAE,GAAAF,EAAAG,SAAAC,gBACAC,EAAAV,EAAAW,OAAAN,GAAAlB,GAAA,iBAAAyB,GAAA,EACA,kBAAAL,GACAG,EAAAvB,GAAA,mBAAAyB,GAAA,IAEAL,EAAAS,WAAAT,EAAAO,MAAAC,cACAR,EAAAO,MAAAC,cAAA,SAmBAsB,EAAA,SAAAf,GACA,kBACA,MAAAA,IAiBAL,GAAAhC,UAAAE,GAAA,WACA,GAAAR,GAAAvB,KAAAO,EAAAwB,GAAAQ,MAAAvC,KAAAO,EAAAF,UACA,OAAAkB,KAAAvB,KAAAO,EAAAP,KAAAuB,EAoBA,IAAA2D,GAAA,WAcA,QAAAA,GAAA5B,GACAA,EACAvB,GAAA,iBAAAoD,GACAC,OAAAC,GACAtD,GAAA,kBAAAuD,GACAvD,GAAA,iBAAAwD,GACAxD,GAAA,iCAAAyD,GACA9B,MAAA,uBACAA,MAAA,+CAGA,QAAAyB,KACA,IAAAM,GAAAL,EAAA7C,MAAAvC,KAAAK,WAAA,CACA,GAAAqF,GAAAC,EAAA,QAAAC,EAAArD,MAAAvC,KAAAK,WAAAuC,EAAAiD,MAAA7F,KAAAK,UACAqF,KACA9C,EAAAW,OAAAX,EAAAE,MAAAG,MAAAlB,GAAA,iBAAA+D,GAAA,GAAA/D,GAAA,eAAAgE,GAAA,GACAf,EAAApC,EAAAE,MAAAG,MACAJ,IACAmD,GAAA,EACAC,EAAArD,EAAAE,MAAAoD,QACAC,EAAAvD,EAAAE,MAAAsD,QACAV,EAAA,WAGA,QAAAI,KAEA,GADAtC,KACAwC,EAAA,CACA,GAAA5B,GAAAxB,EAAAE,MAAAoD,QAAAD,EAAA5B,EAAAzB,EAAAE,MAAAsD,QAAAD,CACAH,GAAA5B,IAAAC,IAAAgC,EAEAC,EAAAT,MAAA,QAGA,QAAAE,KACAnD,EAAAW,OAAAX,EAAAE,MAAAG,MAAAlB,GAAA,oCACAiB,EAAAJ,EAAAE,MAAAG,KAAA+C,GACAxC,IACA8C,EAAAT,MAAA,OAGA,QAAAP,KACA,GAAAF,EAAA7C,MAAAvC,KAAAK,WAAA,CACA,GAEAF,GAAAuF,EAFAa,EAAA3D,EAAAE,MAAA0D,eACAlF,EAAAsE,EAAArD,MAAAvC,KAAAK,WACAD,EAAAmG,EAAAjG,MAEA,KAAAH,EAAA,EAAeA,EAAAC,IAAOD,GACtBuF,EAAAC,EAAAY,EAAApG,GAAAoE,WAAAjD,EAAAsB,EAAA6D,MAAAzG,KAAAK,cACAwC,IACA6C,EAAA,WAKA,QAAAH,KACA,GACApF,GAAAuF,EADAa,EAAA3D,EAAAE,MAAA0D,eACApG,EAAAmG,EAAAjG,MAEA,KAAAH,EAAA,EAAeA,EAAAC,IAAOD,GACtBuF,EAAAY,EAAAC,EAAApG,GAAAoE,eACAf,IACAkC,EAAA,SAKA,QAAAF,KACA,GACArF,GAAAuF,EADAa,EAAA3D,EAAAE,MAAA0D,eACApG,EAAAmG,EAAAjG,MAIA,KAFAmF,GAAAiB,aAAAjB,GACAA,EAAAhC,WAAA,WAAyCgC,EAAA,MAAsB,KAC/DtF,EAAA,EAAeA,EAAAC,IAAOD,GACtBuF,EAAAY,EAAAC,EAAApG,GAAAoE,eACA1B,IACA6C,EAAA,QAKA,QAAAC,GAAA3B,EAAA4B,EAAAe,EAAAvE,EAAAC,GACA,GAAAuE,GAAAxC,EAAAC,EAAAwC,EAAAF,EAAAf,EAAA5B,GACA8C,EAAAC,EAAA7E,MAEA,IAAAU,EAAAoE,YAAA,GAAAnD,GAAAqB,EAAA,cAAA0B,EAAA5C,EAAAC,EAAA4C,EAAA,GAAAA,EAAA,OAAAC,GAAA,WACA,cAAAlE,EAAAE,MAAAiB,QAAA6C,EAAA7C,EAAAxB,MAAAH,EAAAC,MACA+B,EAAAwC,EAAA1C,EAAA2C,EAAA,MACAxC,EAAAuC,EAAAzC,EAAA0C,EAAA,OACA,KAGA,eAAAnB,GAAAtE,GACA,GAAAhB,GAAA6G,EAAAJ,CACA,QAAAzF,GACA,YAAAkF,EAAAtC,GAAA0B,EAAAtF,EAAA6D,GAA2D,MAC3D,iBAAAqC,GAAAtC,KAAAC,CACA,YAAA4C,EAAAF,EAAAf,EAAA5B,GAAA5D,EAAA6D,EAEArB,EAAAoE,YAAA,GAAAnD,GAAAqB,EAAA9D,EAAAwF,EAAA5C,EAAA5D,EAAAyG,EAAA,GAAAzC,EAAAyC,EAAA,GAAAxC,EAAAwC,EAAA,GAAAI,EAAA,GAAAJ,EAAA,GAAAI,EAAA,GAAAH,KAAAvE,MAAAuE,GAAA1F,EAAAgB,EAAAC,KA/GA,GAOA4D,GACAE,EACAH,EACAP,EAVAL,EAAAZ,EACAoB,EAAAlB,EACAX,EAAAa,EACAS,EAAAP,EACAwB,KACAS,EAAApE,EAAA1C,SAAA,sBACAgE,EAAA,EAKAoC,EAAA,CAiIA,OAzBAnB,GAAAE,OAAA,SAAA7E,GACA,MAAAF,WAAAC,QAAA8E,EAAA,kBAAA7E,KAAA0E,IAAA1E,GAAA2E,GAAAE,GAGAF,EAAAU,UAAA,SAAArF,GACA,MAAAF,WAAAC,QAAAsF,EAAA,kBAAArF,KAAA0E,EAAA1E,GAAA2E,GAAAU,GAGAV,EAAAnB,QAAA,SAAAxD,GACA,MAAAF,WAAAC,QAAAyD,EAAA,kBAAAxD,KAAA0E,EAAA1E,GAAA2E,GAAAnB,GAGAmB,EAAAG,UAAA,SAAA9E,GACA,MAAAF,WAAAC,QAAA+E,EAAA,kBAAA9E,KAAA0E,IAAA1E,GAAA2E,GAAAG,GAGAH,EAAAnD,GAAA,WACA,GAAAR,GAAAwF,EAAAhF,GAAAQ,MAAAwE,EAAA1G,UACA,OAAAkB,KAAAwF,EAAA7B,EAAA3D,GAGA2D,EAAAgC,cAAA,SAAA3G,GACA,MAAAF,WAAAC,QAAA+F,GAAA9F,QAAA2E,GAAAiC,KAAAC,KAAAf,IAGAnB,EAGAtF,GAAAsF,OACAtF,EAAAyH,YAAArC,EACApF,EAAA0H,WAAAtE,EAEAR,OAAAC,eAAA7C,EAAA,cAA8C2B,OAAA,OFkHxCgG,IACA,SAAU5H,EAAQC,EAASC,IGzVjC,SAAAC,EAAAC,GACAA,EAAAH,IAGCI,KAAA,SAAAJ,GAA4B,YAE7B,SAAA4H,GAAAtH,GACA,OAAAA,EAGA,QAAAuH,GAAAvH,GACA,MAAAA,KAGA,QAAAwH,GAAAxH,GACA,MAAAA,IAAA,EAAAA,GAGA,QAAAyH,GAAAzH,GACA,QAAAA,GAAA,MAAAA,SAAA,EAAAA,GAAA,KAGA,QAAA0H,GAAA1H,GACA,MAAAA,OAGA,QAAA2H,GAAA3H,GACA,QAAAA,MAAA,EAGA,QAAA4H,GAAA5H,GACA,QAAAA,GAAA,MAAAA,UAAA,GAAAA,IAAA,KA4CA,QAAA6H,GAAA7H,GACA,SAAAiH,KAAAa,IAAA9H,EAAA+H,GAGA,QAAAC,GAAAhI,GACA,MAAAiH,MAAAgB,IAAAjI,EAAA+H,GAGA,QAAAG,GAAAlI,GACA,SAAAiH,KAAAa,IAAAK,EAAAnI,IAAA,EAGA,QAAAoI,GAAApI,GACA,MAAAiH,MAAAoB,IAAA,KAAArI,EAAA,IAGA,QAAAsI,GAAAtI,GACA,SAAAiH,KAAAoB,IAAA,MAAArI,GAGA,QAAAuI,GAAAvI,GACA,QAAAA,GAAA,MAAAiH,KAAAoB,IAAA,KAAArI,EAAA,MAAAiH,KAAAoB,IAAA,QAAArI,IAAA,EAGA,QAAAwI,GAAAxI,GACA,SAAAiH,KAAAC,KAAA,EAAAlH,KAGA,QAAAyI,GAAAzI,GACA,MAAAiH,MAAAC,KAAA,KAAAlH,KAGA,QAAA0I,GAAA1I,GACA,QAAAA,GAAA,QAAAiH,KAAAC,KAAA,EAAAlH,KAAAiH,KAAAC,KAAA,GAAAlH,GAAA,GAAAA,GAAA,KAcA,QAAA2I,GAAA3I,GACA,SAAA4I,EAAA,EAAA5I,GAGA,QAAA4I,GAAA5I,GACA,OAAAA,MAAA6I,EAAAC,EAAA9I,MAAA+I,EAAAD,GAAA9I,GAAAgJ,GAAAhJ,EAAAiJ,EAAAjJ,EAAAkJ,EAAAJ,GAAA9I,GAAAmJ,GAAAnJ,EAAAoJ,EAAAN,GAAA9I,GAAAqJ,GAAArJ,EAAAsJ,EAGA,QAAAC,GAAAvJ,GACA,QAAAA,GAAA,QAAA4I,EAAA,EAAA5I,GAAA4I,EAAA5I,EAAA,QAjGA,GAAAwJ,GAAA,EAEAC,EAAA,QAAAC,GAAAC,GAGA,QAAAF,GAAAzJ,GACA,MAAAiH,MAAAoB,IAAArI,EAAA2J,GAKA,MARAA,MAMAF,EAAAD,SAAAE,EAEAD,GACCD,GAEDI,EAAA,QAAAF,GAAAC,GAGA,QAAAC,GAAA5J,GACA,SAAAiH,KAAAoB,IAAA,EAAArI,EAAA2J,GAKA,MARAA,MAMAC,EAAAJ,SAAAE,EAEAE,GACCJ,GAEDK,EAAA,QAAAH,GAAAC,GAGA,QAAAE,GAAA7J,GACA,QAAAA,GAAA,MAAAiH,KAAAoB,IAAArI,EAAA2J,GAAA,EAAA1C,KAAAoB,IAAA,EAAArI,EAAA2J,IAAA,EAKA,MARAA,MAMAE,EAAAL,SAAAE,EAEAG,GACCL,GAEDrB,EAAAlB,KAAA6C,GACA/B,EAAAI,EAAA,EAsCAU,EAAA,KACAG,EAAA,KACAD,EAAA,KACAE,EAAA,IACAE,EAAA,KACAD,EAAA,MACAE,EAAA,MACAC,EAAA,MACAC,EAAA,MACAR,EAAA,EAAAD,IAcAkB,EAAA,QAEAC,EAAA,QAAAN,GAAAhD,GAGA,QAAAsD,GAAAhK,GACA,MAAAA,OAAA0G,EAAA,GAAA1G,EAAA0G,GAKA,MARAA,MAMAsD,EAAAD,UAAAL,EAEAM,GACCD,GAEDE,EAAA,QAAAP,GAAAhD,GAGA,QAAAuD,GAAAjK,GACA,QAAAA,MAAA0G,EAAA,GAAA1G,EAAA0G,GAAA,EAKA,MARAA,MAMAuD,EAAAF,UAAAL,EAEAO,GACCF,GAEDG,EAAA,QAAAR,GAAAhD,GAGA,QAAAwD,GAAAlK,GACA,QAAAA,GAAA,KAAAA,MAAA0G,EAAA,GAAA1G,EAAA0G,IAAA1G,GAAA,GAAAA,IAAA0G,EAAA,GAAA1G,EAAA0G,GAAA,KAKA,MARAA,MAMAwD,EAAAH,UAAAL,EAEAQ,GACCH,GAEDI,EAAA,EAAAlD,KAAA6C,GACAM,EAAA,EACAC,EAAA,GAEAC,EAAA,QAAAZ,GAAAa,EAAA5D,GAGA,QAAA2D,GAAAtK,GACA,MAAAuK,GAAAtD,KAAAoB,IAAA,OAAArI,GAAAiH,KAAAgB,KAAAvB,EAAA1G,GAAA2G,GAHA,GAAAD,GAAAO,KAAAuD,KAAA,GAAAD,EAAAtD,KAAAwD,IAAA,EAAAF,MAAA5D,GAAAwD,EASA,OAHAG,GAAAF,UAAA,SAAAG,GAAqC,MAAAb,GAAAa,EAAA5D,EAAAwD,IACrCG,EAAAD,OAAA,SAAA1D,GAAkC,MAAA+C,GAAAa,EAAA5D,IAElC2D,GACCF,EAAAC,GAEDK,EAAA,QAAAhB,GAAAa,EAAA5D,GAGA,QAAA+D,GAAA1K,GACA,SAAAuK,EAAAtD,KAAAoB,IAAA,OAAArI,OAAAiH,KAAAgB,KAAAjI,EAAA0G,GAAAC,GAHA,GAAAD,GAAAO,KAAAuD,KAAA,GAAAD,EAAAtD,KAAAwD,IAAA,EAAAF,MAAA5D,GAAAwD,EASA,OAHAO,GAAAN,UAAA,SAAAG,GAAsC,MAAAb,GAAAa,EAAA5D,EAAAwD,IACtCO,EAAAL,OAAA,SAAA1D,GAAmC,MAAA+C,GAAAa,EAAA5D,IAEnC+D,GACCN,EAAAC,GAEDM,EAAA,QAAAjB,GAAAa,EAAA5D,GAGA,QAAAgE,GAAA3K,GACA,QAAAA,EAAA,EAAAA,EAAA,KACAuK,EAAAtD,KAAAoB,IAAA,KAAArI,GAAAiH,KAAAgB,KAAAvB,EAAA1G,GAAA2G,GACA,EAAA4D,EAAAtD,KAAAoB,IAAA,MAAArI,GAAAiH,KAAAgB,KAAAvB,EAAA1G,GAAA2G,IAAA,EALA,GAAAD,GAAAO,KAAAuD,KAAA,GAAAD,EAAAtD,KAAAwD,IAAA,EAAAF,MAAA5D,GAAAwD,EAWA,OAHAQ,GAAAP,UAAA,SAAAG,GAAwC,MAAAb,GAAAa,EAAA5D,EAAAwD,IACxCQ,EAAAN,OAAA,SAAA1D,GAAqC,MAAA+C,GAAAa,EAAA5D,IAErCgE,GACCP,EAAAC,EAED3K,GAAAkL,WAAAtD,EACA5H,EAAAmL,SAAApD,EACA/H,EAAAoL,WAAAvD,EACA7H,EAAAqL,YAAAvD,EACA9H,EAAAsL,cAAAvD,EACA/H,EAAAuL,UAAArD,EACAlI,EAAAwL,YAAAxD,EACAhI,EAAAyL,aAAAxD,EACAjI,EAAA0L,eAAAxD,EACAlI,EAAA2L,SAAAxB,EACAnK,EAAA4L,WAAA7B,EACA/J,EAAA6L,YAAA3B,EACAlK,EAAA8L,cAAA3B,EACAnK,EAAA+L,QAAAvD,EACAxI,EAAAgM,UAAA7D,EACAnI,EAAAiM,WAAA3D,EACAtI,EAAAkM,aAAA1D,EACAxI,EAAAmM,QAAAtD,EACA7I,EAAAoM,UAAA1D,EACA1I,EAAAqM,WAAAzD,EACA5I,EAAAsM,aAAAzD,EACA7I,EAAAuM,WAAAvD,EACAhJ,EAAAwM,aAAA1D,EACA9I,EAAAyM,cAAA1D,EACA/I,EAAA0M,gBAAA1D,EACAhJ,EAAA2M,WAAAzD,EACAlJ,EAAA4M,aAAA3D,EACAjJ,EAAA6M,cAAA3D,EACAlJ,EAAA8M,gBAAAjD,EACA7J,EAAA+M,SAAAvC,EACAxK,EAAAgN,WAAA1C,EACAtK,EAAAiN,YAAA1C,EACAvK,EAAAkN,cAAA1C,EACAxK,EAAAmN,YAAAnC,EACAhL,EAAAoN,cAAAxC,EACA5K,EAAAqN,eAAArC,EACAhL,EAAAsN,iBAAArC,EAEArI,OAAAC,eAAA7C,EAAA,cAA8C2B,OAAA,OHmWxC4L,IACA,SAAUxN,EAAQC,EAASC,IInmBjC,SAAAC,EAAAC,GACAA,EAAAH,EAAAC,EAAA,OAGCG,KAAA,SAAAJ,EAAAwN,GAAoC,YASrC,SAAAC,KACA,UAAAC,GAGA,QAAAA,KACAtN,KAAAuN,QAsBA,QAAAC,GAAAH,EAAA5C,EAAAgD,GACA,GAAAvJ,GAAAmJ,EAAAzG,EAAA6D,EAAAgD,EACAC,EAAAxJ,EAAAuG,EACAkD,EAAAzJ,EAAAwJ,CACAL,GAAAnN,EAAAuK,EAAAkD,GAAAF,EAAAC,GA2BA,QAAAE,GAAA1J,GACA,MAAAA,GAAA,IAAAA,GAAA,EAAAmE,GAAAlB,KAAAyG,KAAA1J,GAGA,QAAAwG,GAAAxG,GACA,MAAAA,GAAA,EAAA+D,GAAA/D,GAAA,GAAA+D,GAAAd,KAAAuD,KAAAxG,GAGA,QAAA2J,GAAA3J,GACA,OAAAA,EAAAiE,GAAAjE,EAAA,IAAAA,EAGA,QAAAxC,MAEA,QAAAoM,GAAAC,EAAAC,GACAD,GAAAE,GAAA9M,eAAA4M,EAAA3M,OACA6M,GAAAF,EAAA3M,MAAA2M,EAAAC,GA8CA,QAAAE,GAAAC,EAAAH,EAAAI,GACA,GAAAC,GAAAlO,GAAA,EAAAC,EAAA+N,EAAA7N,OAAA8N,CAEA,KADAJ,EAAAM,cACAnO,EAAAC,GAAAiO,EAAAF,EAAAhO,GAAA6N,EAAArH,MAAA0H,EAAA,GAAAA,EAAA,GAAAA,EAAA,GACAL,GAAAO,UAGA,QAAAC,GAAAL,EAAAH,GACA,GAAA7N,IAAA,EAAAC,EAAA+N,EAAA7N,MAEA,KADA0N,EAAAS,iBACAtO,EAAAC,GAAA8N,EAAAC,EAAAhO,GAAA6N,EAAA,EACAA,GAAAU,aAGA,QAAAC,GAAAC,EAAAZ,GACAY,GAAAC,GAAA1N,eAAAyN,EAAAxN,MACAyN,GAAAD,EAAAxN,MAAAwN,EAAAZ,GAEAF,EAAAc,EAAAZ,GAgCA,QAAAc,KACAC,GAAApI,MAAAqI,EAGA,QAAAC,KACAC,EAAAC,GAAAC,IAGA,QAAAJ,GAAAK,EAAAC,GACAP,GAAApI,MAAAuI,EACAC,GAAAE,EAAAD,GAAAE,EACAD,GAAAE,GAAAD,GAAAC,GACAC,GAAAH,EAAAI,GAAAzH,GAAAsH,IAAA,EAAAI,IAAAC,GAAAxH,GAAAmH,GAGA,QAAAJ,GAAAG,EAAAC,GACAD,GAAAE,GAAAD,GAAAC,GACAD,IAAA,EAAAI,EAKA,IAAAE,GAAAP,EAAAG,GACAK,EAAAD,GAAA,OACAE,EAAAD,EAAAD,EACAG,EAAA/H,GAAAsH,GACAU,EAAA7H,GAAAmH,GACAW,EAAAN,GAAAK,EACAE,EAAAT,GAAAM,EAAAE,EAAAjI,GAAA8H,GACAK,EAAAF,EAAAJ,EAAA1H,GAAA2H,EACAM,IAAA5C,IAAA6C,GAAAF,EAAAD,IAGAV,GAAAH,EAAAI,GAAAM,EAAAJ,GAAAK,EAGA,QAAAM,GAAA1B,GAGA,MAFA2B,IAAAhD,QACAoB,EAAAC,EAAAG,IACA,EAAAwB,GAGA,QAAAC,GAAAC,GACA,OAAAJ,GAAAI,EAAA,GAAAA,EAAA,IAAA/F,EAAA+F,EAAA,KAGA,QAAAA,GAAAD,GACA,GAAAnB,GAAAmB,EAAA,GAAAlB,EAAAkB,EAAA,GAAAT,EAAA/H,GAAAsH,EACA,QAAAS,EAAA/H,GAAAqH,GAAAU,EAAA5H,GAAAkH,GAAAlH,GAAAmH,IAGA,QAAAoB,GAAAjG,EAAAgD,GACA,MAAAhD,GAAA,GAAAgD,EAAA,GAAAhD,EAAA,GAAAgD,EAAA,GAAAhD,EAAA,GAAAgD,EAAA,GAGA,QAAAkD,GAAAlG,EAAAgD,GACA,OAAAhD,EAAA,GAAAgD,EAAA,GAAAhD,EAAA,GAAAgD,EAAA,GAAAhD,EAAA,GAAAgD,EAAA,GAAAhD,EAAA,GAAAgD,EAAA,GAAAhD,EAAA,GAAAgD,EAAA,GAAAhD,EAAA,GAAAgD,EAAA,IAIA,QAAAmD,GAAAnG,EAAAgD,GACAhD,EAAA,IAAAgD,EAAA,GAAAhD,EAAA,IAAAgD,EAAA,GAAAhD,EAAA,IAAAgD,EAAA,GAGA,QAAAoD,GAAAC,EAAAb,GACA,OAAAa,EAAA,GAAAb,EAAAa,EAAA,GAAAb,EAAAa,EAAA,GAAAb,GAIA,QAAAc,GAAAlM,GACA,GAAAmM,GAAA5J,GAAAvC,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GACAA,GAAA,IAAAmM,EAAAnM,EAAA,IAAAmM,EAAAnM,EAAA,IAAAmM,EAsCA,QAAAC,GAAA5B,EAAAC,GACA4B,GAAAtP,KAAAuP,IAAAC,GAAA/B,EAAAgC,GAAAhC,IACAC,EAAAgC,QAAAhC,GACAA,EAAAiC,QAAAjC,GAGA,QAAAkC,GAAAnC,EAAAC,GACA,GAAAzI,GAAA4J,GAAApB,EAAAE,GAAAD,EAAAC,IACA,IAAAtI,GAAA,CACA,GAAAwK,GAAAd,EAAA1J,GAAAJ,GACA6K,GAAAD,EAAA,IAAAA,EAAA,MACAE,EAAAhB,EAAAe,EAAAD,EACAV,GAAAY,GACAA,EAAAnB,EAAAmB,EACA,IAGAC,GAHAC,EAAAxC,EAAAyC,GACAC,EAAAF,EAAA,OACAG,EAAAL,EAAA,GAAAM,GAAAF,EAEAG,EAAAC,GAAAN,GAAA,GACAK,IAAAH,EAAAD,GAAAE,KAAAD,EAAA1C,IACAuC,EAAAD,EAAA,GAAAM,GACAL,EAAAL,QAAAK,KACKI,KAAA,aAAAE,GAAAH,EAAAD,GAAAE,KAAAD,EAAA1C,IACLuC,GAAAD,EAAA,GAAAM,GACAL,EAAAN,QAAAM,KAEAtC,EAAAgC,QAAAhC,GACAA,EAAAiC,QAAAjC,KAEA4C,EACA7C,EAAAyC,GACAM,EAAAhB,GAAA/B,GAAA+C,EAAAhB,GAAAC,SAAAhC,GAEA+C,EAAA/C,EAAAgC,IAAAe,EAAAhB,GAAAC,MAAAD,GAAA/B,GAGAgC,IAAAD,IACA/B,EAAA+B,QAAA/B,GACAA,EAAAgC,QAAAhC,IAEAA,EAAAyC,GACAM,EAAAhB,GAAA/B,GAAA+C,EAAAhB,GAAAC,SAAAhC,GAEA+C,EAAA/C,EAAAgC,IAAAe,EAAAhB,GAAAC,MAAAD,GAAA/B,OAKA6B,IAAAtP,KAAAuP,IAAAC,GAAA/B,EAAAgC,GAAAhC,GAEAC,GAAAgC,QAAAhC,GACAA,EAAAiC,QAAAjC,GACArI,GAAAJ,EAAAiL,GAAAzC,EAGA,QAAAgD,KACAC,GAAA3L,MAAA6K,EAGA,QAAAe,KACApB,GAAA,GAAAC,GAAAD,GAAA,GAAAE,GACAiB,GAAA3L,MAAAsK,EACAhK,GAAA,KAGA,QAAAuL,GAAAnD,EAAAC,GACA,GAAArI,GAAA,CACA,GAAA4K,GAAAxC,EAAAyC,EACAW,IAAAjF,IAAA2E,GAAAN,GAAA,IAAAA,KAAA,YAAAA,OAEAa,IAAArD,EAAAsD,GAAArD,CAEAP,IAAApI,MAAA0I,EAAAC,GACAkC,EAAAnC,EAAAC,GAGA,QAAAsD,KACA7D,GAAAT,YAGA,QAAAuE,KACAL,EAAAE,GAAAC,IACA5D,GAAAR,UACA4D,GAAAM,IAAAK,KAAA1B,KAAAC,GAAA,MACAF,GAAA,GAAAC,GAAAD,GAAA,GAAAE,GACApK,GAAA,KAMA,QAAAmL,GAAA5C,EAAA6B,GACA,OAAAA,GAAA7B,GAAA,EAAA6B,EAAA,IAAAA,EAGA,QAAA0B,GAAAtI,EAAAgD,GACA,MAAAhD,GAAA,GAAAgD,EAAA,GAGA,QAAAuF,GAAAC,EAAA/O,GACA,MAAA+O,GAAA,IAAAA,EAAA,GAAAA,EAAA,IAAA/O,MAAA+O,EAAA,GAAA/O,EAAA+O,EAAA,IAAAA,EAAA,GAAA/O,EAGA,QAAAgP,GAAAC,GACA,GAAAhT,GAAAC,EAAAqK,EAAAgD,EAAA2F,EAAAC,EAAAxB,CAOA,IALAN,GAAAF,KAAAD,GAAAE,GAAAgC,KACApC,MACAvC,EAAAwE,EAAAb,IAGAlS,EAAA8Q,GAAA5Q,OAAA,CAIA,IAHA4Q,GAAAqC,KAAAR,GAGA5S,EAAA,EAAAsK,EAAAyG,GAAA,GAAAkC,GAAA3I,GAA4CtK,EAAAC,IAAOD,EACnDsN,EAAAyD,GAAA/Q,GACA6S,EAAAvI,EAAAgD,EAAA,KAAAuF,EAAAvI,EAAAgD,EAAA,KACA2E,EAAA3H,EAAA,GAAAgD,EAAA,IAAA2E,EAAA3H,EAAA,GAAAA,EAAA,MAAAA,EAAA,GAAAgD,EAAA,IACA2E,EAAA3E,EAAA,GAAAhD,EAAA,IAAA2H,EAAA3H,EAAA,GAAAA,EAAA,MAAAA,EAAA,GAAAgD,EAAA,KAEA2F,EAAAxR,KAAA6I,EAAAgD,EAMA,KAAA4F,IAAAC,KAAAlT,EAAAgT,EAAA9S,OAAA,EAAAH,EAAA,EAAAsK,EAAA2I,EAAAhT,GAA2ED,GAAAC,EAAQqK,EAAAgD,IAAAtN,EACnFsN,EAAA2F,EAAAjT,IACA0R,EAAAO,EAAA3H,EAAA,GAAAgD,EAAA,KAAA4F,MAAAxB,EAAAT,GAAA3D,EAAA,GAAA4D,GAAA5G,EAAA,IAMA,MAFAyG,IAAAC,GAAA,KAEAC,KAAAkC,KAAAhC,KAAAgC,MACAE,sBACApC,GAAAE,KAAAD,GAAAE,KAoCA,QAAAkC,GAAApE,EAAAC,GACAD,GAAAE,GAAAD,GAAAC,EACA,IAAAQ,GAAA/H,GAAAsH,EACAoE,GAAA3D,EAAA/H,GAAAqH,GAAAU,EAAA5H,GAAAkH,GAAAlH,GAAAmH,IAGA,QAAAoE,GAAAxP,EAAAC,EAAAwP,KACAC,GACAC,KAAA3P,EAAA2P,IAAAD,GACAE,KAAA3P,EAAA2P,IAAAF,GACAG,KAAAJ,EAAAI,IAAAH,GAGA,QAAAI,KACAC,GAAAtN,MAAAuN,EAGA,QAAAA,GAAA7E,EAAAC,GACAD,GAAAE,GAAAD,GAAAC,EACA,IAAAQ,GAAA/H,GAAAsH,EACA6E,IAAApE,EAAA/H,GAAAqH,GACA+E,GAAArE,EAAA5H,GAAAkH,GACAgF,GAAAlM,GAAAmH,GACA2E,GAAAtN,MAAA2N,EACAZ,EAAAS,GAAAC,GAAAC,IAGA,QAAAC,GAAAjF,EAAAC,GACAD,GAAAE,GAAAD,GAAAC,EACA,IAAAQ,GAAA/H,GAAAsH,GACApL,EAAA6L,EAAA/H,GAAAqH,GACAlL,EAAA4L,EAAA5H,GAAAkH,GACAsE,EAAAxL,GAAAmH,GACAiF,EAAAlE,GAAAjJ,IAAAmN,EAAAH,GAAAT,EAAAU,GAAAlQ,GAAAoQ,KAAAF,GAAAnQ,EAAAiQ,GAAAR,GAAAY,KAAAJ,GAAAhQ,EAAAiQ,GAAAlQ,GAAAqQ,GAAAJ,GAAAjQ,EAAAkQ,GAAAjQ,EAAAkQ,GAAAV,EACAa,KAAAD,EACAE,IAAAF,GAAAJ,OAAAjQ,IACAwQ,IAAAH,GAAAH,OAAAjQ,IACAwQ,IAAAJ,GAAAF,OAAAV,IACAD,EAAAS,GAAAC,GAAAC,IAGA,QAAAO,KACAX,GAAAtN,MAAA8M,EAKA,QAAAoB,KACAZ,GAAAtN,MAAAmO,EAGA,QAAAC,KACAC,EAAAC,GAAAC,IACAjB,GAAAtN,MAAA8M,EAGA,QAAAqB,GAAAzF,EAAAC,GACA2F,GAAA5F,EAAA6F,GAAA5F,EACAD,GAAAE,GAAAD,GAAAC,GACA0E,GAAAtN,MAAAqO,CACA,IAAAjF,GAAA/H,GAAAsH,EACA6E,IAAApE,EAAA/H,GAAAqH,GACA+E,GAAArE,EAAA5H,GAAAkH,GACAgF,GAAAlM,GAAAmH,GACAoE,EAAAS,GAAAC,GAAAC,IAGA,QAAAW,GAAA3F,EAAAC,GACAD,GAAAE,GAAAD,GAAAC,EACA,IAAAQ,GAAA/H,GAAAsH,GACApL,EAAA6L,EAAA/H,GAAAqH,GACAlL,EAAA4L,EAAA5H,GAAAkH,GACAsE,EAAAxL,GAAAmH,GACA6F,EAAAf,GAAAT,EAAAU,GAAAlQ,EACAiR,EAAAf,GAAAnQ,EAAAiQ,GAAAR,EACA0B,EAAAlB,GAAAhQ,EAAAiQ,GAAAlQ,EACAoR,EAAAlO,GAAA+N,IAAAC,IAAAC,KACAd,EAAA7J,EAAA4K,GACAnF,EAAAmF,IAAAf,EAAAe,CACAC,KAAApF,EAAAgF,EACAK,IAAArF,EAAAiF,EACAK,IAAAtF,EAAAkF,EACAb,IAAAD,EACAE,IAAAF,GAAAJ,OAAAjQ,IACAwQ,IAAAH,GAAAH,OAAAjQ,IACAwQ,IAAAJ,GAAAF,OAAAV,IACAD,EAAAS,GAAAC,GAAAC,IAGA,QAAAqB,GAAA9G,GACAgF,GAAAY,GACAX,GAAAC,GAAAC,GACAU,GAAAC,GAAAC,GACAY,GAAAC,GAAAC,GAAA,EACA9G,EAAAC,EAAAqF,GAEA,IAAA/P,GAAAqR,GACApR,EAAAqR,GACA7B,EAAA8B,GACAH,EAAApR,IAAAC,IAAAwP,GAGA,OAAA2B,GAAAK,KACAzR,EAAAuQ,GAAAtQ,EAAAuQ,GAAAf,EAAAgB,GAEAH,GAAA1B,KAAA5O,EAAA2P,GAAA1P,EAAA2P,GAAAH,EAAAI,IACAuB,EAAApR,IAAAC,IAAAwP,IAEA2B,EAAAK,KAAAnC,UAGAnD,GAAAlM,EAAAD,GAAA+N,GAAAvH,EAAAiJ,EAAAvM,GAAAkO,IAAArD,IAGA,QAAAhN,GAAAf,GACA,kBACA,MAAAA,IAIA,QAAA0R,GAAAnL,EAAAgD,GAEA,QAAAmI,GAAA1R,EAAAC,GACA,MAAAD,GAAAuG,EAAAvG,EAAAC,GAAAsJ,EAAAvJ,EAAA,GAAAA,EAAA,IAOA,MAJAuG,GAAAoL,QAAApI,EAAAoI,SAAAD,EAAAC,OAAA,SAAA3R,EAAAC,GACA,MAAAD,GAAAuJ,EAAAoI,OAAA3R,EAAAC,GAAAD,GAAAuG,EAAAoL,OAAA3R,EAAA,GAAAA,EAAA,MAGA0R,EAGA,QAAAE,GAAAzG,EAAAC,GACA,OAAAD,EAAAhH,GAAAgH,EAAAhF,GAAAgF,GAAAhH,GAAAgH,EAAAhF,GAAAgF,EAAAC,GAKA,QAAAyG,GAAAC,EAAAC,EAAAC,GACA,OAAAF,GAAA3L,IAAA4L,GAAAC,EAAAN,EAAAO,EAAAH,GAAAI,EAAAH,EAAAC,IACAC,EAAAH,GACAC,GAAAC,EAAAE,EAAAH,EAAAC,GACAJ,EAGA,QAAAO,GAAAL,GACA,gBAAA3G,EAAAC,GACA,MAAAD,IAAA2G,GAAA3G,EAAAhH,GAAAgH,EAAAhF,GAAAgF,GAAAhH,GAAAgH,EAAAhF,GAAAgF,EAAAC,IAIA,QAAA6G,GAAAH,GACA,GAAAM,GAAAD,EAAAL,EAEA,OADAM,GAAAT,OAAAQ,GAAAL,GACAM,EAGA,QAAAF,GAAAH,EAAAC,GAMA,QAAAI,GAAAjH,EAAAC,GACA,GAAAS,GAAA/H,GAAAsH,GACApL,EAAA8D,GAAAqH,GAAAU,EACA5L,EAAAgE,GAAAkH,GAAAU,EACA4D,EAAAxL,GAAAmH,GACAW,EAAA0D,EAAA4C,EAAArS,EAAAsS,CACA,QACAnG,GAAAlM,EAAAsS,EAAAxG,EAAAyG,EAAAxS,EAAAqS,EAAA5C,EAAA6C,GACA9L,EAAAuF,EAAAwG,EAAAtS,EAAAuS,IAbA,GAAAH,GAAAvO,GAAAiO,GACAO,EAAArO,GAAA8N,GACAQ,EAAAzO,GAAAkO,GACAQ,EAAAvO,GAAA+N,EA0BA,OAZAI,GAAAT,OAAA,SAAAxG,EAAAC,GACA,GAAAS,GAAA/H,GAAAsH,GACApL,EAAA8D,GAAAqH,GAAAU,EACA5L,EAAAgE,GAAAkH,GAAAU,EACA4D,EAAAxL,GAAAmH,GACAW,EAAA0D,EAAA8C,EAAAtS,EAAAuS,CACA,QACArG,GAAAlM,EAAAsS,EAAA9C,EAAA+C,EAAAxS,EAAAqS,EAAAtG,EAAAuG,GACA9L,EAAAuF,EAAAsG,EAAArS,EAAAsS,KAIAF,EAGA,QAAAA,IAAAK,GAGA,QAAAC,GAAAzI,GAEA,MADAA,GAAAwI,EAAAxI,EAAA,GAAAoB,GAAApB,EAAA,GAAAoB,IACApB,EAAA,IAAA8D,GAAA9D,EAAA,IAAA8D,GAAA9D,EAQA,MAZAwI,GAAAZ,EAAAY,EAAA,GAAApH,GAAAoH,EAAA,GAAApH,GAAAoH,EAAArW,OAAA,EAAAqW,EAAA,GAAApH,GAAA,GAOAqH,EAAAf,OAAA,SAAA1H,GAEA,MADAA,GAAAwI,EAAAd,OAAA1H,EAAA,GAAAoB,GAAApB,EAAA,GAAAoB,IACApB,EAAA,IAAA8D,GAAA9D,EAAA,IAAA8D,GAAA9D,GAGAyI,EAIA,QAAAC,IAAA7I,EAAA8I,EAAAjF,EAAAkF,EAAAC,EAAAC,GACA,GAAApF,EAAA,CACA,GAAAqF,GAAAlP,GAAA8O,GACAK,EAAAhP,GAAA2O,GACAM,EAAAL,EAAAlF,CACA,OAAAmF,GACAA,EAAAF,EAAAC,EAAA1M,GACA4M,EAAAH,EAAAM,EAAA,IAEAJ,EAAAK,GAAAH,EAAAF,GACAC,EAAAI,GAAAH,EAAAD,IACAF,EAAA,EAAAC,EAAAC,EAAAD,EAAAC,KAAAD,GAAAD,EAAA1M,IAEA,QAAA1D,GAAAzG,EAAA8W,EAAyBD,EAAA,EAAA7W,EAAA+W,EAAA/W,EAAA+W,EAAiC/W,GAAAkX,EAC1DzQ,EAAA6J,GAAA0G,GAAAC,EAAAnP,GAAA9H,IAAAiX,EAAAhP,GAAAjI,KACA8N,EAAArH,QAAA,GAAAA,EAAA,KAKA,QAAA0Q,IAAAH,EAAAvQ,GACAA,EAAA8J,EAAA9J,KAAA,IAAAuQ,EACAnG,EAAApK,EACA,IAAAmQ,GAAAlJ,GAAAjH,EAAA,GACA,UAAAA,EAAA,MAAAmQ,KAAAzM,GAAAyI,IAAAzI,GAGA,QAAAiN,MAQA,QAAA3Q,GAAAzC,EAAAC,GACAoT,EAAA3V,KAAAsC,EAAAyS,EAAAzS,EAAAC,IACAD,EAAA,IAAA+N,GAAA/N,EAAA,IAAA+N,GAGA,QAAAqF,KACA,GAAAhW,GAAAkW,EAAAjV,MAAAvC,KAAAK,WACAoX,EAAAX,EAAAvU,MAAAvC,KAAAK,WAAAkP,GACA1I,EAAA6Q,EAAAnV,MAAAvC,KAAAK,WAAAkP,EAMA,OALAgI,MACAZ,EAAAZ,GAAAzU,EAAA,GAAAiO,IAAAjO,EAAA,GAAAiO,GAAA,GAAAsG,OACAgB,GAAA7I,EAAAyJ,EAAA5Q,EAAA,GACAvF,GAASF,KAAA,UAAA+M,aAAAoJ,IACTA,EAAAZ,EAAA,KACArV,EArBA,GAGAiW,GACAZ,EAJAa,EAAAvS,GAAA,MACA6R,EAAA7R,EAAA,IACAyS,EAAAzS,EAAA,GAGA+I,GAAgBrH,QA+BhB,OAZA2Q,GAAAE,OAAA,SAAAjX,GACA,MAAAF,WAAAC,QAAAkX,EAAA,kBAAAjX,KAAA0E,IAAA1E,EAAA,IAAAA,EAAA,KAAA+W,GAAAE,GAGAF,EAAAR,OAAA,SAAAvW,GACA,MAAAF,WAAAC,QAAAwW,EAAA,kBAAAvW,KAAA0E,GAAA1E,GAAA+W,GAAAR,GAGAQ,EAAAI,UAAA,SAAAnX,GACA,MAAAF,WAAAC,QAAAoX,EAAA,kBAAAnX,KAAA0E,GAAA1E,GAAA+W,GAAAI,GAGAJ,EAGA,QAAAK,MACA,GACAC,GADAC,IAEA,QACAlR,MAAA,SAAAzC,EAAAC,GACAyT,EAAAhW,MAAAsC,EAAAC,KAEAmK,UAAA,WACAuJ,EAAAjW,KAAAgW,OAEArJ,QAAA7M,EACAoW,OAAA,WACAD,EAAAvX,OAAA,GAAAuX,EAAAjW,KAAAiW,EAAAE,MAAApW,OAAAkW,EAAAG,WAEAC,OAAA,WACA,GAAAA,GAAAJ,CAGA,OAFAA,MACAD,EAAA,KACAK,IAKA,QAAAC,IAAAzN,EAAAgD,GACA,MAAA0E,IAAA1H,EAAA,GAAAgD,EAAA,IAAAqF,IAAAX,GAAA1H,EAAA,GAAAgD,EAAA,IAAAqF,GAGA,QAAAqF,IAAAxR,EAAAyR,EAAAC,EAAAC,GACAtY,KAAAkE,EAAAyC,EACA3G,KAAA2T,EAAAyE,EACApY,KAAAuY,EAAAF,EACArY,KAAA6J,EAAAyO,EACAtY,KAAAmQ,GAAA,EACAnQ,KAAAI,EAAAJ,KAAA6G,EAAA,KAMA,QAAA2R,IAAAC,EAAAC,EAAAC,EAAAC,EAAA5K,GACA,GAEA7N,GACAC,EAHA2D,KACA8U,IAwBA,IApBAJ,EAAAK,QAAA,SAAAC,GACA,MAAA3Y,EAAA2Y,EAAAzY,OAAA,QACA,GAAAF,GAAA8D,EAAA+C,EAAA8R,EAAA,GAAAC,EAAAD,EAAA3Y,EAKA,IAAA8X,GAAAjR,EAAA+R,GAAA,CAEA,IADAhL,EAAAM,YACAnO,EAAA,EAAiBA,EAAAC,IAAOD,EAAA6N,EAAArH,OAAAM,EAAA8R,EAAA5Y,IAAA,GAAA8G,EAAA,GAExB,YADA+G,GAAAO,UAIAxK,EAAAnC,KAAAsC,EAAA,GAAAiU,IAAAlR,EAAA8R,EAAA,UACAF,EAAAjX,KAAAsC,EAAAqU,EAAA,GAAAJ,IAAAlR,EAAA,KAAA/C,GAAA,IACAH,EAAAnC,KAAAsC,EAAA,GAAAiU,IAAAa,EAAAD,EAAA,UACAF,EAAAjX,KAAAsC,EAAAqU,EAAA,GAAAJ,IAAAa,EAAA,KAAA9U,GAAA,OAGAH,EAAAzD,OAAA,CAMA,IAJAuY,EAAAtF,KAAAmF,GACAO,GAAAlV,GACAkV,GAAAJ,GAEA1Y,EAAA,EAAAC,EAAAyY,EAAAvY,OAA8BH,EAAAC,IAAOD,EACrC0Y,EAAA1Y,GAAA0J,EAAA8O,IAOA,KAJA,GACAP,GACAzR,EAFAuS,EAAAnV,EAAA,KAIA,CAIA,IAFA,GAAAoV,GAAAD,EACAE,GAAA,EACAD,EAAAhJ,GAAA,IAAAgJ,IAAA/Y,KAAA8Y,EAAA,MACAd,GAAAe,EAAAxF,EACA3F,EAAAM,WACA,IAEA,GADA6K,EAAAhJ,EAAAgJ,EAAAZ,EAAApI,GAAA,EACAgJ,EAAAtP,EAAA,CACA,GAAAuP,EACA,IAAAjZ,EAAA,EAAAC,EAAAgY,EAAA9X,OAAwCH,EAAAC,IAAOD,EAAA6N,EAAArH,SAAAyR,EAAAjY,IAAA,GAAAwG,EAAA,QAE/CiS,GAAAO,EAAAjV,EAAAiV,EAAA/Y,EAAA8D,EAAA,EAAA8J,EAEAmL,KAAA/Y,MACO,CACP,GAAAgZ,EAEA,IADAhB,EAAAe,EAAAtS,EAAA8M,EACAxT,EAAAiY,EAAA9X,OAAA,EAAqCH,GAAA,IAAQA,EAAA6N,EAAArH,SAAAyR,EAAAjY,IAAA,GAAAwG,EAAA,QAE7CiS,GAAAO,EAAAjV,EAAAiV,EAAAtS,EAAA3C,GAAA,EAAA8J,EAEAmL,KAAAtS,EAEAsS,IAAAZ,EACAH,EAAAe,EAAAxF,EACAyF,YACKD,EAAAhJ,EACLnC,GAAAO,YAIA,QAAA0K,IAAAI,GACA,GAAAjZ,EAAAiZ,EAAA/Y,OAAA,CAKA,IAJA,GAAAF,GAGAqN,EAFAtN,EAAA,EACAsK,EAAA4O,EAAA,KAEAlZ,EAAAC,GACAqK,EAAArK,EAAAqN,EAAA4L,EAAAlZ,GACAsN,EAAA5G,EAAA4D,EACAA,EAAAgD,CAEAhD,GAAArK,EAAAqN,EAAA4L,EAAA,GACA5L,EAAA5G,EAAA4D,GAKA,QAAA6O,IAAAC,EAAA5S,GACA,GAAA0I,GAAA1I,EAAA,GACA2I,EAAA3I,EAAA,GACAqJ,EAAA7H,GAAAmH,GACAmC,GAAAtJ,GAAAkH,IAAArH,GAAAqH,GAAA,GACA+C,EAAA,EACAoH,EAAA,CAEAC,IAAAlM,QAEA,IAAAyC,EAAAV,EAAArH,GAAA6K,GACA9C,KAAA,IAAAV,GAAArH,GAAA6K,GAEA,QAAA3S,GAAA,EAAAC,EAAAmZ,EAAAjZ,OAAqCH,EAAAC,IAAOD,EAC5C,GAAAmV,GAAAiC,EAAAgC,EAAApZ,IAAAG,OASA,OARAiX,GACAjC,EACAoE,EAAAnC,EAAAjC,EAAA,GACA9F,EAAAkK,EAAA,GACApI,EAAAoI,EAAA,KAAAhK,GACAC,EAAAxH,GAAAmJ,GACA7B,EAAAzH,GAAAsJ,GAEAqI,EAAA,EAAmBA,EAAArE,IAAOqE,EAAAnK,EAAA6B,EAAA1B,EAAAiK,EAAAnK,EAAAoK,EAAAH,EAAAI,EAAA,CAC1B,GAAAA,GAAAvC,EAAAoC,GACAtI,EAAAyI,EAAA,GACAvI,EAAAuI,EAAA,KAAApK,GACAkK,EAAAzR,GAAAoJ,GACAsI,EAAA7R,GAAAuJ,GACAM,EAAAR,EAAA7B,EACAuC,EAAAF,GAAA,OACAkI,EAAAhI,EAAAF,EACAK,EAAA6H,EAAA1R,GACA4H,EAAAN,EAAAiK,CAOA,IALAH,GAAAjM,IAAA6C,GAAAJ,EAAA8B,EAAA5J,GAAA4R,GAAAtK,EAAAoK,EAAA5J,EAAAjI,GAAA+R,KACA3H,GAAAF,EAAAL,EAAAE,EAAA1H,GAAAwH,EAIAK,EAAA1C,GAAAH,EAAAgC,GAAAhC,EAAA,CACA,GAAA2K,GAAArJ,EAAAF,EAAAiJ,GAAAjJ,EAAAqJ,GACA/I,GAAAiJ,EACA,IAAAC,GAAAtJ,EAAAc,EAAAuI,EACAjJ,GAAAkJ,EACA,IAAAC,IAAAhI,EAAAL,GAAA,QAAAnH,EAAAuP,EAAA,KACA3K,EAAA4K,GAAA5K,IAAA4K,IAAAF,EAAA,IAAAA,EAAA,OACAR,GAAAtH,EAAAL,GAAA,SAiBA,OAAAO,GAAAU,IAAAV,EAAAU,IAAA2G,IAAA3G,IAAA,EAAA0G,EAGA,QAAAX,IAAAsB,EAAAC,EAAAxB,EAAAM,GACA,gBAAAmB,GA+CA,QAAA1T,GAAA0I,EAAAC,GACA6K,EAAA9K,EAAAC,IAAA+K,EAAA1T,MAAA0I,EAAAC,GAGA,QAAAgL,GAAAjL,EAAAC,GACAsI,EAAAjR,MAAA0I,EAAAC,GAGA,QAAAhB,KACAuK,EAAAlS,MAAA2T,EACA1C,EAAAtJ,YAGA,QAAAC,KACAsK,EAAAlS,QACAiR,EAAArJ,UAGA,QAAAgM,GAAAlL,EAAAC,GACAiI,EAAA3V,MAAAyN,EAAAC,IACAkL,EAAA7T,MAAA0I,EAAAC,GAGA,QAAAmL,KACAD,EAAAlM,YACAiJ,KAGA,QAAAmD,KACAH,EAAAhD,EAAA,MAAAA,EAAA,OACAiD,EAAAjM,SAEA,IAEApO,GAAAmV,EACAyD,EACApS,EAJAgU,EAAAH,EAAAG,QACAC,EAAAC,EAAA5C,SACA7X,EAAAwa,EAAAta,MAQA,IAJAiX,EAAAQ,MACAwB,EAAA3X,KAAA2V,GACAA,EAAA,KAEAnX,EAGA,KAAAua,GAEA,GADA5B,EAAA6B,EAAA,IACAtF,EAAAyD,EAAAzY,OAAA,MAGA,IAFAwa,IAAAT,EAAA5L,eAAAqM,GAAA,GACAT,EAAA/L,YACAnO,EAAA,EAAqBA,EAAAmV,IAAOnV,EAAAka,EAAA1T,SAAAoS,EAAA5Y,IAAA,GAAAwG,EAAA,GAC5B0T,GAAA9L,eAOAnO,GAAA,KAAAua,GAAAC,EAAAhZ,KAAAgZ,EAAA7C,MAAApW,OAAAiZ,EAAA5C,UAEAS,EAAA7W,KAAAgZ,EAAAxV,OAAA2V,KA1GA,GAIAxB,GACAd,EACAlB,EANAK,EAAAwC,EAAAC,GACAQ,EAAAlD,KACA6C,EAAAJ,EAAAS,GACAC,GAAA,EAKAjC,GACAlS,QACA2H,YACAC,UACAE,aAAA,WACAoK,EAAAlS,MAAA4T,EACA1B,EAAAvK,UAAAmM,EACA5B,EAAAtK,QAAAmM,EACAjC,KACAc,MAEA7K,WAAA,WACAmK,EAAAlS,QACAkS,EAAAvK,YACAuK,EAAAtK,UACAkK,EAAArL,EAAA4N,MAAAvC,EACA,IAAAE,GAAAW,GAAAC,EAAAL,EACAT,GAAAnY,QACAwa,IAAAT,EAAA5L,eAAAqM,GAAA,GACAtC,GAAAC,EAAAC,GAAAC,EAAAC,EAAAyB,IACS1B,IACTmC,IAAAT,EAAA5L,eAAAqM,GAAA,GACAT,EAAA/L,YACAsK,EAAA,YAAAyB,GACAA,EAAA9L,WAEAuM,IAAAT,EAAA3L,aAAAoM,GAAA,GACArC,EAAAc,EAAA,MAEA0B,OAAA,WACAZ,EAAA5L,eACA4L,EAAA/L,YACAsK,EAAA,YAAAyB,GACAA,EAAA9L,UACA8L,EAAA3L,cAmEA,OAAAmK,IAIA,QAAAkC,IAAAhC,GACA,MAAAA,GAAAzY,OAAA,EAKA,QAAAoY,IAAAjO,EAAAgD,GACA,QAAAhD,IAAAvG,GAAA,KAAAuG,EAAA,GAAAxC,GAAA6K,GAAA7K,GAAAwC,EAAA,MACAgD,IAAAvJ,GAAA,KAAAuJ,EAAA,GAAAxF,GAAA6K,GAAA7K,GAAAwF,EAAA,IAaA,QAAAyN,IAAAlN,GACA,GAGA2M,GAHAnL,EAAAgE,IACAlC,EAAAkC,IACA2H,EAAA3H,GAGA,QACAlF,UAAA,WACAN,EAAAM,YACAqM,EAAA,GAEAhU,MAAA,SAAA0K,EAAAE,GACA,GAAA6J,GAAA/J,EAAA,EAAAhJ,OACAwJ,EAAAM,GAAAd,EAAA7B,EACA2C,IAAAN,EAAAxJ,IAAAyK,IACA9E,EAAArH,MAAA6I,EAAA8B,KAAAC,GAAA,IAAAtJ,QACA+F,EAAArH,MAAAwU,EAAA7J,GACAtD,EAAAO,UACAP,EAAAM,YACAN,EAAArH,MAAAyU,EAAA9J,GACAtD,EAAArH,MAAA0K,EAAAC,GACAqJ,EAAA,GACOQ,IAAAC,GAAAvJ,GAAAxJ,KACP8J,GAAA3C,EAAA2L,GAAArI,KAAAtD,GAAA2L,EAAArI,IACAX,GAAAd,EAAA+J,GAAAtI,KAAAzB,GAAA+J,EAAAtI,IACAxB,EAAA+J,GAAA7L,EAAA8B,EAAAD,EAAAE,GACAvD,EAAArH,MAAAwU,EAAA7J,GACAtD,EAAAO,UACAP,EAAAM,YACAN,EAAArH,MAAAyU,EAAA9J,GACAqJ,EAAA,GAEA3M,EAAArH,MAAA6I,EAAA6B,EAAAC,EAAAC,GACA4J,EAAAC,GAEA7M,QAAA,WACAP,EAAAO,UACAiB,EAAA8B,EAAAkC,KAEAmH,MAAA,WACA,SAAAA,IAKA,QAAAU,IAAA7L,EAAA8B,EAAAD,EAAAE,GACA,GAAA9B,GACAoK,EACAyB,EAAAnT,GAAAqH,EAAA6B,EACA,OAAAc,IAAAmJ,GAAAxI,GACAyI,IAAApT,GAAAmJ,IAAAuI,EAAA7R,GAAAuJ,IAAApJ,GAAAkJ,GACAlJ,GAAAoJ,IAAA9B,EAAAzH,GAAAsJ,IAAAnJ,GAAAqH,KACAC,EAAAoK,EAAAyB,KACAhK,EAAAC,GAAA,EAGA,QAAAiK,IAAAC,EAAAC,EAAA3E,EAAA/I,GACA,GAAAsB,EACA,UAAAmM,EACAnM,EAAAyH,EAAA9O,GACA+F,EAAArH,OAAA0B,GAAAiH,GACAtB,EAAArH,MAAA,EAAA2I,GACAtB,EAAArH,MAAA0B,GAAAiH,GACAtB,EAAArH,MAAA0B,GAAA,GACA2F,EAAArH,MAAA0B,IAAAiH,GACAtB,EAAArH,MAAA,GAAA2I,GACAtB,EAAArH,OAAA0B,IAAAiH,GACAtB,EAAArH,OAAA0B,GAAA,GACA2F,EAAArH,OAAA0B,GAAAiH,OACG,IAAA6C,GAAAsJ,EAAA,GAAAC,EAAA,IAAA5I,GAAA,CACH,GAAAzD,GAAAoM,EAAA,GAAAC,EAAA,GAAArT,MACAiH,GAAAyH,EAAA1H,EAAA,EACArB,EAAArH,OAAA0I,EAAAC,GACAtB,EAAArH,MAAA,EAAA2I,GACAtB,EAAArH,MAAA0I,EAAAC,OAEAtB,GAAArH,MAAA+U,EAAA,GAAAA,EAAA,IAIA,QAAAC,IAAA7E,GAMA,QAAA8B,GAAA6C,EAAAC,EAAA3E,EAAA/I,GACA6I,GAAA7I,EAAA8I,EAAAjF,EAAAkF,EAAA0E,EAAAC,GAGA,QAAAE,GAAAvM,EAAAC,GACA,MAAAtH,IAAAqH,GAAArH,GAAAsH,GAAAuM,EAOA,QAAAzB,GAAApM,GACA,GAAA0L,GACAoC,EACAC,EACAC,EACArB,CACA,QACArM,UAAA,WACA0N,EAAAD,GAAA,EACApB,EAAA,GAEAhU,MAAA,SAAA0I,EAAAC,GACA,GACA2M,GADAnC,GAAAzK,EAAAC,GAEAa,EAAAyL,EAAAvM,EAAAC,GACAhO,EAAA4a,EACA/L,EAAA,EAAAgM,EAAA9M,EAAAC,GACAa,EAAAgM,EAAA9M,KAAA,EAAAhH,QAAAiH,GAAA,CAYA,KAXAoK,IAAAsC,EAAAD,EAAA5L,IAAAnC,EAAAM,YAGA6B,IAAA4L,IACAE,EAAAG,EAAA1C,EAAAI,KACAmC,GAAA/D,GAAAwB,EAAAuC,IAAA/D,GAAA4B,EAAAmC,MACAnC,EAAA,IAAAhH,GACAgH,EAAA,IAAAhH,GACA3C,EAAAyL,EAAA9B,EAAA,GAAAA,EAAA,MAGA3J,IAAA4L,EACApB,EAAA,EACAxK,GAEAnC,EAAAM,YACA2N,EAAAG,EAAAtC,EAAAJ,GACA1L,EAAArH,MAAAsV,EAAA,GAAAA,EAAA,MAGAA,EAAAG,EAAA1C,EAAAI,GACA9L,EAAArH,MAAAsV,EAAA,GAAAA,EAAA,IACAjO,EAAAO,WAEAmL,EAAAuC,MACS,IAAAI,GAAA3C,GAAAwC,EAAA/L,EAAA,CACT,GAAAjQ,EAGAoB,GAAAwa,KAAA5b,EAAAkc,EAAAtC,EAAAJ,GAAA,MACAiB,EAAA,EACAuB,GACAlO,EAAAM,YACAN,EAAArH,MAAAzG,EAAA,MAAAA,EAAA,OACA8N,EAAArH,MAAAzG,EAAA,MAAAA,EAAA,OACA8N,EAAAO,YAEAP,EAAArH,MAAAzG,EAAA,MAAAA,EAAA,OACA8N,EAAAO,UACAP,EAAAM,YACAN,EAAArH,MAAAzG,EAAA,MAAAA,EAAA,UAIAiQ,GAAAuJ,GAAAxB,GAAAwB,EAAAI,IACA9L,EAAArH,MAAAmT,EAAA,GAAAA,EAAA,IAEAJ,EAAAI,EAAAiC,EAAA5L,EAAA2L,EAAAxa,GAEAiN,QAAA,WACAwN,GAAA/N,EAAAO,UACAmL,EAAA,MAIAiB,MAAA,WACA,MAAAA,IAAAqB,GAAAD,IAAA,IAMA,QAAAK,GAAA3R,EAAAgD,EAAA6O,GACA,GAAAC,GAAA9L,EAAAhG,GACA+R,EAAA/L,EAAAhD,GAIAgP,GAAA,OACAC,EAAA/L,EAAA4L,EAAAC,GACAG,EAAAjM,EAAAgM,KACAE,EAAAF,EAAA,GACAG,EAAAF,EAAAC,GAGA,KAAAC,EAAA,OAAAP,GAAA7R,CAEA,IAAAqS,GAAAjB,EAAAc,EAAAE,EACAE,GAAAlB,EAAAe,EAAAC,EACAG,EAAArM,EAAA8L,EAAAC,GACAO,EAAApM,EAAA4L,EAAAK,GACAI,EAAArM,EAAA6L,EAAAK,EACAnM,GAAAqM,EAAAC,EAGA,IAAAhN,GAAA8M,EACAzI,EAAA7D,EAAAuM,EAAA/M,GACAiN,EAAAzM,EAAAR,KACAkN,EAAA7I,IAAA4I,GAAAzM,EAAAuM,KAAA,EAEA,MAAAG,EAAA,IAEA,GAAAld,GAAAkH,GAAAgW,GACAC,EAAAxM,EAAAX,IAAAqE,EAAArU,GAAAid,EAIA,IAHAvM,EAAAyM,EAAAJ,GACAI,EAAA7M,EAAA6M,IAEAf,EAAA,MAAAe,EAGA,IAIA1J,GAJAnE,EAAA/E,EAAA,GACA4G,EAAA5D,EAAA,GACA6D,EAAA7G,EAAA,GACA8G,EAAA9D,EAAA,EAGA4D,GAAA7B,IAAAmE,EAAAnE,IAAA6B,IAAAsC,EAEA,IAAA9B,GAAAR,EAAA7B,EACA8N,EAAAnL,GAAAN,EAAAxJ,IAAAyK,GACAyK,EAAAD,GAAAzL,EAAAiB,EAKA,KAHAwK,GAAA/L,EAAAD,IAAAqC,EAAArC,IAAAC,IAAAoC,GAGA4J,EACAD,EACAhM,EAAAC,EAAA,EAAA8L,EAAA,IAAAlL,GAAAkL,EAAA,GAAA7N,GAAAsD,GAAAxB,EAAAC,GACAD,GAAA+L,EAAA,IAAAA,EAAA,IAAA9L,EACAM,EAAAxJ,IAAAmH,GAAA6N,EAAA,IAAAA,EAAA,IAAAhM,GAAA,CACA,GAAAmM,GAAA3M,EAAAX,IAAAqE,EAAArU,GAAAid,EAEA,OADAvM,GAAA4M,EAAAP,IACAI,EAAA7M,EAAAgN,MAMA,QAAArB,GAAA9M,EAAAC,GACA,GAAAmI,GAAAyE,EAAApF,EAAAzO,GAAAyO,EACAqF,EAAA,CAKA,OAJA9M,IAAAoI,EAAA0E,GAAA,EACA9M,EAAAoI,IAAA0E,GAAA,GACA7M,GAAAmI,EAAA0E,GAAA,EACA7M,EAAAmI,IAAA0E,GAAA,GACAA,EA1KA,GAAAN,GAAA7T,GAAA8O,GACAjF,EAAA,EAAAtC,GACA2M,EAAAL,EAAA,EACAQ,EAAAlK,GAAA0J,GAAA/I,EA0KA,OAAA+F,IAAA+C,EAAAxB,EAAAxB,EAAAsD,GAAA,GAAApF,KAAAzO,GAAAyO,EAAAzO,KAGA,QAAA+R,IAAA3P,EAAAgD,EAAA0G,EAAAC,EAAAqJ,EAAAC,GACA,GAQAjG,GARAkG,EAAAlT,EAAA,GACAmT,EAAAnT,EAAA,GACAoT,EAAApQ,EAAA,GACAqQ,EAAArQ,EAAA,GACAuJ,EAAA,EACAC,EAAA,EACA7S,EAAAyZ,EAAAF,EACAtZ,EAAAyZ,EAAAF,CAIA,IADAnG,EAAAtD,EAAAwJ,EACAvZ,KAAAqT,EAAA,IAEA,GADAA,GAAArT,EACAA,EAAA,GACA,GAAAqT,EAAAT,EAAA,MACAS,GAAAR,MAAAQ,OACG,IAAArT,EAAA,GACH,GAAAqT,EAAAR,EAAA,MACAQ,GAAAT,MAAAS,GAIA,GADAA,EAAAgG,EAAAE,EACAvZ,KAAAqT,EAAA,IAEA,GADAA,GAAArT,EACAA,EAAA,GACA,GAAAqT,EAAAR,EAAA,MACAQ,GAAAT,MAAAS,OACG,IAAArT,EAAA,GACH,GAAAqT,EAAAT,EAAA,MACAS,GAAAR,MAAAQ,GAIA,GADAA,EAAArD,EAAAwJ,EACAvZ,KAAAoT,EAAA,IAEA,GADAA,GAAApT,EACAA,EAAA,GACA,GAAAoT,EAAAT,EAAA,MACAS,GAAAR,MAAAQ,OACG,IAAApT,EAAA,GACH,GAAAoT,EAAAR,EAAA,MACAQ,GAAAT,MAAAS,GAIA,GADAA,EAAAiG,EAAAE,EACAvZ,KAAAoT,EAAA,IAEA,GADAA,GAAApT,EACAA,EAAA,GACA,GAAAoT,EAAAR,EAAA,MACAQ,GAAAT,MAAAS,OACG,IAAApT,EAAA,GACH,GAAAoT,EAAAT,EAAA,MACAS,GAAAR,MAAAQ,GAKA,MAFAT,GAAA,IAAAvM,EAAA,GAAAkT,EAAA3G,EAAA5S,EAAAqG,EAAA,GAAAmT,EAAA5G,EAAA3S,GACA4S,EAAA,IAAAxJ,EAAA,GAAAkQ,EAAA1G,EAAA7S,EAAAqJ,EAAA,GAAAmQ,EAAA3G,EAAA5S,IACA,MASA,QAAA0Z,IAAA5J,EAAAC,EAAAqJ,EAAAC,GAEA,QAAA9B,GAAA1X,EAAAC,GACA,MAAAgQ,IAAAjQ,MAAAuZ,GAAArJ,GAAAjQ,MAAAuZ,EAGA,QAAA9E,GAAA6C,EAAAC,EAAA3E,EAAA/I,GACA,GAAAvD,GAAA,EAAAuT,EAAA,CACA,UAAAvC,IACAhR,EAAAwT,EAAAxC,EAAA1E,OAAAiH,EAAAC,EAAAvC,EAAA3E,KACAmH,EAAAzC,EAAAC,GAAA,EAAA3E,EAAA,GACA,EAAA/I,GAAArH,MAAA,IAAA8D,GAAA,IAAAA,EAAA0J,EAAAsJ,EAAAhT,EAAA,EAAAiT,EAAAtJ,UACA3J,KAAAsM,EAAA,QAAAiH,OAEAhQ,GAAArH,MAAA+U,EAAA,GAAAA,EAAA,IAIA,QAAAuC,GAAApX,EAAAkQ,GACA,MAAA5E,IAAAtL,EAAA,GAAAsN,GAAArB,GAAAiE,EAAA,MACA5E,GAAAtL,EAAA,GAAA4W,GAAA3K,GAAAiE,EAAA,MACA5E,GAAAtL,EAAA,GAAAuN,GAAAtB,GAAAiE,EAAA,MACAA,EAAA,MAGA,QAAA2B,GAAAjO,EAAAgD,GACA,MAAAyQ,GAAAzT,EAAAvG,EAAAuJ,EAAAvJ,GAGA,QAAAga,GAAAzT,EAAAgD,GACA,GAAA0Q,GAAAF,EAAAxT,EAAA,GACA2T,EAAAH,EAAAxQ,EAAA,EACA,OAAA0Q,KAAAC,EAAAD,EAAAC,EACA,IAAAD,EAAA1Q,EAAA,GAAAhD,EAAA,GACA,IAAA0T,EAAA1T,EAAA,GAAAgD,EAAA,GACA,IAAA0Q,EAAA1T,EAAA,GAAAgD,EAAA,GACAA,EAAA,GAAAhD,EAAA,GAGA,gBAAAuD,GAmBA,QAAArH,GAAAzC,EAAAC,GACAyX,EAAA1X,EAAAC,IAAAka,EAAA1X,MAAAzC,EAAAC,GAGA,QAAAma,KAGA,OAFA9E,GAAA,EAEArZ,EAAA,EAAAC,EAAAmZ,EAAAjZ,OAAyCH,EAAAC,IAAOD,EAChD,OAAAoe,GAAAP,EAAAzG,EAAAgC,EAAApZ,GAAAwZ,EAAA,EAAArE,EAAAiC,EAAAjX,OAAAqG,EAAA4Q,EAAA,GAAAvO,EAAArC,EAAA,GAAAoC,EAAApC,EAAA,GAAkHgT,EAAArE,IAAOqE,EACzH4E,EAAAvV,EAAAgV,EAAAjV,EAAApC,EAAA4Q,EAAAoC,GAAA3Q,EAAArC,EAAA,GAAAoC,EAAApC,EAAA,GACAqX,GAAAN,EAAyB3U,EAAA2U,IAAA1U,EAAAuV,IAAAb,EAAAM,IAAAjV,EAAAiV,IAAA7J,EAAAoK,MAAA/E,EACTzQ,GAAA2U,IAAA1U,EAAAuV,IAAAb,EAAAM,IAAAjV,EAAAiV,IAAA7J,EAAAoK,MAAA/E,CAIhB,OAAAA,GAIA,QAAA/K,KACA4P,EAAAG,EAAA/F,KAAAc,KAAAoB,GAAA,EAGA,QAAAjM,KACA,GAAAiK,GAAA2F,IACAG,EAAA9D,GAAAhC,EACAiD,GAAAnD,EAAArL,EAAA4N,MAAAvC,IAAAnY,QACAme,GAAA7C,KACA5N,EAAAS,eACAgQ,IACAzQ,EAAAM,YACAsK,EAAA,YAAA5K,GACAA,EAAAO,WAEAqN,GACApD,GAAAC,EAAAC,EAAAC,EAAAC,EAAA5K,GAEAA,EAAAU,cAEA2P,EAAArQ,EAAAyK,EAAAc,EAAAhC,EAAA,KAGA,QAAAjJ,KACAoQ,EAAA/X,MAAA6K,EACA+H,KAAA3X,KAAA2V,MACAoH,GAAA,EACAC,GAAA,EACAC,EAAAC,EAAAtL,IAMA,QAAAjF,KACAkK,IACAjH,EAAAuN,EAAAC,GACAC,GAAAL,GAAAJ,EAAA1G,SACAW,EAAA7W,KAAA4c,EAAAvG,WAEAyG,EAAA/X,QACAiY,GAAAP,EAAA9P,UAGA,QAAAiD,GAAAtN,EAAAC,GACA,GAAAgM,GAAAyL,EAAA1X,EAAAC,EAEA,IADAoV,GAAAhC,EAAA3V,MAAAsC,EAAAC,IACAwa,EACAI,EAAA7a,EAAA8a,EAAA7a,EAAA8a,EAAA9O,EACAwO,GAAA,EACAxO,IACAkO,EAAA/P,YACA+P,EAAA1X,MAAAzC,EAAAC,QAGA,IAAAgM,GAAAyO,EAAAP,EAAA1X,MAAAzC,EAAAC,OACA,CACA,GAAAsG,IAAAoU,EAAA1X,KAAAwD,IAAAuU,GAAA/X,KAAAgY,IAAAC,GAAAP,IAAAC,EAAA3X,KAAAwD,IAAAuU,GAAA/X,KAAAgY,IAAAC,GAAAN,KACArR,GAAAvJ,EAAAiD,KAAAwD,IAAAuU,GAAA/X,KAAAgY,IAAAC,GAAAlb,IAAAC,EAAAgD,KAAAwD,IAAAuU,GAAA/X,KAAAgY,IAAAC,GAAAjb,IACAiW,IAAA3P,EAAAgD,EAAA0G,EAAAC,EAAAqJ,EAAAC,IACAkB,IACAP,EAAA/P,YACA+P,EAAA1X,MAAA8D,EAAA,GAAAA,EAAA,KAEA4T,EAAA1X,MAAA8G,EAAA,GAAAA,EAAA,IACA0C,GAAAkO,EAAA9P,UACAoM,GAAA,GACWxK,IACXkO,EAAA/P,YACA+P,EAAA1X,MAAAzC,EAAAC,GACAwW,GAAA,GAIAkE,EAAA3a,EAAA4a,EAAA3a,EAAAya,EAAAzO,EA/GA,GAEAsI,GACAc,EACAhC,EACAwH,EAAAC,EAAAC,EACAJ,EAAAC,EAAAF,EACAD,EACAhE,EARA0D,EAAArQ,EACAwQ,EAAA7G,KASA+G,GACA/X,QACA2H,YACAC,UACAE,eACAC,aAmGA,OAAAgQ,IAIA,QAAAW,MACA,GAIAC,GACAC,EACA1G,EANA1E,EAAA,EACAC,EAAA,EACAqJ,EAAA,IACAC,EAAA,GAKA,OAAA7E,IACA7K,OAAA,SAAAA,GACA,MAAAsR,IAAAC,IAAAvR,EAAAsR,IAAAvB,GAAA5J,EAAAC,EAAAqJ,EAAAC,GAAA6B,EAAAvR,IAEAqR,OAAA,SAAA9e,GACA,MAAAF,WAAAC,QAAA6T,GAAA5T,EAAA,MAAA6T,GAAA7T,EAAA,MAAAkd,GAAAld,EAAA,MAAAmd,GAAAnd,EAAA,MAAA+e,EAAAC,EAAA,KAAA1G,KAAA1E,EAAAC,IAAAqJ,EAAAC,MAmBA,QAAA8B,MACAC,GAAA9Y,MAAA+Y,GACAD,GAAAlR,QAAAoR,GAGA,QAAAA,MACAF,GAAA9Y,MAAA8Y,GAAAlR,QAAA7M,EAGA,QAAAge,IAAArQ,EAAAC,GACAD,GAAAE,GAAAD,GAAAC,GACAqQ,GAAAvQ,EAAAwQ,GAAA1X,GAAAmH,GAAAwQ,GAAA9X,GAAAsH,GACAmQ,GAAA9Y,MAAAoZ,GAGA,QAAAA,IAAA1Q,EAAAC,GACAD,GAAAE,GAAAD,GAAAC,EACA,IAAAS,GAAA7H,GAAAmH,GACAS,EAAA/H,GAAAsH,GACAuC,EAAAM,GAAA9C,EAAAuQ,IACAI,EAAAhY,GAAA6J,GACAoO,EAAA9X,GAAA0J,GACA3N,EAAA6L,EAAAkQ,EACA9b,EAAA2b,GAAA9P,EAAA6P,GAAA9P,EAAAiQ,EACArM,EAAAkM,GAAA7P,EAAA8P,GAAA/P,EAAAiQ,CACAE,IAAA1S,IAAA6C,GAAAjJ,GAAAlD,IAAAC,KAAAwP,IACAiM,GAAAvQ,EAAAwQ,GAAA7P,EAAA8P,GAAA/P,EAGA,QAAAzP,IAAAsO,GAGA,MAFAsR,IAAA3S,QACAoB,EAAAC,EAAA6Q,KACAS,GAMA,QAAAC,IAAA1V,EAAAgD,GAGA,MAFAU,IAAA,GAAA1D,EACA0D,GAAA,GAAAV,EACAnN,GAAAsO,IAiDA,QAAAwR,IAAArS,EAAApH,GACA,SAAAoH,IAAAsS,GAAAlf,eAAA4M,EAAA3M,QACAif,GAAAtS,EAAA3M,MAAA2M,EAAApH,GAIA,QAAA2Z,IAAAnS,EAAAxH,GACA,WAAAwZ,GAAAhS,EAAAxH,GAGA,QAAA4Z,IAAApS,EAAAxH,GACA,GAAA6Z,GAAAL,GAAAhS,EAAA,GAAAA,EAAA,IACAsS,EAAAN,GAAAhS,EAAA,GAAAxH,GACA+Z,EAAAP,GAAAxZ,EAAAwH,EAAA,GACA,OAAAsS,GAAAC,GAAAF,EAAA1N,GAGA,QAAA6N,IAAAxS,EAAAxH,GACA,QAAA2S,GAAAnL,EAAApN,IAAA6f,IAAAC,GAAAla,IAGA,QAAAia,IAAArJ,GACA,MAAAA,KAAAxW,IAAA8f,IAAAtJ,EAAAQ,MAAAR,EAGA,QAAAsJ,IAAAla,GACA,OAAAA,EAAA,GAAA4I,GAAA5I,EAAA,GAAA4I,IAGA,QAAAuR,IAAAlS,EAAAjI,GACA,OAAAiI,GAAAmS,GAAA5f,eAAAyN,EAAAxN,MACA2f,GAAAnS,EAAAxN,MACAgf,IAAAxR,EAAAjI,GAGA,QAAAqa,IAAA5M,EAAAsJ,EAAArZ,GACA,GAAAF,GAAAiJ,EAAA6T,MAAA7M,EAAAsJ,EAAA5K,GAAAzO,GAAA1C,OAAA+b,EACA,iBAAAxZ,GAAsB,MAAAC,GAAApD,IAAA,SAAAoD,GAA2B,OAAAD,EAAAC,MAGjD,QAAA+c,IAAA/M,EAAAsJ,EAAArZ,GACA,GAAAF,GAAAkJ,EAAA6T,MAAA9M,EAAAsJ,EAAA3K,GAAA1O,GAAAzC,OAAA8b,EACA,iBAAAtZ,GAAsB,MAAAD,GAAAnD,IAAA,SAAAmD,GAA2B,OAAAA,EAAAC,MAGjD,QAAAgd,MAOA,QAAAA,KACA,OAAY/f,KAAA,kBAAA+M,YAAA0J,KAGZ,QAAAA,KACA,MAAAzK,GAAA6T,MAAAG,GAAAvN,EAAAwN,KAAA5M,EAAA4M,GAAAtgB,IAAAugB,GACA3f,OAAAyL,EAAA6T,MAAAG,GAAAtN,EAAAyN,KAAA7M,EAAA6M,GAAAxgB,IAAAygB,IACA7f,OAAAyL,EAAA6T,MAAAG,GAAAjN,EAAA/P,KAAAqZ,EAAArZ,GAAAgB,OAAA,SAAAlB,GAA8E,MAAAiO,IAAAjO,EAAAmd,GAAAvO,KAAgC/R,IAAAmD,IAC9GvC,OAAAyL,EAAA6T,MAAAG,GAAAhN,EAAA/P,KAAAqZ,EAAArZ,GAAAe,OAAA,SAAAjB,GAA8E,MAAAgO,IAAAhO,EAAAod,GAAAzO,KAAgC/R,IAAAoD,IAd9G,GAAAsZ,GAAAtJ,EAAAM,EAAAZ,EACA6J,EAAAtJ,EAAAM,EAAAZ,EAEA5P,EAAAC,EAAAmd,EAAAE,EADApd,EAAA,GAAAC,EAAAD,EAAAid,EAAA,GAAAE,EAAA,IAEA7J,EAAA,GA+EA,OAlEAyJ,GAAAtJ,MAAA,WACA,MAAAA,KAAA9W,IAAA,SAAAoN,GAA8C,OAAS/M,KAAA,aAAA+M,kBAGvDgT,EAAAM,QAAA,WACA,OACArgB,KAAA,UACA+M,aACAmT,EAAAzN,GAAAlS,OACA6f,EAAA9M,GAAAxT,MAAA,GACAogB,EAAA7M,GAAAiN,UAAAxgB,MAAA,GACAsgB,EAAA1N,GAAA4N,UAAAxgB,MAAA,OAKAigB,EAAA9B,OAAA,SAAA9e,GACA,MAAAF,WAAAC,OACA6gB,EAAAQ,YAAAphB,GAAAqhB,YAAArhB,GADA4gB,EAAAS,eAIAT,EAAAQ,YAAA,SAAAphB,GACA,MAAAF,WAAAC,QACAuT,GAAAtT,EAAA,MAAAkU,GAAAlU,EAAA,MACAuT,GAAAvT,EAAA,MAAAmU,GAAAnU,EAAA,MACAsT,EAAAY,IAAAlU,EAAAsT,IAAAY,IAAAlU,GACAuT,EAAAY,IAAAnU,EAAAuT,IAAAY,IAAAnU,GACA4gB,EAAAzJ,gBALA7D,EAAAC,IAAAW,EAAAC,KAQAyM,EAAAS,YAAA,SAAArhB,GACA,MAAAF,WAAAC,QACA6T,GAAA5T,EAAA,MAAAkd,GAAAld,EAAA,MACA6T,GAAA7T,EAAA,MAAAmd,GAAAnd,EAAA,MACA4T,EAAAsJ,IAAAld,EAAA4T,IAAAsJ,IAAAld,GACA6T,EAAAsJ,IAAAnd,EAAA6T,IAAAsJ,IAAAnd,GACA4gB,EAAAzJ,gBALAvD,EAAAC,IAAAqJ,EAAAC,KAQAyD,EAAA/J,KAAA,SAAA7W,GACA,MAAAF,WAAAC,OACA6gB,EAAAU,UAAAthB,GAAAuhB,UAAAvhB,GADA4gB,EAAAW,aAIAX,EAAAU,UAAA,SAAAthB,GACA,MAAAF,WAAAC,QACA+gB,GAAA9gB,EAAA,GAAAghB,GAAAhhB,EAAA,GACA4gB,IAFAE,EAAAE,IAKAJ,EAAAW,UAAA,SAAAvhB,GACA,MAAAF,WAAAC,QACA8D,GAAA7D,EAAA,GAAA8D,GAAA9D,EAAA,GACA4gB,IAFA/c,EAAAC,IAKA8c,EAAAzJ,UAAA,SAAAnX,GACA,MAAAF,WAAAC,QACAoX,GAAAnX,EACA2D,EAAA8c,GAAA5M,EAAAsJ,EAAA,IACAvZ,EAAA+c,GAAA/M,EAAAsJ,EAAA/F,GACA4J,EAAAN,GAAAlN,EAAAY,EAAA,IACA8M,EAAAN,GAAArN,EAAAY,EAAAiD,GACAyJ,GANAzJ,GASAyJ,EACAQ,eAAA,QAAA7O,KAAA,OAAAA,MACA8O,eAAA,QAAA9O,KAAA,OAAAA,MAGA,QAAAiP,MACA,MAAAZ,QAGA,QAAAvI,IAAAnO,EAAAgD,GACA,GAAA0G,GAAA1J,EAAA,GAAA8E,GACA6E,EAAA3J,EAAA,GAAA8E,GACAkO,EAAAhQ,EAAA,GAAA8B,GACAmO,EAAAjQ,EAAA,GAAA8B,GACAyS,EAAAha,GAAAoM,GACA6N,EAAA9Z,GAAAiM,GACA8N,EAAAla,GAAA0V,GACAyE,EAAAha,GAAAuV,GACA0E,EAAAJ,EAAAha,GAAAmM,GACAkO,EAAAL,EAAA7Z,GAAAgM,GACAmO,EAAAJ,EAAAla,GAAAyV,GACA8E,EAAAL,EAAA/Z,GAAAsV,GACA5Y,EAAA,EAAA6F,EAAAtD,GAAAyG,EAAA6P,EAAAtJ,GAAA4N,EAAAE,EAAArU,EAAA4P,EAAAtJ,KACAlE,EAAA9H,GAAAtD,GAEA+T,EAAA/T,EAAA,SAAA3E,GACA,GAAAgd,GAAA/U,GAAAjI,GAAA2E,GAAAoL,EACAgN,EAAA9U,GAAAtD,EAAA3E,GAAA+P,EACA/L,EAAA+Y,EAAAmF,EAAAlF,EAAAoF,EACAne,EAAA8Y,EAAAoF,EAAAnF,EAAAqF,EACA5O,EAAAsJ,EAAAgF,EAAA/E,EAAAiF,CACA,QACA9R,GAAAlM,EAAAD,GAAA+N,GACA5B,GAAAsD,EAAAvM,GAAAlD,IAAAC,MAAA8N,KAEG,WACH,OAAAkC,EAAAlC,GAAAmC,EAAAnC,IAKA,OAFA2G,GAAAuH,SAAAtb,EAEA+T,EAGA,QAAA4J,IAAAte,GACA,MAAAA,GA8BA,QAAAue,MACAC,GAAA/b,MAAAgc,GAGA,QAAAA,IAAAze,EAAAC,GACAue,GAAA/b,MAAAic,GACAC,GAAAC,GAAA5e,EAAA6e,GAAAC,GAAA7e,EAGA,QAAAye,IAAA1e,EAAAC,GACA8e,GAAAzV,IAAAwV,GAAA9e,EAAA4e,GAAA3e,GACA2e,GAAA5e,EAAA8e,GAAA7e,EAGA,QAAA+e,MACAN,GAAAC,GAAAE,IAqBA,QAAAI,IAAAjf,EAAAC,GACAD,EAAAkf,QAAAlf,GACAA,EAAAuZ,QAAAvZ,GACAC,EAAAkf,QAAAlf,GACAA,EAAAuZ,QAAAvZ,GA4CA,QAAAmf,IAAApf,EAAAC,GACAof,IAAArf,EACAsf,IAAArf,IACAsf,GAGA,QAAAC,MACAC,GAAAhd,MAAAid,GAGA,QAAAA,IAAA1f,EAAAC,GACAwf,GAAAhd,MAAAkd,GACAP,GAAAQ,GAAA5f,EAAA6f,GAAA5f,GAGA,QAAA0f,IAAA3f,EAAAC,GACA,GAAAC,GAAAF,EAAA4f,GAAAzf,EAAAF,EAAA4f,GAAApQ,EAAAvM,GAAAhD,IAAAC,IACA2f,KAAArQ,GAAAmQ,GAAA5f,GAAA,EACA+f,IAAAtQ,GAAAoQ,GAAA5f,GAAA,EACA+f,IAAAvQ,EACA2P,GAAAQ,GAAA5f,EAAA6f,GAAA5f,GAGA,QAAAggB,MACAR,GAAAhd,MAAA2c,GAGA,QAAAc,MACAT,GAAAhd,MAAA0d,GAGA,QAAAC,MACAC,GAAAC,GAAAC,IAGA,QAAAJ,IAAAngB,EAAAC,GACAwf,GAAAhd,MAAA4d,GACAjB,GAAAkB,GAAAV,GAAA5f,EAAAugB,GAAAV,GAAA5f,GAGA,QAAAogB,IAAArgB,EAAAC,GACA,GAAAC,GAAAF,EAAA4f,GACAzf,EAAAF,EAAA4f,GACApQ,EAAAvM,GAAAhD,IAAAC,IAEA2f,KAAArQ,GAAAmQ,GAAA5f,GAAA,EACA+f,IAAAtQ,GAAAoQ,GAAA5f,GAAA,EACA+f,IAAAvQ,EAEAA,EAAAoQ,GAAA7f,EAAA4f,GAAA3f,EACAugB,IAAA/Q,GAAAmQ,GAAA5f,GACAygB,IAAAhR,GAAAoQ,GAAA5f,GACAygB,IAAA,EAAAjR,EACA2P,GAAAQ,GAAA5f,EAAA6f,GAAA5f,GAGA,QAAA0gB,IAAAC,GACA9kB,KAAA+kB,SAAAD,EAuEA,QAAAE,IAAA9gB,EAAAC,GACA8gB,GAAAte,MAAAue,GACAC,GAAAC,GAAAlhB,EAAAmhB,GAAAC,GAAAnhB,EAGA,QAAA+gB,IAAAhhB,EAAAC,GACAihB,IAAAlhB,EAAAohB,IAAAnhB,EACAohB,GAAA/X,IAAApG,GAAAge,MAAAE,QACAF,GAAAlhB,EAAAohB,GAAAnhB,EAGA,QAAAqhB,MACAxlB,KAAAylB,WAoDA,QAAAC,IAAA5O,GACA,YAAAA,EACA,IAAAA,EAAA,IAAAA,EAAA,eAAAA,EACA,IAAAA,EAAA,IAAAA,EAAA,cAAAA,EACA,IAGA,QAAA6O,IAAAC,EAAAd,GAKA,QAAAe,GAAAjX,GAKA,MAJAA,KACA,kBAAAkX,IAAAC,EAAAD,eAAAvjB,MAAAvC,KAAAK,YACAsO,EAAAC,EAAAoX,EAAAD,KAEAA,EAAA9N,SATA,GACA+N,GACAD,EAFAD,EAAA,GAiDA,OArCAD,GAAAvV,KAAA,SAAA1B,GAEA,MADAD,GAAAC,EAAAoX,EAAAtD,KACAA,GAAAzK,UAGA4N,EAAAI,QAAA,SAAArX,GAEA,MADAD,GAAAC,EAAAoX,EAAAf,KACAA,GAAAhN,UAGA4N,EAAA3S,OAAA,SAAAtE,GAEA,MADAD,GAAAC,EAAAoX,EAAAE,KACAA,GAAAjO,UAGA4N,EAAAnQ,SAAA,SAAA9G,GAEA,MADAD,GAAAC,EAAAoX,EAAArC,KACAA,GAAA1L,UAGA4N,EAAAD,WAAA,SAAArlB,GACA,MAAAF,WAAAC,QAAA0lB,EAAA,MAAAzlB,GAAAqlB,EAAA,KAAApD,KAAAoD,EAAArlB,GAAAyN,OAAA6X,GAAAD,GAGAC,EAAAf,QAAA,SAAAvkB,GACA,MAAAF,WAAAC,QACAylB,EAAA,MAAAxlB,GAAAukB,EAAA,QAAAU,KAAA,GAAAX,IAAAC,EAAAvkB,GACA,kBAAAulB,IAAAC,EAAAD,eACAD,GAHAf,GAMAe,EAAAC,YAAA,SAAAvlB,GACA,MAAAF,WAAAC,QACAwlB,EAAA,kBAAAvlB,MAAAwlB,EAAAD,aAAAvlB,OACAslB,GAFAC,GAKAD,EAAAD,cAAAd,WAGA,QAAAqB,IAAAC,GACA,OACApY,OAAAqY,GAAAD,IAIA,QAAAC,IAAAD,GACA,gBAAApY,GACA,GAAApH,GAAA,GAAA0f,GACA,QAAAC,KAAAH,GAAAxf,EAAA2f,GAAAH,EAAAG,EAEA,OADA3f,GAAAoH,SACApH,GAIA,QAAA0f,OAYA,QAAAE,IAAAZ,EAAAa,EAAA7X,GACA,GAAAiK,GAAA+M,EAAAc,YAAAd,EAAAc,YAMA,OALAd,GAAAe,MAAA,KAAAC,WAAA,MACA,MAAA/N,GAAA+M,EAAAc,WAAA,MACA/X,EAAAC,EAAAgX,EAAA5X,OAAAkY,KACAO,EAAAP,GAAAjO,UACA,MAAAY,GAAA+M,EAAAc,WAAA7N,GACA+M,EAGA,QAAAiB,IAAAjB,EAAAvG,EAAAzQ,GACA,MAAA4X,IAAAZ,EAAA,SAAAnY,GACA,GAAA8G,GAAA8K,EAAA,MAAAA,EAAA,MACAyH,EAAAzH,EAAA,MAAAA,EAAA,MACApP,EAAA9I,KAAAgY,IAAA5K,GAAA9G,EAAA,MAAAA,EAAA,OAAAqZ,GAAArZ,EAAA,MAAAA,EAAA,QACAvJ,GAAAmb,EAAA,OAAA9K,EAAAtE,GAAAxC,EAAA,MAAAA,EAAA,UACAtJ,GAAAkb,EAAA,OAAAyH,EAAA7W,GAAAxC,EAAA,MAAAA,EAAA,SACAmY,GAAAe,MAAA,IAAA1W,GAAA2W,WAAA1iB,EAAAC,KACGyK,GAGH,QAAAmY,IAAAnB,EAAAoB,EAAApY,GACA,MAAAiY,IAAAjB,IAAA,KAAAoB,GAAApY,GAGA,QAAAqY,IAAArB,EAAAsB,EAAAtY,GACA,MAAA4X,IAAAZ,EAAA,SAAAnY,GACA,GAAA8G,IAAA2S,EACAjX,EAAAsE,GAAA9G,EAAA,MAAAA,EAAA,OACAvJ,GAAAqQ,EAAAtE,GAAAxC,EAAA,MAAAA,EAAA,UACAtJ,GAAA8L,EAAAxC,EAAA,KACAmY,GAAAe,MAAA,IAAA1W,GAAA2W,WAAA1iB,EAAAC,KACGyK,GAGH,QAAAuY,IAAAvB,EAAAwB,EAAAxY,GACA,MAAA4X,IAAAZ,EAAA,SAAAnY,GACA,GAAAqZ,IAAAM,EACAnX,EAAA6W,GAAArZ,EAAA,MAAAA,EAAA,OACAvJ,GAAA+L,EAAAxC,EAAA,MACAtJ,GAAA2iB,EAAA7W,GAAAxC,EAAA,MAAAA,EAAA,SACAmY,GAAAe,MAAA,IAAA1W,GAAA2W,WAAA1iB,EAAAC,KACGyK,GAMH,QAAAyY,IAAAC,EAAAC,GACA,OAAAA,EAAAC,GAAAF,EAAAC,GAAAE,GAAAH,GAGA,QAAAG,IAAAH,GACA,MAAAjB,KACA1f,MAAA,SAAAzC,EAAAC,GACAD,EAAAojB,EAAApjB,EAAAC,GACAnE,KAAAgO,OAAArH,MAAAzC,EAAA,GAAAA,EAAA,OAKA,QAAAsjB,IAAAF,EAAAC,GAEA,QAAAG,GAAAvT,EAAAC,EAAA5E,EAAA+O,EAAAvV,EAAA8S,EAAA2B,EAAAC,EAAArM,EAAA2M,EAAAjV,EAAA+T,EAAA6K,EAAA3Z,GACA,GAAA5J,GAAAqZ,EAAAtJ,EACA9P,EAAAqZ,EAAAtJ,EACAwT,EAAAxjB,IAAAC,GACA,IAAAujB,EAAA,EAAAL,GAAAI,IAAA,CACA,GAAAld,GAAA8T,EAAAP,EACAvQ,EAAAzE,EAAAD,EACAzH,EAAAwa,EAAAgB,EACAxH,EAAAlO,GAAAqD,IAAAgD,IAAAnM,KACAumB,EAAAnd,EAAApJ,GAAAgU,GACAxD,EAAAK,MAAA7Q,GAAA,GAAAwR,IAAAX,GAAA3C,EAAA6B,GAAAyB,IAAAtD,EAAA6B,GAAA,EAAAhB,GAAA5C,EAAAhD,GACA5D,EAAAygB,EAAAxV,EAAA+V,GACAC,EAAAjhB,EAAA,GACAkhB,EAAAlhB,EAAA,GACAmhB,EAAAF,EAAA3T,EACA8T,EAAAF,EAAA3T,EACA8T,EAAA7jB,EAAA2jB,EAAA5jB,EAAA6jB,GACAC,IAAAN,EAAAL,GACApV,IAAA/N,EAAA4jB,EAAA3jB,EAAA4jB,GAAAL,EAAA,QACArJ,EAAAP,EAAAhV,EAAAD,EAAA+S,EAAAgB,EAAAqL,MACAT,EAAAvT,EAAAC,EAAA5E,EAAA+O,EAAAvV,EAAA8S,EAAAgM,EAAAC,EAAAjW,EAAArH,GAAA6K,EAAA7H,GAAA6H,EAAAhU,EAAAqmB,EAAA3Z,GACAA,EAAArH,MAAAmhB,EAAAC,GACAL,EAAAI,EAAAC,EAAAjW,EAAArH,EAAAgD,EAAAnM,EAAAmc,EAAAC,EAAArM,EAAA2M,EAAAjV,EAAA+T,EAAA6K,EAAA3Z,KAIA,gBAAAA,GAYA,QAAArH,GAAAzC,EAAAC,GACAD,EAAAojB,EAAApjB,EAAAC,GACA6J,EAAArH,MAAAzC,EAAA,GAAAA,EAAA,IAGA,QAAAoK,KACA6F,EAAAX,IACA4U,EAAAzhB,MAAA6K,EACAxD,EAAAM,YAGA,QAAAkD,GAAAnC,EAAAC,GACA,GAAAhO,GAAAmP,GAAApB,EAAAC,IAAAzI,EAAAygB,EAAAjY,EAAAC,EACAoY,GAAAvT,EAAAC,EAAA5E,EAAA+O,EAAAvV,EAAA8S,EAAA3H,EAAAtN,EAAA,GAAAuN,EAAAvN,EAAA,GAAA2I,EAAAH,EAAAkP,EAAAjd,EAAA,GAAA0H,EAAA1H,EAAA,GAAAwa,EAAAxa,EAAA,GAAA+mB,GAAAra,GACAA,EAAArH,MAAAwN,EAAAC,GAGA,QAAA7F,KACA6Z,EAAAzhB,QACAqH,EAAAO,UAGA,QAAAkM,KACAnM,IACA8Z,EAAAzhB,MAAA2hB,EACAF,EAAA7Z,QAAAmM,EAGA,QAAA4N,GAAAjZ,EAAAC,GACAkC,EAAArC,EAAAE,EAAAC,GAAAuT,EAAA1O,EAAA4O,EAAA3O,EAAAmU,EAAAhK,EAAAiK,EAAAxf,EAAAyf,EAAA3M,EACAsM,EAAAzhB,MAAA6K,EAGA,QAAAkJ,KACAgN,EAAAvT,EAAAC,EAAA5E,EAAA+O,EAAAvV,EAAA8S,EAAA+G,EAAAE,EAAA5T,EAAAoZ,EAAAC,EAAAC,EAAAJ,GAAAra,GACAoa,EAAA7Z,UACAA,IA/CA,GAAAY,GAAA0T,EAAAE,EAAAwF,EAAAC,EAAAC,EACAjZ,EAAA2E,EAAAC,EAAAmK,EAAAvV,EAAA8S,EAEAsM,GACAzhB,QACA2H,YACAC,UACAE,aAAA,WAAgCT,EAAAS,eAAuB2Z,EAAA9Z,UAAAmM,GACvD/L,WAAA,WAA8BV,EAAAU,aAAqB0Z,EAAA9Z,aA0CnD,OAAA8Z,IAUA,QAAAM,IAAA/R,GACA,MAAA0P,KACA1f,MAAA,SAAAzC,EAAAC,GACA,GAAAsT,GAAAd,EAAAzS,EAAAC,EACA,OAAAnE,MAAAgO,OAAArH,MAAA8Q,EAAA,GAAAA,EAAA,OAKA,QAAAkR,IAAA1Y,EAAA7L,EAAAC,GACA,QAAAukB,GAAA1kB,EAAAC,GACA,OAAAC,EAAA6L,EAAA/L,EAAAG,EAAA4L,EAAA9L,GAKA,MAHAykB,GAAA/S,OAAA,SAAA3R,EAAAC,GACA,QAAAD,EAAAE,GAAA6L,GAAA5L,EAAAF,GAAA8L,IAEA2Y,EAGA,QAAAC,IAAA5Y,EAAA7L,EAAAC,EAAAykB,GASA,QAAAF,GAAA1kB,EAAAC,GACA,OAAAsG,EAAAvG,EAAAuJ,EAAAtJ,EAAAC,EAAAC,EAAAoJ,EAAAvJ,EAAAuG,EAAAtG,GATA,GAAA4kB,GAAA/gB,GAAA8gB,GACAE,EAAA7gB,GAAA2gB,GACAre,EAAAse,EAAA9Y,EACAxC,EAAAub,EAAA/Y,EACAgZ,EAAAF,EAAA9Y,EACAiZ,EAAAF,EAAA/Y,EACAkZ,GAAAH,EAAA3kB,EAAA0kB,EAAA3kB,GAAA6L,EACAmZ,GAAAJ,EAAA5kB,EAAA2kB,EAAA1kB,GAAA4L,CAOA,OAHA2Y,GAAA/S,OAAA,SAAA3R,EAAAC,GACA,OAAA8kB,EAAA/kB,EAAAglB,EAAA/kB,EAAAglB,EAAAC,EAAAF,EAAAhlB,EAAA+kB,EAAA9kB,IAEAykB,EAGA,QAAAhD,IAAA0B,GACA,MAAA+B,IAAA,WAAuC,MAAA/B,OAGvC,QAAA+B,IAAAC,GAgBA,QAAA1D,GAAAjf,GACA,MAAA4iB,GAAA5iB,EAAA,GAAA4I,GAAA5I,EAAA,GAAA4I,IAGA,QAAAsG,GAAAlP,GAEA,MADAA,GAAA4iB,EAAA1T,OAAAlP,EAAA,GAAAA,EAAA,IACAA,MAAA,GAAAsL,GAAAtL,EAAA,GAAAsL,IA+DA,QAAAuX,KACA,GAAAhS,GAAAqR,GAAA5Y,EAAA,IAAA6Y,GAAAvmB,MAAA,KAAA+kB,EAAAjY,EAAAC,IACAsZ,GAAAE,EAAAD,GAAAF,IAAA1Y,EAAA/L,EAAAsT,EAAA,GAAArT,EAAAqT,EAAA,GAAAsR,EAKA,OAJAnS,GAAAZ,EAAAC,EAAAC,EAAAC,GACAuT,EAAA7T,EAAA0R,EAAAsB,GACAW,EAAA3T,EAAAe,EAAA8S,GACAC,EAAArC,GAAAoC,EAAAlC,GACAha,IAGA,QAAAA,KAEA,MADA+R,GAAAC,EAAA,KACAqG,EAhGA,GAAA0B,GAIA3Q,EAGAvC,EAAAqJ,EAAAC,EAEAgM,EACAD,EACAF,EACAjK,EACAC,EAZAtP,EAAA,IACA/L,EAAA,IAAAC,EAAA,IACAkL,EAAA,EAAAC,EAAA,EACA0G,EAAA,EAAAC,EAAA,EAAAC,EAAA,EACA4S,EAAA,EACAa,EAAA,KAAAC,EAAAC,GACA1V,EAAA,KAAA2V,EAAAtH,GACA+E,EAAA,EA2FA,OA3EA3B,GAAA5X,OAAA,SAAAA,GACA,MAAAsR,IAAAC,IAAAvR,EAAAsR,IAAAyK,GAAArB,GAAA/R,GAAAiT,EAAAF,EAAAI,EAAAvK,EAAAvR,QAGA4X,EAAAgE,QAAA,SAAArpB,GACA,MAAAF,WAAAC,QAAAspB,EAAArpB,EAAAopB,EAAAK,OAAAzc,KAAAqc,GAGAhE,EAAAkE,SAAA,SAAAvpB,GACA,MAAAF,WAAAC,QAAAwpB,EAAAvpB,EAAA4T,EAAAC,EAAAqJ,EAAAC,EAAA,KAAAnQ,KAAAuc,GAGAlE,EAAAqE,UAAA,SAAA1pB,GACA,MAAAF,WAAAC,QAAAspB,GAAArpB,EAAAob,GAAAgO,EAAAppB,EAAAgP,KAAAoa,EAAA,KAAAE,IAAAtc,KAAAoc,EAAA1X,IAGA2T,EAAAc,WAAA,SAAAnmB,GACA,MAAAF,WAAAC,QAAAwpB,EAAA,MAAAvpB,GAAA4T,EAAAC,EAAAqJ,EAAAC,EAAA,KAAA8E,IAAAzE,GAAA5J,GAAA5T,EAAA,MAAA6T,GAAA7T,EAAA,MAAAkd,GAAAld,EAAA,MAAAmd,GAAAnd,EAAA,OAAAgN,KAAA,MAAA4G,EAAA,OAAAA,EAAAC,IAAAqJ,EAAAC,KAGAkI,EAAAe,MAAA,SAAApmB,GACA,MAAAF,WAAAC,QAAA2P,GAAA1P,EAAAipB,KAAAvZ,GAGA2V,EAAAgB,UAAA,SAAArmB,GACA,MAAAF,WAAAC,QAAA4D,GAAA3D,EAAA,GAAA4D,GAAA5D,EAAA,GAAAipB,MAAAtlB,EAAAC,IAGAyhB,EAAApO,OAAA,SAAAjX,GACA,MAAAF,WAAAC,QAAA+O,EAAA9O,EAAA,OAAAgP,GAAAD,EAAA/O,EAAA,OAAAgP,GAAAia,MAAAna,EAAA4C,GAAA3C,EAAA2C,KAGA2T,EAAAjP,OAAA,SAAApW,GACA,MAAAF,WAAAC,QAAA0V,EAAAzV,EAAA,OAAAgP,GAAA0G,EAAA1V,EAAA,OAAAgP,GAAA2G,EAAA3V,EAAAD,OAAA,EAAAC,EAAA,OAAAgP,GAAA,EAAAia,MAAAxT,EAAA/D,GAAAgE,EAAAhE,GAAAiE,EAAAjE,KAGA2T,EAAAxT,MAAA,SAAA7R,GACA,MAAAF,WAAAC,QAAAwoB,EAAAvoB,EAAA,IAAAgP,GAAAia,KAAAV,EAAA7W,IAGA2T,EAAAlO,UAAA,SAAAnX,GACA,MAAAF,WAAAC,QAAAopB,EAAArC,GAAAoC,EAAAlC,EAAAhnB,KAAAgN,KAAAnG,GAAAmgB,IAGA3B,EAAAiB,UAAA,SAAAxH,EAAAzQ,GACA,MAAAiY,IAAAjB,EAAAvG,EAAAzQ,IAGAgX,EAAAmB,QAAA,SAAAC,EAAApY,GACA,MAAAmY,IAAAnB,EAAAoB,EAAApY,IAGAgX,EAAAqB,SAAA,SAAAC,EAAAtY,GACA,MAAAqY,IAAArB,EAAAsB,EAAAtY,IAGAgX,EAAAuB,UAAA,SAAAC,EAAAxY,GACA,MAAAuY,IAAAvB,EAAAwB,EAAAxY,IAkBA,WAGA,MAFA0Y,GAAAgC,EAAA/mB,MAAAvC,KAAAK,WACAulB,EAAA/P,OAAAyR,EAAAzR,UACA2T,KAIA,QAAAU,IAAAZ,GACA,GAAAhY,GAAA,EACAC,EAAAlJ,GAAA,EACAiN,EAAA+T,GAAAC,GACAziB,EAAAyO,EAAAhE,EAAAC,EAMA,OAJA1K,GAAAsjB,UAAA,SAAA5pB,GACA,MAAAF,WAAAC,OAAAgV,EAAAhE,EAAA/Q,EAAA,GAAAgP,GAAAgC,EAAAhR,EAAA,GAAAgP,KAAA+B,EAAAW,GAAAV,EAAAU,KAGApL,EAGA,QAAAujB,IAAA9Y,GAGA,QAAAsF,GAAAvH,EAAAC,GACA,OAAAD,EAAAI,EAAAtH,GAAAmH,GAAAG,GAHA,GAAAA,GAAAzH,GAAAsJ,EAUA,OAJAsF,GAAAf,OAAA,SAAA3R,EAAAC,GACA,OAAAD,EAAAuL,EAAA/E,EAAAvG,EAAAsL,KAGAmH,EAGA,QAAAyT,IAAAjW,EAAAsJ,GAQA,QAAA4J,GAAApjB,EAAAC,GACA,GAAAsT,GAAArQ,GAAA9F,EAAA,EAAAlB,EAAA+H,GAAAhE,IAAA/D,CACA,QAAAqX,EAAAtP,GAAAjE,GAAA9D,GAAAkqB,EAAA7S,EAAAzP,GAAA9D,IATA,GAAA+d,GAAA9Z,GAAAiM,GAAAhU,GAAA6hB,EAAA9Z,GAAAuV,IAAA,CAGA,IAAAvL,GAAA/R,GAAA0S,GAAA,MAAAsX,IAAAhW,EAEA,IAAA9S,GAAA,EAAA2gB,GAAA,EAAA7hB,EAAA6hB,GAAAqI,EAAAljB,GAAA9F,GAAAlB,CAYA,OALAknB,GAAAzR,OAAA,SAAA3R,EAAAC,GACA,GAAAomB,GAAAD,EAAAnmB,CACA,QAAAkM,GAAAnM,EAAAiO,GAAAoY,IAAAnqB,EAAAoqB,GAAAD,GAAA7f,GAAApJ,GAAA4C,IAAAqmB,KAAAnqB,MAAA,EAAAA,MAGAknB,EAGA,QAAAmD,MACA,MAAAP,IAAAG,IACA1D,MAAA,SACAnP,QAAA,YAGA,QAAAkT,MACA,MAAAD,MACAN,WAAA,YACAxD,MAAA,MACAC,WAAA,UACAjQ,QAAA,OACAa,SAAA,UAKA,QAAAmT,IAAAC,GACA,GAAAxqB,GAAAwqB,EAAAtqB,MACA,QACAqG,MAAA,SAAAzC,EAAAC,GAAuC,IAAZ,GAAAhE,IAAA,IAAYA,EAAAC,GAAAwqB,EAAAzqB,GAAAwG,MAAAzC,EAAAC,IACvC8W,OAAA,WAAoC,IAAZ,GAAA9a,IAAA,IAAYA,EAAAC,GAAAwqB,EAAAzqB,GAAA8a,UACpC3M,UAAA,WAAuC,IAAZ,GAAAnO,IAAA,IAAYA,EAAAC,GAAAwqB,EAAAzqB,GAAAmO,aACvCC,QAAA,WAAqC,IAAZ,GAAApO,IAAA,IAAYA,EAAAC,GAAAwqB,EAAAzqB,GAAAoO,WACrCE,aAAA,WAA0C,IAAZ,GAAAtO,IAAA,IAAYA,EAAAC,GAAAwqB,EAAAzqB,GAAAsO,gBAC1CC,WAAA,WAAwC,IAAZ,GAAAvO,IAAA,IAAYA,EAAAC,GAAAwqB,EAAAzqB,GAAAuO,eASxC,QAAAmc,MAQA,QAAAA,GAAA1c,GACA,GAAAjK,GAAAiK,EAAA,GAAAhK,EAAAgK,EAAA,EACA,OAAAxH,GAAA,KAAAmkB,EAAAnkB,MAAAzC,EAAAC,GAAAwC,IACAokB,EAAApkB,MAAAzC,EAAAC,GAAAwC,KACAqkB,EAAArkB,MAAAzC,EAAAC,GAAAwC,GAmEA,QAAA4G,KAEA,MADA+R,GAAAC,EAAA,KACAsL,EAhFA,GAAAvL,GACAC,EACAuL,EACAC,EACAC,EACArkB,EAHAskB,EAAAP,KACAQ,EAAAT,KAAA9T,QAAA,QAAAa,SAAA,SAAA2S,WAAA,QACAgB,EAAAV,KAAA9T,QAAA,QAAAa,SAAA,SAAA2S,WAAA,OACAiB,GAA4BzkB,MAAA,SAAAzC,EAAAC,GAAuBwC,GAAAzC,EAAAC,IA8EnD,OArEA0mB,GAAAhV,OAAA,SAAA1H,GACA,GAAA8B,GAAAgb,EAAAtE,QACAzmB,EAAA+qB,EAAArE,YACA1iB,GAAAiK,EAAA,GAAAjO,EAAA,IAAA+P,EACA9L,GAAAgK,EAAA,GAAAjO,EAAA,IAAA+P,CACA,QAAA9L,GAAA,KAAAA,EAAA,MAAAD,IAAA,MAAAA,GAAA,KAAAgnB,EACA/mB,GAAA,MAAAA,EAAA,MAAAD,IAAA,MAAAA,GAAA,KAAAinB,EACAF,GAAApV,OAAA1H,IAGA0c,EAAA7c,OAAA,SAAAA,GACA,MAAAsR,IAAAC,IAAAvR,EAAAsR,IAAAqL,IAAAM,EAAAjd,OAAAuR,EAAAvR,GAAAkd,EAAAld,UAAAmd,EAAAnd,aAGA6c,EAAAnT,UAAA,SAAAnX,GACA,MAAAF,WAAAC,QACA2qB,EAAAvT,UAAAnX,GAAA2qB,EAAAxT,UAAAnX,GAAA4qB,EAAAzT,UAAAnX,GACAgN,KAFA0d,EAAAvT,aAKAmT,EAAAlE,MAAA,SAAApmB,GACA,MAAAF,WAAAC,QACA2qB,EAAAtE,MAAApmB,GAAA2qB,EAAAvE,MAAA,IAAApmB,GAAA4qB,EAAAxE,MAAApmB,GACAsqB,EAAAjE,UAAAqE,EAAArE,cAFAqE,EAAAtE,SAKAkE,EAAAjE,UAAA,SAAArmB,GACA,IAAAF,UAAAC,OAAA,MAAA2qB,GAAArE,WACA,IAAA3W,GAAAgb,EAAAtE,QAAAziB,GAAA3D,EAAA,GAAA4D,GAAA5D,EAAA,EAiBA,OAfAuqB,GAAAG,EACArE,UAAArmB,GACAmmB,aAAAxiB,EAAA,KAAA+L,EAAA9L,EAAA,KAAA8L,IAAA/L,EAAA,KAAA+L,EAAA9L,EAAA,KAAA8L,KACAjC,OAAAod;AAEAL,EAAAG,EACAtE,WAAA1iB,EAAA,KAAA+L,EAAA9L,EAAA,KAAA8L,IACAyW,aAAAxiB,EAAA,KAAA+L,EAAA6C,GAAA3O,EAAA,IAAA8L,EAAA6C,KAAA5O,EAAA,KAAA+L,EAAA6C,GAAA3O,EAAA,KAAA8L,EAAA6C,MACA9E,OAAAod,GAEAJ,EAAAG,EACAvE,WAAA1iB,EAAA,KAAA+L,EAAA9L,EAAA,KAAA8L,IACAyW,aAAAxiB,EAAA,KAAA+L,EAAA6C,GAAA3O,EAAA,KAAA8L,EAAA6C,KAAA5O,EAAA,KAAA+L,EAAA6C,GAAA3O,EAAA,KAAA8L,EAAA6C,MACA9E,OAAAod,GAEA7d,KAGAsd,EAAAhE,UAAA,SAAAxH,EAAAzQ,GACA,MAAAiY,IAAAgE,EAAAxL,EAAAzQ,IAGAic,EAAA9D,QAAA,SAAAC,EAAApY,GACA,MAAAmY,IAAA8D,EAAA7D,EAAApY,IAGAic,EAAA5D,SAAA,SAAAC,EAAAtY,GACA,MAAAqY,IAAA4D,EAAA3D,EAAAtY,IAGAic,EAAA1D,UAAA,SAAAC,EAAAxY,GACA,MAAAuY,IAAA0D,EAAAzD,EAAAxY,IAQAic,EAAAlE,MAAA,MAGA,QAAA0E,IAAA1E,GACA,gBAAAziB,EAAAC,GACA,GAAAgR,GAAAnN,GAAA9D,GACAkR,EAAApN,GAAA7D,GACA8L,EAAA0W,EAAAxR,EAAAC,EACA,QACAnF,EAAAmF,EAAAjN,GAAAjE,GACA+L,EAAA9H,GAAAhE,KAKA,QAAAmnB,IAAAlZ,GACA,gBAAAlO,EAAAC,GACA,GAAAwP,GAAAvM,GAAAlD,IAAAC,KACA7C,EAAA8Q,EAAAuB,GACA4X,EAAApjB,GAAA7G,GACAkqB,EAAAxjB,GAAA1G,EACA,QACA+O,GAAAnM,EAAAqnB,EAAA5X,EAAA6X,GACA9gB,EAAAiJ,GAAAxP,EAAAonB,EAAA5X,KAaA,QAAA8X,MACA,MAAA7F,IAAA8F,IACA/E,MAAA,QACAsD,UAAA,SAWA,QAAA0B,MACA,MAAA/F,IAAAgG,IACAjF,MAAA,SACAsD,UAAA,SAGA,QAAA4B,IAAAxc,EAAAC,GACA,OAAAD,EAAAyc,GAAAC,IAAA9jB,GAAAqH,GAAA,KAOA,QAAA0c,MACA,MAAAC,IAAAJ,IACAlF,MAAA,IAAAtc,IAGA,QAAA4hB,IAAA3E,GAwBA,QAAA4E,KACA,GAAAjc,GAAA5H,GAAAse,IACAzmB,EAAAoV,EAAAgB,GAAAhB,EAAAqB,UAAAd,QAAA,MACA,OAAA6Q,GAAA,MAAAvS,IACAjU,EAAA,GAAA+P,EAAA/P,EAAA,GAAA+P,IAAA/P,EAAA,GAAA+P,EAAA/P,EAAA,GAAA+P,IAAAqX,IAAAuE,KACA1kB,KAAAwD,IAAAzK,EAAA,GAAA+P,EAAAkE,GAAAC,IAAAjN,KAAAgY,IAAAjf,EAAA,GAAA+P,EAAAwN,GAAAC,MACAvJ,EAAAhN,KAAAwD,IAAAzK,EAAA,GAAA+P,EAAAmE,KAAAqJ,EAAAtW,KAAAgY,IAAAjf,EAAA,GAAA+P,EAAAyN,MA7BA,GAKAtJ,GAAAqJ,EAAAC,EALApI,EAAAsQ,GAAA0B,GACA9P,EAAAlC,EAAAkC,OACAmP,EAAArR,EAAAqR,MACAC,EAAAtR,EAAAsR,UACAF,EAAApR,EAAAoR,WACAvS,EAAA,IA2BA,OAzBAmB,GAAAqR,MAAA,SAAApmB,GACA,MAAAF,WAAAC,QAAAqmB,EAAApmB,GAAA2rB,KAAAvF,KAGArR,EAAAsR,UAAA,SAAArmB,GACA,MAAAF,WAAAC,QAAAsmB,EAAArmB,GAAA2rB,KAAAtF,KAGAtR,EAAAkC,OAAA,SAAAjX,GACA,MAAAF,WAAAC,QAAAkX,EAAAjX,GAAA2rB,KAAA1U,KAGAlC,EAAAoR,WAAA,SAAAnmB,GACA,MAAAF,WAAAC,QAAA,MAAAC,EAAA4T,EAAAC,EAAAqJ,EAAAC,EAAA,MAAAvJ,GAAA5T,EAAA,MAAA6T,GAAA7T,EAAA,MAAAkd,GAAAld,EAAA,MAAAmd,GAAAnd,EAAA,OAAA2rB,KAAA,MAAA/X,EAAA,OAAAA,EAAAC,IAAAqJ,EAAAC,KAYAwO,IAGA,QAAAC,IAAAhoB,GACA,MAAA4nB,KAAA9jB,GAAA9D,GAAA,GAGA,QAAAioB,IAAAhY,EAAAsJ,GAOA,QAAA4J,GAAApjB,EAAAC,GACAkoB,EAAA,EAAgBloB,GAAA8D,GAAA6K,KAAA3O,GAAA8D,GAAA6K,IACN3O,EAAA8D,GAAA6K,KAAA3O,EAAA8D,GAAA6K,GACV,IAAA2E,GAAA4U,EAAA9jB,GAAA4jB,GAAAhoB,GAAA/D,EACA,QAAAqX,EAAAtP,GAAA/H,EAAA8D,GAAAmoB,EAAA5U,EAAAzP,GAAA5H,EAAA8D,IAVA,GAAA8d,GAAAha,GAAAoM,GACAhU,EAAAgU,IAAAsJ,EAAAvV,GAAAiM,GAAA0X,GAAA9J,EAAAha,GAAA0V,IAAAoO,GAAAK,GAAAzO,GAAAyO,GAAA/X,IACAiY,EAAArK,EAAAzZ,GAAA4jB,GAAA/X,GAAAhU,IAEA,OAAAA,IASAknB,EAAAzR,OAAA,SAAA3R,EAAAC,GACA,GAAAmoB,GAAAD,EAAAloB,EAAAsT,EAAA+S,GAAApqB,GAAAgH,GAAAlD,IAAAooB,IACA,QAAAjc,GAAAnM,EAAAiO,GAAAma,IAAAlsB,EAAAoqB,GAAA8B,GAAA,EAAA/Q,GAAAhT,GAAA8jB,EAAA5U,EAAA,EAAArX,IAAA6H,KAGAqf,GAdAuE,GAiBA,QAAAU,MACA,MAAArC,IAAAkC,IACAzF,MAAA,OACAwD,WAAA,QAGA,QAAAqC,IAAAnd,EAAAC,GACA,OAAAD,EAAAC,GAKA,QAAAmd,MACA,MAAA7G,IAAA4G,IACA7F,MAAA,QAGA,QAAA+F,IAAAtY,EAAAsJ,GAOA,QAAA4J,GAAApjB,EAAAC,GACA,GAAAwoB,GAAAC,EAAAzoB,EAAA0oB,EAAAzsB,EAAA8D,CACA,QAAAyoB,EAAAxkB,GAAA0kB,GAAAD,EAAAD,EAAA3kB,GAAA6kB,IARA,GAAA7K,GAAAha,GAAAoM,GACAhU,EAAAgU,IAAAsJ,EAAAvV,GAAAiM,IAAA4N,EAAAha,GAAA0V,OAAAtJ,GACAwY,EAAA5K,EAAA5hB,EAAAgU,CAEA,OAAAjC,IAAA/R,GAAA0S,GAAA0Z,IAOAlF,EAAAzR,OAAA,SAAA3R,EAAAC,GACA,GAAAwoB,GAAAC,EAAAzoB,CACA,QAAAkM,GAAAnM,EAAAiO,GAAAwa,IAAAvsB,EAAAoqB,GAAAmC,GAAAC,EAAApC,GAAApqB,GAAAgH,GAAAlD,IAAAyoB,OAGArF,GAGA,QAAAwF,MACA,MAAA5C,IAAAwC,IACA/F,MAAA,SACAnP,QAAA,YAGA,QAAAuV,IAAA7oB,EAAAC,GACA,GAAAiR,GAAApN,GAAA7D,GAAA8L,EAAAjI,GAAA9D,GAAAkR,CACA,QAAAA,EAAAjN,GAAAjE,GAAA+L,EAAA9H,GAAAhE,GAAA8L,GAKA,QAAA+c,MACA,MAAApH,IAAAmH,IACApG,MAAA,SACAsD,UAAA,IAGA,QAAAgD,IAAAC,EAAAC,EAAAC,EAAAC,GACA,WAAAH,GAAA,IAAAC,GAAA,IAAAC,GAAA,IAAAC,EAAA7K,GAAA6D,IACA1f,MAAA,SAAAzC,EAAAC,GACAnE,KAAAgO,OAAArH,MAAAzC,EAAAgpB,EAAAE,EAAAjpB,EAAAgpB,EAAAE,MAKA,QAAAC,MAQA,QAAA/f,KAEA,MADA+R,GAAAC,EAAA,KACAqG,EATA,GACAxR,GAAAqJ,EAAAC,EAEA4B,EACAC,EACAqG,EALA3V,EAAA,EAAAmd,EAAA,EAAAC,EAAA,EAAAE,EAAA,EAAAC,EAAA,EAAA5E,EAAApG,GACArO,EAAA,KACA2V,EAAAtH,EAUA,OAAAoD,IACA5X,OAAA,SAAAA,GACA,MAAAsR,IAAAC,IAAAvR,EAAAsR,IAAAsJ,EAAAkB,EAAAvK,EAAAvR,KAEA8b,SAAA,SAAAvpB,GACA,MAAAF,WAAAC,QAAAwpB,EAAAvpB,EAAA4T,EAAAC,EAAAqJ,EAAAC,EAAA,KAAAnQ,KAAAuc,GAEApD,WAAA,SAAAnmB,GACA,MAAAF,WAAAC,QAAAwpB,EAAA,MAAAvpB,GAAA4T,EAAAC,EAAAqJ,EAAAC,EAAA,KAAA8E,IAAAzE,GAAA5J,GAAA5T,EAAA,MAAA6T,GAAA7T,EAAA,MAAAkd,GAAAld,EAAA,MAAAmd,GAAAnd,EAAA,OAAAgN,KAAA,MAAA4G,EAAA,OAAAA,EAAAC,IAAAqJ,EAAAC,KAEAiJ,MAAA,SAAApmB,GACA,MAAAF,WAAAC,QAAAsoB,EAAAqE,IAAAhd,GAAA1P,GAAAgtB,EAAAtd,EAAAud,EAAAJ,EAAAC,GAAA9f,KAAA0C,GAEA2W,UAAA,SAAArmB,GACA,MAAAF,WAAAC,QAAAsoB,EAAAqE,GAAAhd,EAAAsd,EAAAtd,EAAAud,EAAAJ,GAAA7sB,EAAA,GAAA8sB,GAAA9sB,EAAA,IAAAgN,MAAA6f,EAAAC,IAEAI,SAAA,SAAAltB,GACA,MAAAF,WAAAC,QAAAsoB,EAAAqE,GAAAhd,GAAAsd,EAAAhtB,GAAA,KAAA0P,EAAAud,EAAAJ,EAAAC,GAAA9f,KAAAggB,EAAA,GAEAG,SAAA,SAAAntB,GACA,MAAAF,WAAAC,QAAAsoB,EAAAqE,GAAAhd,EAAAsd,EAAAtd,GAAAud,EAAAjtB,GAAA,KAAA6sB,EAAAC,GAAA9f,KAAAigB,EAAA,GAEA3G,UAAA,SAAAxH,EAAAzQ,GACA,MAAAiY,IAAAjB,EAAAvG,EAAAzQ,IAEAmY,QAAA,SAAAC,EAAApY,GACA,MAAAmY,IAAAnB,EAAAoB,EAAApY,IAEAqY,SAAA,SAAAC,EAAAtY,GACA,MAAAqY,IAAArB,EAAAsB,EAAAtY,IAEAuY,UAAA,SAAAC,EAAAxY,GACA,MAAAuY,IAAAvB,EAAAwB,EAAAxY,KAKA,QAAA+e,IAAAte,EAAAC,GACA,GAAAuY,GAAAvY,IAAAse,EAAA/F,GACA,QACAxY,GAAA,cAAAwY,EAAA+F,IAAA,QAAAA,GAAA,QAAA/F,EAAA,QAAA+F,KACAte,GAAA,SAAAuY,GAAA,QAAA+F,IAAA,gBAAA/F,EAAA,QAAA+F,MAiBA,QAAAC,MACA,MAAAjI,IAAA+H,IACAhH,MAAA,SAGA,QAAAmH,IAAA5pB,EAAAC,GACA,OAAA6D,GAAA7D,GAAAgE,GAAAjE,GAAAiE,GAAAhE,IAKA,QAAA4pB,MACA,MAAAnI,IAAAkI,IACAnH,MAAA,OACAsD,UAAA,GAAAnX,IAGA,QAAAkb,IAAA9pB,EAAAC,GACA,GAAAiR,GAAApN,GAAA7D,GAAA8L,EAAA,EAAAjI,GAAA9D,GAAAkR,CACA,QAAAA,EAAAjN,GAAAjE,GAAA+L,EAAA9H,GAAAhE,GAAA8L,GAOA,QAAAge,MACA,MAAArI,IAAAoI,IACArH,MAAA,KACAsD,UAAA,KAGA,QAAAiE,IAAA7e,EAAAC,GACA,OAAAwc,GAAAC,IAAA9jB,GAAAqH,GAAA,KAAAD,GAOA,QAAA8e,MACA,GAAA7Y,GAAA2W,GAAAiC,IACA1W,EAAAlC,EAAAkC,OACAb,EAAArB,EAAAqB,MAUA,OARArB,GAAAkC,OAAA,SAAAjX,GACA,MAAAF,WAAAC,OAAAkX,IAAAjX,EAAA,GAAAA,EAAA,MAAAA,EAAAiX,KAAAjX,EAAA,IAAAA,EAAA,MAGA+U,EAAAqB,OAAA,SAAApW,GACA,MAAAF,WAAAC,OAAAqW,GAAApW,EAAA,GAAAA,EAAA,GAAAA,EAAAD,OAAA,EAAAC,EAAA,YAAAA,EAAAoW,KAAApW,EAAA,GAAAA,EAAA,GAAAA,EAAA,SAGAoW,GAAA,SACAgQ,MAAA,SA97FArZ,EAAAzL,WACAC,YAAAwL,EACAC,MAAA,WACAvN,KAAA4G,EACA5G,KAAAE,EAAA,GAEAsN,IAAA,SAAArJ,GACAqJ,EAAA4gB,GAAAjqB,EAAAnE,KAAAE,GACAsN,EAAAxN,KAAAouB,GAAAxnB,EAAA5G,KAAA4G,GACA5G,KAAA4G,EAAA5G,KAAAE,GAAAkuB,GAAAluB,EACAF,KAAA4G,EAAAwnB,GAAAluB,GAEAmuB,QAAA,WACA,MAAAruB,MAAA4G,GAIA,IAwHAuI,IACAC,GACAI,GACAC,GACAE,GA+FAyB,GACAE,GACAD,GACAE,GACAO,GACAY,GACAC,GACA1L,GAEAiK,GACAC,GAqKAyC,GACAY,GACAX,GACAC,GACAC,GACAU,GACAC,GACAC,GACAY,GACAC,GACAC,GACAR,GACAC,GACAf,GACAC,GACAC,GAzZA+Z,GAAA,GAAA9gB,GASAwF,GAAA,KACA6C,GAAA,MACAtN,GAAAlB,KAAA6C,GACA/B,GAAAI,GAAA,EACAqH,GAAArH,GAAA,EACAgC,GAAA,EAAAhC,GAEA4J,GAAA,IAAA5J,GACAkH,GAAAlH,GAAA,IAEA8J,GAAAhL,KAAAgL,IACAoJ,GAAApU,KAAAoU,KACAlL,GAAAlJ,KAAAkJ,MACArI,GAAAb,KAAAa,IACAoZ,GAAAja,KAAAia,KACAkN,GAAAnnB,KAAAmnB,IAEAxC,GAAA3kB,KAAA2kB,IACAvjB,GAAApB,KAAAoB,IACAJ,GAAAhB,KAAAgB,IACAqiB,GAAArjB,KAAAqjB,MAAA,SAAAtmB,GAAqC,MAAAA,GAAA,IAAAA,EAAA,QACrCkD,GAAAD,KAAAC,KACA2kB,GAAA5kB,KAAA4kB,IAsBAld,IACA0f,QAAA,SAAA3f,EAAAZ,GACAF,EAAAc,EAAAb,SAAAC,IAEAwgB,kBAAA,SAAA5f,EAAAZ,GAEA,IADA,GAAAygB,GAAA7f,EAAA6f,SAAAtuB,GAAA,EAAAC,EAAAquB,EAAAnuB,SACAH,EAAAC,GAAA0N,EAAA2gB,EAAAtuB,GAAA4N,SAAAC,KAIAC,IACAygB,OAAA,SAAA9f,EAAAZ,GACAA,EAAAiN,UAEA0T,MAAA,SAAA/f,EAAAZ,GACAY,IAAAT,YACAH,EAAArH,MAAAiI,EAAA,GAAAA,EAAA,GAAAA,EAAA,KAEAggB,WAAA,SAAAhgB,EAAAZ,GAEA,IADA,GAAAG,GAAAS,EAAAT,YAAAhO,GAAA,EAAAC,EAAA+N,EAAA7N,SACAH,EAAAC,GAAAwO,EAAAT,EAAAhO,GAAA6N,EAAArH,MAAAiI,EAAA,GAAAA,EAAA,GAAAA,EAAA,KAEAigB,WAAA,SAAAjgB,EAAAZ,GACAE,EAAAU,EAAAT,YAAAH,EAAA,IAEA8gB,gBAAA,SAAAlgB,EAAAZ,GAEA,IADA,GAAAG,GAAAS,EAAAT,YAAAhO,GAAA,EAAAC,EAAA+N,EAAA7N,SACAH,EAAAC,GAAA8N,EAAAC,EAAAhO,GAAA6N,EAAA,IAEA+gB,QAAA,SAAAngB,EAAAZ,GACAQ,EAAAI,EAAAT,YAAAH,IAEAghB,aAAA,SAAApgB,EAAAZ,GAEA,IADA,GAAAG,GAAAS,EAAAT,YAAAhO,GAAA,EAAAC,EAAA+N,EAAA7N,SACAH,EAAAC,GAAAoO,EAAAL,EAAAhO,GAAA6N,IAEAihB,mBAAA,SAAArgB,EAAAZ,GAEA,IADA,GAAAkhB,GAAAtgB,EAAAsgB,WAAA/uB,GAAA,EAAAC,EAAA8uB,EAAA5uB,SACAH,EAAAC,GAAA0N,EAAAohB,EAAA/uB,GAAA6N,KA0BAoC,GAAA/C,IAEAkD,GAAAlD,IAOA0B,IACApI,MAAAjF,EACA4M,UAAA5M,EACA6M,QAAA7M,EACA+M,aAAA,WACA2B,GAAA7C,QACAwB,GAAAT,UAAAQ,EACAC,GAAAR,QAAAU,GAEAP,WAAA,WACA,GAAAygB,IAAA/e,EACAG,IAAA/C,IAAA2hB,EAAA,EAAA9kB,GAAA8kB,KACAnvB,KAAAsO,UAAAtO,KAAAuO,QAAAvO,KAAA2G,MAAAjF,GAEAuZ,OAAA,WACA1K,GAAA/C,IAAAnD,MAsFAoI,GAAApF,IAIAiF,IACA3L,MAAAsK,EACA3C,UAAA+D,EACA9D,QAAAgE,EACA9D,aAAA,WACA6D,GAAA3L,MAAA6L,EACAF,GAAAhE,UAAAsE,EACAN,GAAA/D,QAAAsE,EACAJ,GAAAlF,QACAwB,GAAAN,gBAEAC,WAAA,WACAK,GAAAL,aACA4D,GAAA3L,MAAAsK,EACAqB,GAAAhE,UAAA+D,EACAC,GAAA/D,QAAAgE,EACAnC,GAAA,GAAAgB,KAAAC,GAAA,KAAAC,KAAAC,GAAA,KACAkB,GAAAK,GAAAvB,GAAA,GACAkB,IAAAK,KAAAxB,IAAA,IACAH,GAAA,GAAAC,GAAAD,GAAA,GAAAE,KAiKA4C,IACAgH,OAAAvZ,EACAiF,MAAA8M,EACAnF,UAAA0F,EACAzF,QAAAqG,EACAnG,aAAA,WACAwF,GAAA3F,UAAAuG,EACAZ,GAAA1F,QAAAwG,GAEArG,WAAA,WACAuF,GAAA3F,UAAA0F,EACAC,GAAA1F,QAAAqG,GA8IAkB,GAAAD,OAAAC,CAyQA,IAksBA8J,IACAC,GACAC,GAwRA+C,GACAE,GACAD,GACAE,GA4EAwB,GACAC,GACAX,GACAC,GA9iCAtK,GAAApM,IAmMAwc,GAAAhR,GACA,WAAc,UACdqC,GACAM,KACAnT,IAAAJ,KAmUAmX,GAAA,IACAF,IAAAE,GAsLAc,GAAA7S,IAKAoS,IACAxE,OAAAvZ,EACAiF,MAAAjF,EACA4M,UAAAkR,GACAjR,QAAA7M,EACA+M,aAAA/M,EACAgN,WAAAhN,GAsCAyM,IAAA,WACAS,IAAcxN,KAAA,aAAA+M,gBAQd4S,IACAwN,QAAA,SAAA3f,EAAAjI,GACA,MAAAyZ,IAAAxR,EAAAb,SAAApH,IAEA6nB,kBAAA,SAAA5f,EAAAjI,GAEA,IADA,GAAA8nB,GAAA7f,EAAA6f,SAAAtuB,GAAA,EAAAC,EAAAquB,EAAAnuB,SACAH,EAAAC,GAAA,GAAAggB,GAAAqO,EAAAtuB,GAAA4N,SAAApH,GAAA,QACA,YAIA0Z,IACAqO,OAAA,WACA,UAEAC,MAAA,SAAA/f,EAAAjI,GACA,MAAA2Z,IAAA1R,EAAAT,YAAAxH,IAEAioB,WAAA,SAAAhgB,EAAAjI,GAEA,IADA,GAAAwH,GAAAS,EAAAT,YAAAhO,GAAA,EAAAC,EAAA+N,EAAA7N,SACAH,EAAAC,GAAA,GAAAkgB,GAAAnS,EAAAhO,GAAAwG,GAAA,QACA,WAEAkoB,WAAA,SAAAjgB,EAAAjI,GACA,MAAA4Z,IAAA3R,EAAAT,YAAAxH,IAEAmoB,gBAAA,SAAAlgB,EAAAjI,GAEA,IADA,GAAAwH,GAAAS,EAAAT,YAAAhO,GAAA,EAAAC,EAAA+N,EAAA7N,SACAH,EAAAC,GAAA,GAAAmgB,GAAApS,EAAAhO,GAAAwG,GAAA,QACA,WAEAooB,QAAA,SAAAngB,EAAAjI,GACA,MAAAga,IAAA/R,EAAAT,YAAAxH,IAEAqoB,aAAA,SAAApgB,EAAAjI,GAEA,IADA,GAAAwH,GAAAS,EAAAT,YAAAhO,GAAA,EAAAC,EAAA+N,EAAA7N,SACAH,EAAAC,GAAA,GAAAugB,GAAAxS,EAAAhO,GAAAwG,GAAA,QACA,WAEAsoB,mBAAA,SAAArgB,EAAAjI,GAEA,IADA,GAAAuoB,GAAAtgB,EAAAsgB,WAAA/uB,GAAA,EAAAC,EAAA8uB,EAAA5uB,SACAH,EAAAC,GAAA,GAAAggB,GAAA8O,EAAA/uB,GAAAwG,GAAA,QACA,YAqLAyoB,GAAA/hB,IACA4V,GAAA5V,IAMAqV,IACA/b,MAAAjF,EACA4M,UAAA5M,EACA6M,QAAA7M,EACA+M,aAAA,WACAiU,GAAApU,UAAAmU,GACAC,GAAAnU,QAAA2U,IAEAxU,WAAA,WACAgU,GAAApU,UAAAoU,GAAAnU,QAAAmU,GAAA/b,MAAAjF,EACA0tB,GAAA5hB,IAAA2E,GAAA8Q,KACAA,GAAA1V,SAEA0K,OAAA,WACA,GAAA3H,GAAA8e,GAAA,CAEA,OADAA,IAAA7hB,QACA+C,IAsBA8S,GAAA9P,IACA+P,GAAAD,GACA3F,IAAA2F,GACA1F,GAAAD,GAEAyI,IACAvf,MAAAwc,GACA7U,UAAA5M,EACA6M,QAAA7M,EACA+M,aAAA/M,EACAgN,WAAAhN,EACAuW,OAAA,WACA,GAAA/E,KAAAkQ,GAAAC,KAAA5F,GAAAC,IAEA,OADAD,IAAAC,KAAA2F,GAAAD,GAAA9P,KACAJ,IAaAqQ,GAAA,EACAC,GAAA,EACAC,GAAA,EACAO,GAAA,EACAC,GAAA,EACAC,GAAA,EACAQ,GAAA,EACAC,GAAA,EACAC,GAAA,EAMAjB,IACAhd,MAAA2c,GACAhV,UAAAoV,GACAnV,QAAA4V,GACA1V,aAAA,WACAkV,GAAArV,UAAA8V,GACAT,GAAApV,QAAA+V,IAEA5V,WAAA,WACAiV,GAAAhd,MAAA2c,GACAK,GAAArV,UAAAoV,GACAC,GAAApV,QAAA4V,IAEAlM,OAAA,WACA,GAAAvC,GAAAkP,IAAAF,GAAAE,GAAAD,GAAAC,IACAV,IAAAF,GAAAE,GAAAD,GAAAC,IACAT,IAAAF,GAAAE,GAAAD,GAAAC,KACAjQ,QAIA,OAHA+P,IAAAC,GAAAC,GACAO,GAAAC,GAAAC,GACAQ,GAAAC,GAAAC,GAAA,EACAlP,GAgEAmP,IAAAhjB,WACAwtB,QAAA,IACAvJ,YAAA,SAAAvlB,GACA,MAAAP,MAAAqvB,QAAA9uB,EAAAP,MAEAyO,aAAA,WACAzO,KAAAsvB,MAAA,GAEA5gB,WAAA,WACA1O,KAAAsvB,MAAA9b,KAEAlF,UAAA,WACAtO,KAAAuvB,OAAA,GAEAhhB,QAAA,WACA,IAAAvO,KAAAsvB,OAAAtvB,KAAA+kB,SAAAyK,YACAxvB,KAAAuvB,OAAA/b,KAEA7M,MAAA,SAAAzC,EAAAC,GACA,OAAAnE,KAAAuvB,QACA,OACAvvB,KAAA+kB,SAAA0K,OAAAvrB,EAAAC,GACAnE,KAAAuvB,OAAA,CACA,MAEA,QACAvvB,KAAA+kB,SAAA2K,OAAAxrB,EAAAC,EACA,MAEA,SACAnE,KAAA+kB,SAAA0K,OAAAvrB,EAAAlE,KAAAqvB,QAAAlrB,GACAnE,KAAA+kB,SAAA/K,IAAA9V,EAAAC,EAAAnE,KAAAqvB,QAAA,EAAAhlB,MAKA4N,OAAAvW,EAGA,IACAiuB,IACAxK,GACAE,GACAD,GACAE,GALAC,GAAAlY,IAOA4X,IACAte,MAAAjF,EACA4M,UAAA,WACA2W,GAAAte,MAAAqe,IAEAzW,QAAA,WACAohB,IAAAzK,GAAAC,GAAAE,IACAJ,GAAAte,MAAAjF,GAEA+M,aAAA,WACAkhB,IAAA,GAEAjhB,WAAA,WACAihB,GAAA,MAEA1X,OAAA,WACA,GAAA3X,IAAAilB,EAEA,OADAA,IAAAhY,QACAjN,GAmBAklB,IAAA3jB,WACAwtB,QAAA,IACAO,QAAAlK,GAAA,KACAI,YAAA,SAAAvlB,GAEA,OADAA,QAAAP,KAAAqvB,UAAArvB,KAAAqvB,QAAA9uB,EAAAP,KAAA4vB,QAAA,MACA5vB,MAEAyO,aAAA,WACAzO,KAAAsvB,MAAA,GAEA5gB,WAAA,WACA1O,KAAAsvB,MAAA9b,KAEAlF,UAAA,WACAtO,KAAAuvB,OAAA,GAEAhhB,QAAA,WACA,IAAAvO,KAAAsvB,OAAAtvB,KAAAylB,QAAA7jB,KAAA,KACA5B,KAAAuvB,OAAA/b,KAEA7M,MAAA,SAAAzC,EAAAC,GACA,OAAAnE,KAAAuvB,QACA,OACAvvB,KAAAylB,QAAA7jB,KAAA,IAAAsC,EAAA,IAAAC,GACAnE,KAAAuvB,OAAA,CACA,MAEA,QACAvvB,KAAAylB,QAAA7jB,KAAA,IAAAsC,EAAA,IAAAC,EACA,MAEA,SACA,MAAAnE,KAAA4vB,UAAA5vB,KAAA4vB,QAAAlK,GAAA1lB,KAAAqvB,UACArvB,KAAAylB,QAAA7jB,KAAA,IAAAsC,EAAA,IAAAC,EAAAnE,KAAA4vB,WAKA3X,OAAA,WACA,GAAAjY,KAAAylB,QAAAnlB,OAAA,CACA,GAAA2X,GAAAjY,KAAAylB,QAAAoK,KAAA,GAEA,OADA7vB,MAAAylB,WACAxN,EAEA,cAkFAqO,GAAAzkB,WACAC,YAAAwkB,GACA3f,MAAA,SAAAzC,EAAAC,GAAyBnE,KAAAgO,OAAArH,MAAAzC,EAAAC,IACzB8W,OAAA,WAAsBjb,KAAAgO,OAAAiN,UACtB3M,UAAA,WAAyBtO,KAAAgO,OAAAM,aACzBC,QAAA,WAAuBvO,KAAAgO,OAAAO,WACvBE,aAAA,WAA4BzO,KAAAgO,OAAAS,gBAC5BC,WAAA,WAA0B1O,KAAAgO,OAAAU,cAgD1B,IAAA2Z,IAAA,GACAF,GAAAngB,GAAA,GAAAuH,IAkGAwa,GAAA1D,IACA1f,MAAA,SAAAzC,EAAAC,GACAnE,KAAAgO,OAAArH,MAAAzC,EAAAqL,GAAApL,EAAAoL,OA0VAmc,GAAAL,GAAA,SAAAyE,GACA,MAAA1oB,IAAA,KAAA0oB,KAGApE,IAAA7V,OAAAyV,GAAA,SAAA3X,GACA,SAAAjJ,EAAAiJ,EAAA,IASA,IAAAiY,IAAAP,GAAA,SAAA/pB,GACA,OAAAA,EAAAsM,EAAAtM,OAAA6G,GAAA7G,IAGAsqB,IAAA/V,OAAAyV,GAAA,SAAA3X,GACA,MAAAA,KAaAkY,GAAAhW,OAAA,SAAA3R,EAAAC,GACA,OAAAD,EAAA,EAAAqX,GAAA+S,GAAAnqB,IAAA8D,KAgFAukB,GAAA3W,OAAA2W,GAsCAO,GAAAlX,OAAAyV,GAAA/P,IA0EAoS,GAAA9X,OAAA,SAAA3R,EAAAC,GACA,GAAA0N,GAAAvC,EAAAnL,EAAAhE,EAAA,EACA,IACA,GAAA0nB,GAAAvY,IAAAse,EAAA/F,GACAvY,IAAAuC,GAAAvC,GAAA,SAAAuY,GAAA,QAAA+F,IAAA,gBAAA/F,EAAA,QAAA+F,KAAAzpB,IACA,SAAA0jB,GAAA,QAAA+F,IAAA,gBAAA/F,EAAA,WAAA+F,WACGzb,GAAAN,GAAAiB,MAAA3S,EAAA,EACH,QACA+D,GAAA,OAAA2jB,EAAAvY,OAAA,QAAAuY,IAAA,QAAAA,OAAA,gBAAAA,MACAvY,IAaAwe,GAAAjY,OAAAyV,GAAA5gB,GAaAsjB,GAAAnY,OAAAyV,GAAA,SAAA3X,GACA,SAAA4H,GAAA5H,KAaAua,GAAArY,OAAA,SAAA3R,EAAAC,GACA,QAAAA,EAAA,EAAAoX,GAAA+S,GAAApqB,IAAA+D,KAoBArI,EAAAmwB,QAAAzf,EACA1Q,EAAAowB,UAAA9c,EACAtT,EAAAqwB,YAAAva,EACA9V,EAAAswB,UAAA5Y,GACA1X,EAAAuwB,oBAAAtG,GACAjqB,EAAAwwB,cAAAzU,GACA/b,EAAAywB,cAAAhR,GACAzf,EAAA0wB,iBAAAvS,GACAne,EAAA2wB,YAAAzP,GACAlhB,EAAA4wB,YAAArQ,GACAvgB,EAAA6wB,aAAAtP,GACAvhB,EAAA8wB,eAAA3O,GACAniB,EAAA+wB,eAAA/X,GACAhZ,EAAAgxB,UAAAtwB,GACAV,EAAAixB,QAAAlL,GACA/lB,EAAAkxB,UAAApG,GACA9qB,EAAAmxB,aAAAlG,GACAjrB,EAAAoxB,sBAAAvF,GACA7rB,EAAAqxB,yBAAAvF,GACA9rB,EAAAsxB,wBAAAvF,GACA/rB,EAAAuxB,2BAAAvF,GACAhsB,EAAAwxB,kBAAA7E,GACA3sB,EAAAyxB,qBAAAjF,GACAxsB,EAAA0xB,kBAAA7G,GACA7qB,EAAA2xB,qBAAAlH,GACAzqB,EAAA4xB,oBAAA1E,GACAltB,EAAA6xB,uBAAA/E,GACA9sB,EAAA8xB,mBAAAjF,GACA7sB,EAAA+xB,sBAAAnF,GACA5sB,EAAAgyB,YAAA5E,GACAptB,EAAAiyB,eAAA9E,GACAntB,EAAAkyB,YAAAxE,GACA1tB,EAAAmyB,cAAAnM,GACAhmB,EAAAoyB,qBAAA3I,GACAzpB,EAAAqyB,YAAAjG,GACApsB,EAAAsyB,eAAArG,GACAjsB,EAAAuyB,iBAAAtE,GACAjuB,EAAAwyB,oBAAAzE,GACA/tB,EAAAyyB,gBAAAtE,GACAnuB,EAAA0yB,mBAAAxE,GACAluB,EAAA2yB,iBAAAtE,GACAruB,EAAA4yB,oBAAAxE,GACApuB,EAAA6yB,sBAAAtE,GACAvuB,EAAA8yB,yBAAAxE,GACAtuB,EAAA+yB,YAAArc,GACA1W,EAAA+O,YACA/O,EAAAgzB,aAAAzM,GAEA3jB,OAAAC,eAAA7C,EAAA,cAA8C2B,OAAA,OJ6mBxCsxB,IACA,SAAUlzB,EAAQC,EAASC,IKpnHjC,SAAAC,EAAAC,GACAA,EAAAH,IAGCI,KAAA,SAAAJ,GAA4B,YAc7B,SAAAkzB,KACA,MAAAC,KAAAC,EAAAC,GAAAF,EAAAG,EAAAJ,MAAAK,GAGA,QAAAF,KACAF,EAAA,EAGA,QAAAK,KACApzB,KAAAqzB,MACArzB,KAAAszB,MACAtzB,KAAAuzB,MAAA,KA0BA,QAAAC,GAAA/xB,EAAAgyB,EAAAC,GACA,GAAAxzB,GAAA,GAAAkzB,EAEA,OADAlzB,GAAAyzB,QAAAlyB,EAAAgyB,EAAAC,GACAxzB,EAGA,QAAA0zB,KACAd,MACAe,CAEA,KADA,GAAAhqB,GAAA3J,EAAA4zB,EACA5zB,IACA2J,EAAAkpB,EAAA7yB,EAAAozB,QAAA,GAAApzB,EAAAmzB,MAAAlxB,KAAA,KAAA0H,GACA3J,IAAAqzB,QAEAM,EAGA,QAAAE,KACAhB,GAAAiB,EAAAd,EAAAJ,OAAAK,EACAU,EAAAI,EAAA,CACA,KACAL,IACG,QACHC,EAAA,EACAK,IACAnB,EAAA,GAIA,QAAAoB,KACA,GAAArB,GAAAI,EAAAJ,MAAAW,EAAAX,EAAAkB,CACAP,GAAAW,IAAAjB,GAAAM,EAAAO,EAAAlB,GAGA,QAAAoB,KAEA,IADA,GAAAld,GAAAoG,EAAAnG,EAAA6c,EAAAJ,EAAApgB,IACA2D,GACAA,EAAAoc,OACAK,EAAAzc,EAAAqc,QAAAI,EAAAzc,EAAAqc,OACAtc,EAAAC,MAAAsc,QAEAnW,EAAAnG,EAAAsc,MAAAtc,EAAAsc,MAAA,KACAtc,EAAAD,IAAAuc,MAAAnW,EAAA0W,EAAA1W,EAGAiX,GAAArd,EACAsd,EAAAZ,GAGA,QAAAY,GAAAZ,GACA,IAAAG,EAAA,CACAI,MAAAvtB,aAAAutB,GACA,IAAAR,GAAAC,EAAAX,CACAU,GAAA,IACAC,EAAApgB,MAAA2gB,EAAAxwB,WAAAswB,EAAAL,EAAAR,EAAAJ,MAAAK,IACAoB,MAAAC,cAAAD,MAEAA,IAAAP,EAAAd,EAAAJ,MAAAyB,EAAAE,YAAAN,EAAAC,IACAP,EAAA,EAAAb,EAAAe,KA3GA,GAIAD,GACAO,EALAR,EAAA,EACAI,EAAA,EACAM,EAAA,EACAH,EAAA,IAGAJ,EAAA,EACAjB,EAAA,EACAI,EAAA,EACAD,EAAA,gBAAAwB,0BAAA5B,IAAA4B,YAAAC,KACA3B,EAAA,gBAAA4B,gBAAAC,sBAAAD,OAAAC,sBAAAC,KAAAF,QAAA,SAAAvI,GAAqI5oB,WAAA4oB,EAAA,IAgBrI+G,GAAAvxB,UAAA2xB,EAAA3xB,WACAC,YAAAsxB,EACAO,QAAA,SAAAlyB,EAAAgyB,EAAAC,GACA,qBAAAjyB,GAAA,SAAAszB,WAAA,6BACArB,IAAA,MAAAA,EAAAZ,KAAAY,IAAA,MAAAD,EAAA,GAAAA,GACAzzB,KAAAuzB,OAAAc,IAAAr0B,OACAq0B,IAAAd,MAAAvzB,KACA8zB,EAAA9zB,KACAq0B,EAAAr0B,MAEAA,KAAAqzB,MAAA5xB,EACAzB,KAAAszB,MAAAI,EACAY,KAEAU,KAAA,WACAh1B,KAAAqzB,QACArzB,KAAAqzB,MAAA,KACArzB,KAAAszB,MAAAhgB,IACAghB,MAmEA,IAAAW,GAAA,SAAAxzB,EAAAgyB,EAAAC,GACA,GAAAxzB,GAAA,GAAAkzB,EAMA,OALAK,GAAA,MAAAA,EAAA,GAAAA,EACAvzB,EAAAyzB,QAAA,SAAAuB,GACAh1B,EAAA80B,OACAvzB,EAAAyzB,EAAAzB,IACGA,EAAAC,GACHxzB,GAGAi1B,EAAA,SAAA1zB,EAAAgyB,EAAAC,GACA,GAAAxzB,GAAA,GAAAkzB,GAAAgC,EAAA3B,CACA,cAAAA,GAAAvzB,EAAAyzB,QAAAlyB,EAAAgyB,EAAAC,GAAAxzB,IACAuzB,KAAAC,EAAA,MAAAA,EAAAZ,KAAAY,EACAxzB,EAAAyzB,QAAA,QAAA0B,GAAAH,GACAA,GAAAE,EACAl1B,EAAAyzB,QAAA0B,EAAAD,GAAA3B,EAAAC,GACAjyB,EAAAyzB,IACGzB,EAAAC,GACHxzB,GAGAN,GAAAkzB,MACAlzB,EAAA4zB,QACA5zB,EAAAg0B,aACAh0B,EAAAq0B,QAAAgB,EACAr1B,EAAA20B,SAAAY,EAEA3yB,OAAAC,eAAA7C,EAAA,cAA8C2B,OAAA,OL8nHxC+zB,IACA,SAAU31B,EAAQC,EAASC,IMhxHjC,SAAAC,EAAAC,GACAA,EAAAH,EAAAC,EAAA,IAAAA,EAAA,IAAAA,EAAA,KAAAA,EAAA,KAAAA,EAAA,KAAAA,EAAA,OAGCG,KAAA,SAAAJ,EAAAgD,EAAAD,EAAA4yB,EAAAC,EAAAC,EAAAC,GAAwF,YAgCzF,SAAAC,GAAAC,EAAA5xB,GACA,GAAA6xB,GAAAx0B,EAAAu0B,EAAA5xB,EACA,IAAA6xB,EAAAC,MAAAC,EAAA,SAAAv1B,OAAA,8BACA,OAAAq1B,GAGA,QAAAr0B,GAAAo0B,EAAA5xB,GACA,GAAA6xB,GAAAx0B,EAAAu0B,EAAA5xB,EACA,IAAA6xB,EAAAC,MAAAE,EAAA,SAAAx1B,OAAA,4BACA,OAAAq1B,GAGA,QAAAx0B,GAAAu0B,EAAA5xB,GACA,GAAA6xB,GAAAD,EAAAK,YACA,KAAAJ,SAAA7xB,IAAA,SAAAxD,OAAA,uBACA,OAAAq1B,GAGA,QAAAK,GAAAN,EAAA5xB,EAAAmyB,GASA,QAAAN,GAAAX,GACAiB,EAAAL,MAAAM,EACAD,EAAA3C,MAAAG,QAAAza,EAAAid,EAAA1C,MAAA0C,EAAAzC,MAGAyC,EAAA1C,OAAAyB,GAAAhc,EAAAgc,EAAAiB,EAAA1C,OAGA,QAAAva,GAAAgc,GACA,GAAA/0B,GAAAwZ,EAAAvZ,EAAAmY,CAGA,IAAA4d,EAAAL,QAAAM,EAAA,MAAApB,IAEA,KAAA70B,IAAAk2B,GAEA,GADA9d,EAAA8d,EAAAl2B,GACAoY,EAAAvX,OAAAm1B,EAAAn1B,KAAA,CAKA,GAAAuX,EAAAud,QAAAQ,EAAA,MAAAf,GAAAtB,QAAA/a,EAIAX,GAAAud,QAAAS,GACAhe,EAAAud,MAAAU,EACAje,EAAAib,MAAAwB,OACAzc,EAAAxW,GAAAI,KAAA,YAAAyzB,IAAAa,SAAAle,EAAAoN,MAAApN,EAAAme,aACAL,GAAAl2B,KAMAA,EAAA6D,IACAuU,EAAAud,MAAAU,EACAje,EAAAib,MAAAwB,aACAqB,GAAAl2B,IAoBA,GAZAo1B,EAAAtB,QAAA,WACAkC,EAAAL,QAAAQ,IACAH,EAAAL,MAAAS,EACAJ,EAAA3C,MAAAG,QAAA0B,EAAAc,EAAA1C,MAAA0C,EAAAzC,MACA2B,EAAAH,MAMAiB,EAAAL,MAAAE,EACAG,EAAAp0B,GAAAI,KAAA,QAAAyzB,IAAAa,SAAAN,EAAAxQ,MAAAwQ,EAAAO,OACAP,EAAAL,QAAAE,EAAA,CAKA,IAJAG,EAAAL,MAAAQ,EAGAK,EAAA,GAAAr0B,OAAAlC,EAAA+1B,EAAAQ,MAAAr2B,QACAH,EAAA,EAAAwZ,GAAA,EAAuBxZ,EAAAC,IAAOD,GAC9BoY,EAAA4d,EAAAQ,MAAAx2B,GAAAoB,MAAAY,KAAAyzB,IAAAa,SAAAN,EAAAxQ,MAAAwQ,EAAAO,UACAC,IAAAhd,GAAApB,EAGAoe,GAAAr2B,OAAAqZ,EAAA,GAGA,QAAA0b,GAAAH,GAKA,IAJA,GAAAh1B,GAAAg1B,EAAAiB,EAAAS,SAAAT,EAAAU,KAAA10B,KAAA,KAAA+yB,EAAAiB,EAAAS,WAAAT,EAAA3C,MAAAG,QAAAqB,GAAAmB,EAAAL,MAAAgB,EAAA,GACA32B,GAAA,EACAC,EAAAu2B,EAAAr2B,SAEAH,EAAAC,GACAu2B,EAAAx2B,GAAAgC,KAAA,KAAAjC,EAIAi2B,GAAAL,QAAAgB,IACAX,EAAAp0B,GAAAI,KAAA,MAAAyzB,IAAAa,SAAAN,EAAAxQ,MAAAwQ,EAAAO,OACA1B,KAIA,QAAAA,KACAmB,EAAAL,MAAAU,EACAL,EAAA3C,MAAAwB,aACAqB,GAAAryB,EACA,QAAA7D,KAAAk2B,GAAA,aACAT,GAAAK,aApGA,GACAU,GADAN,EAAAT,EAAAK,YAKAI,GAAAryB,GAAAmyB,EACAA,EAAA3C,MAAA+B,EAAA/B,MAAAqC,EAAA,EAAAM,EAAAzC,MA+HA,QAAAqD,GAAA/yB,EAAAhD,GACA,GAAAg2B,GAAAC,CACA,mBACA,GAAApB,GAAAr0B,EAAAxB,KAAAgE,GACA2yB,EAAAd,EAAAc,KAKA,IAAAA,IAAAK,EAAA,CACAC,EAAAD,EAAAL,CACA,QAAAx2B,GAAA,EAAAC,EAAA62B,EAAA32B,OAAwCH,EAAAC,IAAOD,EAC/C,GAAA82B,EAAA92B,GAAAa,SAAA,CACAi2B,IAAA/1B,QACA+1B,EAAAC,OAAA/2B,EAAA,EACA,QAKA01B,EAAAc,MAAAM,GAIA,QAAAE,GAAAnzB,EAAAhD,EAAAO,GACA,GAAAy1B,GAAAC,CACA,sBAAA11B,GAAA,SAAAf,MACA,mBACA,GAAAq1B,GAAAr0B,EAAAxB,KAAAgE,GACA2yB,EAAAd,EAAAc,KAKA,IAAAA,IAAAK,EAAA,CACAC,GAAAD,EAAAL,GAAAz1B,OACA,QAAAhB,IAAoBc,OAAAO,SAAyBpB,EAAA,EAAAC,EAAA62B,EAAA32B,OAA2BH,EAAAC,IAAOD,EAC/E,GAAA82B,EAAA92B,GAAAa,SAAA,CACAi2B,EAAA92B,GAAAD,CACA,OAGAC,IAAAC,GAAA62B,EAAAr1B,KAAA1B,GAGA21B,EAAAc,MAAAM,GAsBA,QAAAG,GAAAC,EAAAr2B,EAAAO,GACA,GAAAyC,GAAAqzB,EAAAC,GAOA,OALAD,GAAAE,KAAA,WACA,GAAA1B,GAAAr0B,EAAAxB,KAAAgE,IACA6xB,EAAAt0B,QAAAs0B,EAAAt0B,WAA2CP,GAAAO,EAAAgB,MAAAvC,KAAAK,aAG3C,SAAAu1B,GACA,MAAAv0B,GAAAu0B,EAAA5xB,GAAAzC,MAAAP,IAYA,QAAAw2B,GAAAx2B,GACA,kBACAhB,KAAAy3B,gBAAAz2B,IAIA,QAAA02B,GAAAC,GACA,kBACA33B,KAAA43B,kBAAAD,EAAAE,MAAAF,EAAAG,QAIA,QAAAC,GAAA/2B,EAAAg3B,EAAAC,GACA,GAAAC,GACAC,CACA,mBACA,GAAAC,GAAAp4B,KAAAq4B,aAAAr3B,EACA,OAAAo3B,KAAAH,EAAA,KACAG,IAAAF,EAAAC,EACAA,EAAAH,EAAAE,EAAAE,EAAAH,IAIA,QAAAK,GAAAX,EAAAK,EAAAC,GACA,GAAAC,GACAC,CACA,mBACA,GAAAC,GAAAp4B,KAAAu4B,eAAAZ,EAAAE,MAAAF,EAAAG,MACA,OAAAM,KAAAH,EAAA,KACAG,IAAAF,EAAAC,EACAA,EAAAH,EAAAE,EAAAE,EAAAH,IAIA,QAAAO,GAAAx3B,EAAAg3B,EAAAz2B,GACA,GAAA22B,GACAO,EACAN,CACA,mBACA,GAAAC,GAAAH,EAAA12B,EAAAvB,KACA,cAAAi4B,MAAAj4B,MAAAy3B,gBAAAz2B,IACAo3B,EAAAp4B,KAAAq4B,aAAAr3B,GACAo3B,IAAAH,EAAA,KACAG,IAAAF,GAAAD,IAAAQ,EAAAN,EACAA,EAAAH,EAAAE,EAAAE,EAAAK,EAAAR,KAIA,QAAAS,GAAAf,EAAAK,EAAAz2B,GACA,GAAA22B,GACAO,EACAN,CACA,mBACA,GAAAC,GAAAH,EAAA12B,EAAAvB,KACA,cAAAi4B,MAAAj4B,MAAA43B,kBAAAD,EAAAE,MAAAF,EAAAG,QACAM,EAAAp4B,KAAAu4B,eAAAZ,EAAAE,MAAAF,EAAAG,OACAM,IAAAH,EAAA,KACAG,IAAAF,GAAAD,IAAAQ,EAAAN,EACAA,EAAAH,EAAAE,EAAAE,EAAAK,EAAAR,KAYA,QAAAU,GAAAhB,EAAAp2B,GACA,QAAAo1B,KACA,GAAAf,GAAA51B,KAAAG,EAAAoB,EAAAgB,MAAAqzB,EAAAv1B,UACA,OAAAF,IAAA,SAAAD,GACA01B,EAAAgD,eAAAjB,EAAAE,MAAAF,EAAAG,MAAA33B,EAAAD,KAIA,MADAy2B,GAAAkC,OAAAt3B,EACAo1B,EAGA,QAAAmC,GAAA93B,EAAAO,GACA,QAAAo1B,KACA,GAAAf,GAAA51B,KAAAG,EAAAoB,EAAAgB,MAAAqzB,EAAAv1B,UACA,OAAAF,IAAA,SAAAD,GACA01B,EAAAmD,aAAA/3B,EAAAb,EAAAD,KAIA,MADAy2B,GAAAkC,OAAAt3B,EACAo1B,EAYA,QAAAqC,GAAAh1B,EAAAzC,GACA,kBACAo0B,EAAA31B,KAAAgE,GAAAyvB,OAAAlyB,EAAAgB,MAAAvC,KAAAK,YAIA,QAAA44B,GAAAj1B,EAAAzC,GACA,MAAAA,MAAA,WACAo0B,EAAA31B,KAAAgE,GAAAyvB,MAAAlyB,GAcA,QAAA23B,GAAAl1B,EAAAzC,GACA,kBACAC,EAAAxB,KAAAgE,GAAA4yB,UAAAr1B,EAAAgB,MAAAvC,KAAAK,YAIA,QAAA84B,GAAAn1B,EAAAzC,GACA,MAAAA,MAAA,WACAC,EAAAxB,KAAAgE,GAAA4yB,SAAAr1B,GAcA,QAAA63B,GAAAp1B,EAAAzC,GACA,qBAAAA,GAAA,SAAAf,MACA,mBACAgB,EAAAxB,KAAAgE,GAAA6yB,KAAAt1B,GA4CA,QAAA2X,GAAAlY,GACA,OAAAA,EAAA,IAAAH,OAAAC,MAAA,SAAAu4B,MAAA,SAAAn5B,GACA,GAAAC,GAAAD,EAAAe,QAAA,IAEA,OADAd,IAAA,IAAAD,IAAAgB,MAAA,EAAAf,KACAD,GAAA,UAAAA,IAIA,QAAAo5B,GAAAt1B,EAAAhD,EAAAu4B,GACA,GAAAC,GAAAC,EAAAC,EAAAxgB,EAAAlY,GAAA20B,EAAAn0B,CACA,mBACA,GAAAq0B,GAAA6D,EAAA15B,KAAAgE,GACAjC,EAAA8zB,EAAA9zB,EAKAA,KAAAy3B,IAAAC,GAAAD,EAAAz3B,GAAAG,QAAAH,GAAAf,EAAAu4B,GAEA1D,EAAA9zB,GAAA03B,GAYA,QAAAE,GAAA31B,GACA,kBACA,GAAA41B,GAAA55B,KAAA2E,UACA,QAAAxE,KAAAH,MAAAi2B,aAAA,IAAA91B,IAAA6D,EAAA,MACA41B,MAAAC,YAAA75B,OAwDA,QAAA85B,GAAA94B,EAAAg3B,GACA,GAAAE,GACAO,EACAN,CACA,mBACA,GAAAC,GAAAx1B,EAAAc,MAAA1D,KAAAgB,GACAi3B,GAAAj4B,KAAA0D,MAAAq2B,eAAA/4B,GAAA4B,EAAAc,MAAA1D,KAAAgB,GACA,OAAAo3B,KAAAH,EAAA,KACAG,IAAAF,GAAAD,IAAAQ,EAAAN,EACAA,EAAAH,EAAAE,EAAAE,EAAAK,EAAAR,IAIA,QAAA+B,GAAAh5B,GACA,kBACAhB,KAAA0D,MAAAq2B,eAAA/4B,IAIA,QAAAi5B,GAAAj5B,EAAAg3B,EAAAC,GACA,GAAAC,GACAC,CACA,mBACA,GAAAC,GAAAx1B,EAAAc,MAAA1D,KAAAgB,EACA,OAAAo3B,KAAAH,EAAA,KACAG,IAAAF,EAAAC,EACAA,EAAAH,EAAAE,EAAAE,EAAAH,IAIA,QAAAiC,GAAAl5B,EAAAg3B,EAAAz2B,GACA,GAAA22B,GACAO,EACAN,CACA,mBACA,GAAAC,GAAAx1B,EAAAc,MAAA1D,KAAAgB,GACAi3B,EAAA12B,EAAAvB,KAEA,OADA,OAAAi4B,IAAAj4B,KAAA0D,MAAAq2B,eAAA/4B,GAAAi3B,EAAAr1B,EAAAc,MAAA1D,KAAAgB,IACAo3B,IAAAH,EAAA,KACAG,IAAAF,GAAAD,IAAAQ,EAAAN,EACAA,EAAAH,EAAAE,EAAAE,EAAAK,EAAAR,IAcA,QAAAkC,GAAAn5B,EAAAO,EAAA64B,GACA,QAAAzD,KACA,GAAAf,GAAA51B,KAAAG,EAAAoB,EAAAgB,MAAAqzB,EAAAv1B,UACA,OAAAF,IAAA,SAAAD,GACA01B,EAAAlyB,MAAA22B,YAAAr5B,EAAAb,EAAAD,GAAAk6B,IAIA,MADAzD,GAAAkC,OAAAt3B,EACAo1B,EAWA,QAAA2D,GAAA/4B,GACA,kBACAvB,KAAAu6B,YAAAh5B,GAIA,QAAAi5B,GAAAj5B,GACA,kBACA,GAAA02B,GAAA12B,EAAAvB,KACAA,MAAAu6B,YAAA,MAAAtC,EAAA,GAAAA,GAkCA,QAAAwC,GAAAC,EAAAC,EAAA35B,EAAAgD,GACAhE,KAAA46B,QAAAF,EACA16B,KAAA66B,SAAAF,EACA36B,KAAA86B,MAAA95B,EACAhB,KAAAs3B,IAAAtzB,EAGA,QAAAqzB,GAAAr2B,GACA,MAAA4B,GAAAU,YAAA+zB,WAAAr2B,GAGA,QAAA+5B,KACA,QAAA/2B,GAuCA,QAAAg3B,GAAApF,EAAA5xB,GAEA,IADA,GAAAi3B,KACAA,EAAArF,EAAAK,iBAAAgF,IAAAj3B,KACA,KAAA4xB,IAAAjxB,YACA,MAAAu2B,IAAAxH,KAAA6B,EAAAzC,MAAAoI,EAGA,OAAAD,GAvtBA,GAAAE,GAAAx4B,EAAA1C,SAAA,2BACAm7B,KAEArF,EAAA,EACAK,EAAA,EACAJ,EAAA,EACAM,EAAA,EACAC,EAAA,EACAO,EAAA,EACAN,EAAA,EAEAX,EAAA,SAAAD,EAAA50B,EAAAgD,EAAA2hB,EAAA+Q,EAAAuE,GACA,GAAA5E,GAAAT,EAAAK,YACA,IAAAI,GACA,GAAAryB,IAAAqyB,GAAA,WADAT,GAAAK,eAEAC,GAAAN,EAAA5xB,GACAhD,OACA2kB,QACA+Q,QACA30B,GAAAo5B,EACAxE,MAAAyE,EACA1H,KAAAuH,EAAAvH,KACAD,MAAAwH,EAAAxH,MACAmD,SAAAqE,EAAArE,SACAC,KAAAoE,EAAApE,KACArD,MAAA,KACAsC,MAAAC,KA+HAsF,EAAA,SAAAzF,EAAA50B,GACA,GACA60B,GACA5xB,EAEA9D,EAJAk2B,EAAAT,EAAAK,aAGAqF,GAAA,CAGA,IAAAjF,EAAA,CAEAr1B,EAAA,MAAAA,EAAA,KAAAA,EAAA,EAEA,KAAAb,IAAAk2B,IACAR,EAAAQ,EAAAl2B,IAAAa,UACAiD,EAAA4xB,EAAAC,MAAAE,GAAAH,EAAAC,MAAAgB,EACAjB,EAAAC,MAAAU,EACAX,EAAArC,MAAAwB,OACA/wB,GAAA4xB,EAAA9zB,GAAAI,KAAA,YAAAyzB,IAAAa,SAAAZ,EAAAlQ,MAAAkQ,EAAAa,aACAL,GAAAl2B,IALkDm7B,GAAA,CAQlDA,UAAA1F,GAAAK,eAGAsF,EAAA,SAAAv6B,GACA,MAAAhB,MAAAu3B,KAAA,WACA8D,EAAAr7B,KAAAgB,MAqDAw6B,EAAA,SAAAx6B,EAAAO,GACA,GAAAyC,GAAAhE,KAAAs3B,GAIA,IAFAt2B,GAAA,GAEAX,UAAAC,OAAA,GAEA,OAAAJ,GADAy2B,EAAAt1B,EAAArB,KAAA41B,OAAA5xB,GAAA2yB,MACAx2B,EAAA,EAAAC,EAAAu2B,EAAAr2B,OAAwCH,EAAAC,IAAOD,EAC/C,IAAAD,EAAAy2B,EAAAx2B,IAAAa,SACA,MAAAd,GAAAqB,KAGA,aAGA,MAAAvB,MAAAu3B,MAAA,MAAAh2B,EAAAw1B,EAAAI,GAAAnzB,EAAAhD,EAAAO,KAgBAqX,GAAA,SAAAnO,EAAAgD,GACA,GAAAnM,EACA,wBAAAmM,GAAA+nB,EAAAiG,kBACAhuB,YAAAgoB,GAAAiG,MAAAlG,EAAAmG,gBACAr6B,EAAAm0B,EAAAiG,MAAAjuB,OAAAnM,EAAAk0B,EAAAmG,gBACAnG,EAAAoG,mBAAAnxB,EAAAgD,IAiEAouB,GAAA,SAAA76B,EAAAO,GACA,GAAAo2B,GAAA/0B,EAAAk5B,UAAA96B,GAAAb,EAAA,cAAAw3B,EAAAnC,EAAAuG,wBAAAnjB,EACA,OAAA5Y,MAAA84B,UAAA93B,EAAA,kBAAAO,IACAo2B,EAAAG,MAAAY,EAAAF,GAAAb,EAAAx3B,EAAAi3B,EAAAp3B,KAAA,QAAAgB,EAAAO,IACA,MAAAA,GAAAo2B,EAAAG,MAAAJ,EAAAF,GAAAG,IACAA,EAAAG,MAAAQ,EAAAP,GAAAJ,EAAAx3B,EAAAoB,EAAA,MAyBAy6B,GAAA,SAAAh7B,EAAAO,GACA,GAAAglB,GAAA,QAAAvlB,CACA,IAAAX,UAAAC,OAAA,SAAAimB,EAAAvmB,KAAA22B,MAAApQ,OAAAsS,MACA,UAAAt3B,EAAA,MAAAvB,MAAA22B,MAAApQ,EAAA,KACA,sBAAAhlB,GAAA,SAAAf,MACA,IAAAm3B,GAAA/0B,EAAAk5B,UAAA96B,EACA,OAAAhB,MAAA22B,MAAApQ,GAAAoR,EAAAG,MAAAa,EAAAG,GAAAnB,EAAAp2B,KAeA06B,GAAA,SAAA16B,GACA,GAAAyC,GAAAhE,KAAAs3B,GAEA,OAAAj3B,WAAAC,OACAN,KAAAu3B,MAAA,kBAAAh2B,GACAy3B,EACAC,GAAAj1B,EAAAzC,IACAF,EAAArB,KAAA41B,OAAA5xB,GAAAyvB,OAeAyI,GAAA,SAAA36B,GACA,GAAAyC,GAAAhE,KAAAs3B,GAEA,OAAAj3B,WAAAC,OACAN,KAAAu3B,MAAA,kBAAAh2B,GACA23B,EACAC,GAAAn1B,EAAAzC,IACAF,EAAArB,KAAA41B,OAAA5xB,GAAA4yB,UAUAuF,GAAA,SAAA56B,GACA,GAAAyC,GAAAhE,KAAAs3B,GAEA,OAAAj3B,WAAAC,OACAN,KAAAu3B,KAAA6B,EAAAp1B,EAAAzC,IACAF,EAAArB,KAAA41B,OAAA5xB,GAAA6yB,MAGAuF,GAAA,SAAAC,GACA,kBAAAA,OAAAz5B,EAAA05B,QAAAD,GAEA,QAAA3B,GAAA16B,KAAA46B,QAAAtlB,EAAAolB,EAAAp6B,OAAAi8B,EAAA,GAAAj6B,OAAAgT,GAAAqE,EAAA,EAAqFA,EAAArE,IAAOqE,EAC5F,OAAAic,GAAAc,EAAAgE,EAAA/gB,GAAAvZ,EAAAs2B,EAAAp2B,OAAAk8B,EAAAD,EAAA5iB,MAAAxZ,EAAA,EAA4FA,EAAAC,IAAOD,GACnGy1B,EAAAc,EAAAv2B,KAAAk8B,EAAAl6B,KAAAyzB,IAAAa,SAAAt2B,EAAAu2B,IACA8F,EAAA56B,KAAAg0B,EAKA,WAAA6E,GAAA8B,EAAAv8B,KAAA66B,SAAA76B,KAAA86B,MAAA96B,KAAAs3B,MAGAmF,GAAA,SAAApF,GACA,GAAAA,EAAAC,MAAAt3B,KAAAs3B,IAAA,SAAA92B,MAEA,QAAAk8B,GAAA18B,KAAA46B,QAAA+B,EAAAtF,EAAAuD,QAAAgC,EAAAF,EAAAp8B,OAAAu8B,EAAAF,EAAAr8B,OAAAgV,EAAAnO,KAAAgY,IAAAyd,EAAAC,GAAAC,EAAA,GAAAx6B,OAAAs6B,GAAAjjB,EAAA,EAA+JA,EAAArE,IAAOqE,EACtK,OAAAic,GAAAmH,EAAAL,EAAA/iB,GAAAqjB,EAAAL,EAAAhjB,GAAAvZ,EAAA28B,EAAAz8B,OAAA0a,EAAA8hB,EAAAnjB,GAAA,GAAArX,OAAAlC,GAAAD,EAAA,EAAwHA,EAAAC,IAAOD,GAC/Hy1B,EAAAmH,EAAA58B,IAAA68B,EAAA78B,MACA6a,EAAA7a,GAAAy1B,EAKA,MAAQjc,EAAAijB,IAAQjjB,EAChBmjB,EAAAnjB,GAAA+iB,EAAA/iB,EAGA,WAAA8gB,GAAAqC,EAAA98B,KAAA66B,SAAA76B,KAAA86B,MAAA96B,KAAAs3B,MA0BA2F,GAAA,SAAAj8B,EAAAu4B,GACA,GAAAv1B,GAAAhE,KAAAs3B,GAEA,OAAAj3B,WAAAC,OAAA,EACAe,EAAArB,KAAA41B,OAAA5xB,GAAAjC,MAAAf,GACAhB,KAAAu3B,KAAA+B,EAAAt1B,EAAAhD,EAAAu4B,KAWA2D,GAAA,WACA,MAAAl9B,MAAA+B,GAAA,aAAA43B,EAAA35B,KAAAs3B,OAGA6F,GAAA,SAAA55B,GACA,GAAAvC,GAAAhB,KAAA86B,MACA92B,EAAAhE,KAAAs3B,GAEA,mBAAA/zB,OAAAX,EAAAw6B,SAAA75B,GAEA,QAAAm3B,GAAA16B,KAAA46B,QAAAtlB,EAAAolB,EAAAp6B,OAAAi8B,EAAA,GAAAj6B,OAAAgT,GAAAqE,EAAA,EAAqFA,EAAArE,IAAOqE,EAC5F,OAAAic,GAAAyH,EAAA3G,EAAAgE,EAAA/gB,GAAAvZ,EAAAs2B,EAAAp2B,OAAAk8B,EAAAD,EAAA5iB,GAAA,GAAArX,OAAAlC,GAAAD,EAAA,EAA+GA,EAAAC,IAAOD,GACtHy1B,EAAAc,EAAAv2B,MAAAk9B,EAAA95B,EAAApB,KAAAyzB,IAAAa,SAAAt2B,EAAAu2B,MACA,YAAAd,KAAAyH,EAAA5G,SAAAb,EAAAa,UACA+F,EAAAr8B,GAAAk9B,EACAxH,EAAA2G,EAAAr8B,GAAAa,EAAAgD,EAAA7D,EAAAq8B,EAAAn7B,EAAAu0B,EAAA5xB,IAKA,WAAAy2B,GAAA8B,EAAAv8B,KAAA66B,SAAA75B,EAAAgD,IAGAs5B,GAAA,SAAA/5B,GACA,GAAAvC,GAAAhB,KAAA86B,MACA92B,EAAAhE,KAAAs3B,GAEA,mBAAA/zB,OAAAX,EAAA26B,YAAAh6B,GAEA,QAAAm3B,GAAA16B,KAAA46B,QAAAtlB,EAAAolB,EAAAp6B,OAAAi8B,KAAA5B,KAAAhhB,EAAA,EAAyFA,EAAArE,IAAOqE,EAChG,OAAAic,GAAAc,EAAAgE,EAAA/gB,GAAAvZ,EAAAs2B,EAAAp2B,OAAAH,EAAA,EAA8DA,EAAAC,IAAOD,EACrE,GAAAy1B,EAAAc,EAAAv2B,GAAA,CACA,OAAAq9B,GAAAC,EAAAl6B,EAAApB,KAAAyzB,IAAAa,SAAAt2B,EAAAu2B,GAAAsE,EAAA35B,EAAAu0B,EAAA5xB,GAAAiM,EAAA,EAAAe,EAAAysB,EAAAn9B,OAAmI2P,EAAAe,IAAOf,GAC1IutB,EAAAC,EAAAxtB,KACA4lB,EAAA2H,EAAAx8B,EAAAgD,EAAAiM,EAAAwtB,EAAAzC,EAGAuB,GAAA36B,KAAA67B,GACA9C,EAAA/4B,KAAAg0B,GAKA,UAAA6E,GAAA8B,EAAA5B,EAAA35B,EAAAgD,IAGA05B,GAAA96B,EAAAU,UAAAzB,UAAAC,YAEA67B,GAAA,WACA,UAAAD,IAAA19B,KAAA46B,QAAA56B,KAAA66B,WA+CA+C,GAAA,SAAA58B,EAAAO,EAAA64B,GACA,GAAAj6B,GAAA,cAAAa,GAAA,IAAAw0B,EAAAqI,wBAAAjlB,EACA,cAAArX,EAAAvB,KACAm6B,WAAAn5B,EAAA84B,EAAA94B,EAAAb,IACA4B,GAAA,aAAAf,EAAAg5B,EAAAh5B,IACAhB,KAAAm6B,WAAAn5B,EAAA,kBAAAO,GACA24B,EAAAl5B,EAAAb,EAAAi3B,EAAAp3B,KAAA,SAAAgB,EAAAO,IACA04B,EAAAj5B,EAAAb,EAAAoB,EAAA,IAAA64B,IAcA0D,GAAA,SAAA98B,EAAAO,EAAA64B,GACA,GAAA7T,GAAA,UAAAvlB,GAAA,GACA,IAAAX,UAAAC,OAAA,SAAAimB,EAAAvmB,KAAA22B,MAAApQ,OAAAsS,MACA,UAAAt3B,EAAA,MAAAvB,MAAA22B,MAAApQ,EAAA,KACA,sBAAAhlB,GAAA,SAAAf,MACA,OAAAR,MAAA22B,MAAApQ,EAAA4T,EAAAn5B,EAAAO,EAAA,MAAA64B,EAAA,GAAAA,KAgBA2D,GAAA,SAAAx8B,GACA,MAAAvB,MAAA22B,MAAA,yBAAAp1B,GACAi5B,EAAApD,EAAAp3B,KAAA,OAAAuB,IACA+4B,EAAA,MAAA/4B,EAAA,GAAAA,EAAA,MAGAy8B,GAAA,WAKA,OAJAh9B,GAAAhB,KAAA86B,MACAmD,EAAAj+B,KAAAs3B,IACA4G,EAAAnD,IAEAL,EAAA16B,KAAA46B,QAAAtlB,EAAAolB,EAAAp6B,OAAAqZ,EAAA,EAA2DA,EAAArE,IAAOqE,EAClE,OAAAic,GAAAc,EAAAgE,EAAA/gB,GAAAvZ,EAAAs2B,EAAAp2B,OAAAH,EAAA,EAA8DA,EAAAC,IAAOD,EACrE,GAAAy1B,EAAAc,EAAAv2B,GAAA,CACA,GAAA66B,GAAA35B,EAAAu0B,EAAAqI,EACApI,GAAAD,EAAA50B,EAAAk9B,EAAA/9B,EAAAu2B,GACAhD,KAAAsH,EAAAtH,KAAAsH,EAAAvH,MAAAuH,EAAApE,SACAnD,MAAA,EACAmD,SAAAoE,EAAApE,SACAC,KAAAmE,EAAAnE,OAMA,UAAA4D,GAAAC,EAAA16B,KAAA66B,SAAA75B,EAAAk9B,IAGAl6B,GAAA,EAiBAm6B,GAAAv7B,EAAAU,UAAAzB,SAEA44B,GAAA54B,UAAAw1B,EAAAx1B,WACAC,YAAA24B,EACAl3B,OAAA45B,GACAiB,UAAAd,GACAl4B,OAAAg3B,GACAphB,MAAAyhB,GACAn5B,UAAAq6B,GACAtG,WAAA2G,GACA77B,KAAAg8B,GAAAh8B,KACAk8B,MAAAF,GAAAE,MACAzI,KAAAuI,GAAAvI,KACA5O,KAAAmX,GAAAnX,KACAsU,MAAA6C,GAAA7C,MACA/D,KAAA4G,GAAA5G,KACAx1B,GAAAk7B,GACAqB,KAAAzC,GACA/C,UAAAkD,GACAt4B,MAAAk6B,GACAzD,WAAA2D,GACAS,KAAAR,GACAS,OAAAtB,GACAvG,MAAA6E,EACA/H,MAAAwI,GACArF,SAAAsF,GACArF,KAAAsF,GAGA,IAAAjB,KACAxH,KAAA,KACAD,MAAA,EACAmD,SAAA,IACAC,KAAAnB,EAAApqB,gBAaAmzB,GAAA,SAAAz9B,GACA,GAAAgD,GACAi3B,CAEAj6B,aAAAy5B,IACAz2B,EAAAhD,EAAAs2B,IAAAt2B,IAAA85B,QAEA92B,EAAA+2B,KAAAE,EAAAC,IAAAxH,KAAA6B,EAAAzC,MAAA9xB,EAAA,MAAAA,EAAA,KAAAA,EAAA,GAGA,QAAA05B,GAAA16B,KAAA46B,QAAAtlB,EAAAolB,EAAAp6B,OAAAqZ,EAAA,EAA2DA,EAAArE,IAAOqE,EAClE,OAAAic,GAAAc,EAAAgE,EAAA/gB,GAAAvZ,EAAAs2B,EAAAp2B,OAAAH,EAAA,EAA8DA,EAAAC,IAAOD,GACrEy1B,EAAAc,EAAAv2B,KACA01B,EAAAD,EAAA50B,EAAAgD,EAAA7D,EAAAu2B,EAAAuE,GAAAD,EAAApF,EAAA5xB,GAKA,WAAAy2B,GAAAC,EAAA16B,KAAA66B,SAAA75B,EAAAgD,GAGApB,GAAAU,UAAAzB,UAAAw5B,UAAAE,EACA34B,EAAAU,UAAAzB,UAAAw1B,WAAAoH,EAEA,IAAAt7B,KAAA,MAEAc,GAAA,SAAA2xB,EAAA50B,GACA,GACA60B,GACA11B,EAFAk2B,EAAAT,EAAAK,YAIA,IAAAI,EAAA,CACAr1B,EAAA,MAAAA,EAAA,KAAAA,EAAA,EACA,KAAAb,IAAAk2B,GACA,IAAAR,EAAAQ,EAAAl2B,IAAA21B,MAAAM,GAAAP,EAAA70B,SACA,UAAAy5B,KAAA7E,IAAAzyB,GAAAnC,GAAAb,GAKA,YAGAP,GAAAy3B,aACAz3B,EAAAqE,UACArE,EAAAy7B,YAEA74B,OAAAC,eAAA7C,EAAA,cAA8C2B,OAAA,ON0xHxCm9B,IACA,SAAU/+B,EAAQC,EAASC,IO1iJjC,SAAAC,EAAAC,GACAA,EAAAH,EAAAC,EAAA,IAAAA,EAAA,KAAAA,EAAA,KAAAA,EAAA,IAAAA,EAAA,OAGCG,KAAA,SAAAJ,EAAA+C,EAAAg8B,EAAAnJ,EAAA5yB,EAAAg8B,GAAqF,YAQtF,SAAAC,GAAA/6B,EAAA1C,EAAA+kB,GACAnmB,KAAA8D,SACA9D,KAAAoB,OACApB,KAAAmmB,YAGA,QAAA2Y,GAAA7uB,EAAA/L,EAAAC,GACAnE,KAAAiQ,IACAjQ,KAAAkE,IACAlE,KAAAmE,IA4CA,QAAAgiB,GAAAyP,GACA,MAAAA,GAAAmJ,QAAAvc,EAGA,QAAA3f,KACAD,EAAAE,MAAAC,2BASA,QAAAyB,KACA,OAAA5B,EAAAE,MAAA2B,OAGA,QAAAu6B,KACA,GAAAzqB,GAAAuS,EAAAjd,EAAA7J,IASA,OARA6J,aAAAo1B,aACAp1B,IAAAq1B,iBAAAr1B,EACA0K,EAAA1K,EAAAqd,MAAAiY,QAAA59B,MACAulB,EAAAjd,EAAAud,OAAA+X,QAAA59B,QAEAgT,EAAA1K,EAAAu1B,YACAtY,EAAAjd,EAAAw1B,gBAEA,MAAA9qB,EAAAuS,IAGA,QAAAwY,KACA,MAAAt/B,MAAA++B,QAAAvc,EAGA,QAAA+c,KACA,OAAA38B,EAAAE,MAAA08B,QAAA58B,EAAAE,MAAA28B,UAAA,WAGA,QAAA36B,KACA,sBAAA9E,MAGA,QAAA0/B,GAAA9W,EAAAvJ,EAAAsgB,GACA,GAAAC,GAAAhX,EAAAiX,QAAAxgB,EAAA,OAAAsgB,EAAA,MACAG,EAAAlX,EAAAiX,QAAAxgB,EAAA,OAAAsgB,EAAA,MACAI,EAAAnX,EAAAoX,QAAA3gB,EAAA,OAAAsgB,EAAA,MACAM,EAAArX,EAAAoX,QAAA3gB,EAAA,OAAAsgB,EAAA,KACA,OAAA/W,GAAAhC,UACAkZ,EAAAF,KAAAE,GAAA,EAAA34B,KAAAgY,IAAA,EAAAygB,IAAAz4B,KAAAwD,IAAA,EAAAm1B,GACAG,EAAAF,KAAAE,GAAA,EAAA94B,KAAAgY,IAAA,EAAA4gB,IAAA54B,KAAAwD,IAAA,EAAAs1B,IA7GA,GAAAh7B,GAAA,SAAAf,GACA,kBACA,MAAAA,IAgBA46B,GAAAj9B,WACAC,YAAAg9B,EACAnY,MAAA,SAAA1W,GACA,WAAAA,EAAAjQ,KAAA,GAAA8+B,GAAA9+B,KAAAiQ,IAAAjQ,KAAAkE,EAAAlE,KAAAmE,IAEAyiB,UAAA,SAAA1iB,EAAAC,GACA,WAAAD,EAAA,IAAAC,EAAAnE,KAAA,GAAA8+B,GAAA9+B,KAAAiQ,EAAAjQ,KAAAkE,EAAAlE,KAAAiQ,EAAA/L,EAAAlE,KAAAmE,EAAAnE,KAAAiQ,EAAA9L,IAEA5B,MAAA,SAAAoE,GACA,OAAAA,EAAA,GAAA3G,KAAAiQ,EAAAjQ,KAAAkE,EAAAyC,EAAA,GAAA3G,KAAAiQ,EAAAjQ,KAAAmE,IAEA+7B,OAAA,SAAAh8B,GACA,MAAAA,GAAAlE,KAAAiQ,EAAAjQ,KAAAkE,GAEAi8B,OAAA,SAAAh8B,GACA,MAAAA,GAAAnE,KAAAiQ,EAAAjQ,KAAAmE,GAEA0R,OAAA,SAAAuqB,GACA,QAAAA,EAAA,GAAApgC,KAAAkE,GAAAlE,KAAAiQ,GAAAmwB,EAAA,GAAApgC,KAAAmE,GAAAnE,KAAAiQ,IAEA4vB,QAAA,SAAA37B,GACA,OAAAA,EAAAlE,KAAAkE,GAAAlE,KAAAiQ,GAEA+vB,QAAA,SAAA77B,GACA,OAAAA,EAAAnE,KAAAmE,GAAAnE,KAAAiQ,GAEAowB,SAAA,SAAAn8B,GACA,MAAAA,GAAAhC,OAAAo+B,OAAAp8B,EAAA+c,QAAAlgB,IAAAf,KAAA6/B,QAAA7/B,MAAAe,IAAAmD,EAAA2R,OAAA3R,KAEAq8B,SAAA,SAAAp8B,GACA,MAAAA,GAAAjC,OAAAo+B,OAAAn8B,EAAA8c,QAAAlgB,IAAAf,KAAAggC,QAAAhgC,MAAAe,IAAAoD,EAAA0R,OAAA1R,KAEAq8B,SAAA,WACA,mBAAAxgC,KAAAkE,EAAA,IAAAlE,KAAAmE,EAAA,WAAAnE,KAAAiQ,EAAA,KAIA,IAAAuS,GAAA,GAAAsc,GAAA,MAEA3Y,GAAAtkB,UAAAi9B,EAAAj9B,SAUA,IAAA2B,GAAA,WACAZ,EAAAE,MAAAiC,iBACAnC,EAAAE,MAAAC,4BA4CA09B,EAAA,WAkBA,QAAAA,GAAAn9B,GACAA,EACAo9B,SAAA,SAAApB,GACAv9B,GAAA,aAAA4+B,GACA5+B,GAAA,iBAAAoD,GACApD,GAAA,gBAAA6+B,GACAx7B,OAAAC,GACAtD,GAAA,kBAAAuD,GACAvD,GAAA,iBAAAwD,GACAxD,GAAA,iCAAAyD,GACA9B,MAAA,uBACAA,MAAA,+CA0DA,QAAAijB,GAAAiC,EAAA3Y,GAEA,MADAA,GAAA9I,KAAAwD,IAAAk2B,EAAA,GAAA15B,KAAAgY,IAAA0hB,EAAA,GAAA5wB,IACAA,IAAA2Y,EAAA3Y,EAAA2Y,EAAA,GAAAkW,GAAA7uB,EAAA2Y,EAAA1kB,EAAA0kB,EAAAzkB,GAGA,QAAAyiB,GAAAgC,EAAA3hB,EAAA+R,GACA,GAAA9U,GAAA+C,EAAA,GAAA+R,EAAA,GAAA4P,EAAA3Y,EAAA9L,EAAA8C,EAAA,GAAA+R,EAAA,GAAA4P,EAAA3Y,CACA,OAAA/L,KAAA0kB,EAAA1kB,GAAAC,IAAAykB,EAAAzkB,EAAAykB,EAAA,GAAAkW,GAAAlW,EAAA3Y,EAAA/L,EAAAC,GAGA,QAAAuR,GAAA2J,GACA,SAAAA,EAAA,QAAAA,EAAA,WAAAA,EAAA,QAAAA,EAAA,UAGA,QAAAwW,GAAAwB,EAAAzO,EAAApR,GACA6f,EACAt1B,GAAA,wBAAsC2D,EAAA1F,KAAAK,WAAA6Y,UACtCnX,GAAA,qCAAmD2D,EAAA1F,KAAAK,WAAAygC,QACnDnK,MAAA,kBACA,GAAAv0B,GAAApC,KACAqC,EAAAhC,UACAusB,EAAAlnB,EAAAtD,EAAAC,GACAwH,EAAAwV,EAAA9c,MAAAH,EAAAC,GACAwE,EAAA2Q,GAAA9B,EAAA7L,GACA0K,EAAApN,KAAAwD,IAAAd,EAAA,MAAAA,EAAA,MAAAA,EAAA,MAAAA,EAAA,OACAY,EAAArI,EAAA28B,OACAtxB,EAAA,kBAAAmb,KAAArmB,MAAAH,EAAAC,GAAAumB,EACAzoB,EAAAyY,EAAAnO,EAAAoL,OAAAhP,GAAAlF,OAAA4S,EAAA9J,EAAAwF,GAAAxC,EAAAoI,OAAAhP,GAAAlF,OAAA4S,EAAA9G,EAAAwC,GACA,iBAAA/P,GACA,OAAAA,IAAAuN,MACA,CAAkB,GAAAuD,GAAA7Q,EAAAD,GAAA+P,EAAAsE,EAAAvD,EAAA,EAA4B9Q,GAAA,GAAA4+B,GAAA7uB,EAAApJ,EAAA,GAAAmK,EAAA,GAAAf,EAAApJ,EAAA,GAAAmK,EAAA,GAAAf,GAC9C2c,EAAA6T,KAAA,KAAAvgC,MAKA,QAAAwF,GAAAtD,EAAAC,GACA,OAAAuqB,GAAAzsB,EAAA,EAAAC,EAAAkG,EAAAhG,OAA2CH,EAAAC,IAAOD,EAClD,IAAAysB,EAAAtmB,EAAAnG,IAAAiC,SACA,MAAAwqB,EAGA,WAAAmU,GAAA3+B,EAAAC,GAGA,QAAA0+B,GAAA3+B,EAAAC,GACArC,KAAAoC,OACApC,KAAAqC,OACArC,KAAA2lB,OAAA,EACA3lB,KAAAiE,OAAA,EACAjE,KAAAqf,SAAA9c,MAAAH,EAAAC,GAgCA,QAAAs+B,KA8BA,QAAAK,KACApU,EAAAqU,MAAA,KACArU,EAAAkU,MA/BA,GAAA17B,EAAA7C,MAAAvC,KAAAK,WAAA,CACA,GAAAusB,GAAAlnB,EAAA1F,KAAAK,WACAH,EAAAF,KAAA++B,OACA9uB,EAAA9I,KAAAwD,IAAAk2B,EAAA,GAAA15B,KAAAgY,IAAA0hB,EAAA,GAAA3gC,EAAA+P,EAAA9I,KAAAoB,IAAA,EAAA24B,EAAA3+B,MAAAvC,KAAAK,cACAwG,EAAAjE,EAAAiD,MAAA7F,KAIA,IAAA4sB,EAAAqU,MACArU,EAAA/mB,MAAA,QAAAgB,EAAA,IAAA+lB,EAAA/mB,MAAA,QAAAgB,EAAA,KACA+lB,EAAA/mB,MAAA,GAAA3F,EAAA2V,OAAA+W,EAAA/mB,MAAA,GAAAgB,IAEAH,aAAAkmB,EAAAqU,WAIA,IAAA/gC,EAAA+P,MAAA,MAIA2c,GAAA/mB,OAAAgB,EAAA3G,EAAA2V,OAAAhP,IACA+3B,EAAAvD,UAAAr7B,MACA4sB,EAAA1T,QAGA1V,IACAopB,EAAAqU,MAAAx9B,WAAAu9B,EAAAG,GACAvU,EAAA6T,KAAA,QAAAW,EAAAxa,EAAAD,EAAAzmB,EAAA+P,GAAA2c,EAAA/mB,MAAA,GAAA+mB,EAAA/mB,MAAA,IAAA+mB,EAAAvN,OAAAsgB,KAQA,QAAAx6B,KAcA,QAAAW,KAEA,GADAtC,KACAopB,EAAAyU,MAAA,CACA,GAAAj9B,GAAAxB,EAAAE,MAAAoD,QAAAiO,EAAA9P,EAAAzB,EAAAE,MAAAsD,QAAAgO,CACAwY,GAAAyU,MAAAj9B,IAAAC,IAAAgC,EAEAumB,EAAA6T,KAAA,QAAAW,EAAAxa,EAAAgG,EAAAxqB,KAAA28B,OAAAnS,EAAA/mB,MAAA,GAAAjD,EAAAiD,MAAA+mB,EAAAxqB,MAAAwqB,EAAA/mB,MAAA,IAAA+mB,EAAAvN,OAAAsgB,IAGA,QAAA55B,KACAoK,EAAApO,GAAA,oCACA48B,EAAAr3B,WAAA1E,EAAAE,MAAAG,KAAA2pB,EAAAyU,OACA79B,IACAopB,EAAAkU,MA1BA,IAAAr7B,GAAAL,EAAA7C,MAAAvC,KAAAK,WAAA,CACA,GAAAusB,GAAAlnB,EAAA1F,KAAAK,WACA8P,EAAAvN,EAAAW,OAAAX,EAAAE,MAAAG,MAAAlB,GAAA,iBAAA+D,GAAA,GAAA/D,GAAA,eAAAgE,GAAA,GACAc,EAAAjE,EAAAiD,MAAA7F,MACAmU,EAAAvR,EAAAE,MAAAoD,QACAkO,EAAAxR,EAAAE,MAAAsD,OAEAu4B,GAAAt3B,YAAAzE,EAAAE,MAAAG,MACAJ,IACA+pB,EAAA/mB,OAAAgB,EAAA7G,KAAA++B,OAAAlpB,OAAAhP,IACA+3B,EAAAvD,UAAAr7B,MACA4sB,EAAA1T,SAmBA,QAAA0nB,KACA,GAAAx7B,EAAA7C,MAAAvC,KAAAK,WAAA,CACA,GAAA2W,GAAAhX,KAAA++B,OACA93B,EAAArE,EAAAiD,MAAA7F,MACAgZ,EAAAhC,EAAAnB,OAAA5O,GACAq6B,EAAAtqB,EAAA/G,GAAArN,EAAAE,MAAAy+B,SAAA,MACAtqB,EAAAmqB,EAAAxa,EAAAD,EAAA3P,EAAAsqB,GAAAr6B,EAAA+R,GAAAqG,EAAA9c,MAAAvC,KAAAK,WAAAs/B,EAEAn8B,KACAozB,EAAA,EAAAh0B,EAAAW,OAAAvD,MAAAq3B,aAAAT,YAAAz0B,KAAA0zB,EAAA5e,EAAAhQ,GACArE,EAAAW,OAAAvD,MAAAmC,KAAAs+B,EAAAta,UAAAlP,IAGA,QAAA3R,KACA,GAAAF,EAAA7C,MAAAvC,KAAAK,WAAA,CACA,GAEAmhC,GACArhC,EAAAD,EAAA2G,EAHA+lB,EAAAlnB,EAAA1F,KAAAK,WACAkG,EAAA3D,EAAAE,MAAA0D,eAEApG,EAAAmG,EAAAjG,MAGA,KADAuC,IACA1C,EAAA,EAAeA,EAAAC,IAAOD,EACtBD,EAAAqG,EAAApG,GAAA0G,EAAAjE,EAAA6D,MAAAzG,KAAAuG,EAAArG,EAAAqE,YACAsC,KAAA7G,KAAA++B,OAAAlpB,OAAAhP,GAAA3G,EAAAqE,YACAqoB,EAAA6U,OACA7U,EAAA8U,SAAA9U,EAAA8U,OAAA76B,IADA+lB,EAAA6U,OAAA56B,EAAA26B,GAAA,EAKA,OAAAG,KACAA,EAAAj7B,aAAAi7B,IACA/U,EAAA8U,SACA9U,EAAAkU,MACAj6B,EAAAjE,EAAAW,OAAAvD,MAAA+B,GAAA,sBACA8E,KAAAtE,MAAAvC,KAAAK,kBAKAmhC,IACAG,EAAAl+B,WAAA,WAA6Ck+B,EAAA,MAAwBC,GACrEhD,EAAAvD,UAAAr7B,MACA4sB,EAAA1T,WAIA,QAAA3T,KACA,GAEApF,GAAAD,EAAA2G,EAAAmK,EAFA4b,EAAAlnB,EAAA1F,KAAAK,WACAkG,EAAA3D,EAAAE,MAAA0D,eACApG,EAAAmG,EAAAjG,MAIA,KAFAkD,IACAm+B,MAAAj7B,aAAAi7B,IACAxhC,EAAA,EAAeA,EAAAC,IAAOD,EACtBD,EAAAqG,EAAApG,GAAA0G,EAAAjE,EAAA6D,MAAAzG,KAAAuG,EAAArG,EAAAqE,YACAqoB,EAAA6U,QAAA7U,EAAA6U,OAAA,KAAAvhC,EAAAqE,WAAAqoB,EAAA6U,OAAA,GAAA56B,EACA+lB,EAAA8U,QAAA9U,EAAA8U,OAAA,KAAAxhC,EAAAqE,aAAAqoB,EAAA8U,OAAA,GAAA76B,EAGA,IADA3G,EAAA0sB,EAAAxqB,KAAA28B,OACAnS,EAAA8U,OAAA,CACA,GAAAz6B,GAAA2lB,EAAA6U,OAAA,GAAAI,EAAAjV,EAAA6U,OAAA,GACAzoB,EAAA4T,EAAA8U,OAAA,GAAAI,EAAAlV,EAAA8U,OAAA,GACAK,KAAA/oB,EAAA,GAAA/R,EAAA,IAAA86B,KAAA/oB,EAAA,GAAA/R,EAAA,IAAA86B,EACAC,KAAAF,EAAA,GAAAD,EAAA,IAAAG,KAAAF,EAAA,GAAAD,EAAA,IAAAG,CACA9hC,GAAAymB,EAAAzmB,EAAAiH,KAAAC,KAAA26B,EAAAC,IACAn7B,IAAAI,EAAA,GAAA+R,EAAA,OAAA/R,EAAA,GAAA+R,EAAA,OACAhI,IAAA6wB,EAAA,GAAAC,EAAA,OAAAD,EAAA,GAAAC,EAAA,WAEA,KAAAlV,EAAA6U,OACA,MADA56B,GAAA+lB,EAAA6U,OAAA,GAAAzwB,EAAA4b,EAAA6U,OAAA,GAEA7U,EAAA6T,KAAA,QAAAW,EAAAxa,EAAA1mB,EAAA2G,EAAAmK,GAAA4b,EAAAvN,OAAAsgB,IAGA,QAAAn6B,KACA,GAEArF,GAAAD,EAFA0sB,EAAAlnB,EAAA1F,KAAAK,WACAkG,EAAA3D,EAAAE,MAAA0D,eACApG,EAAAmG,EAAAjG,MAKA,KAHAuC,IACA4C,GAAAiB,aAAAjB,GACAA,EAAAhC,WAAA,WAAyCgC,EAAA,MAAsBm8B,GAC/DzhC,EAAA,EAAeA,EAAAC,IAAOD,EACtBD,EAAAqG,EAAApG,GACAysB,EAAA6U,QAAA7U,EAAA6U,OAAA,KAAAvhC,EAAAqE,iBAAAqoB,GAAA6U,OACA7U,EAAA8U,QAAA9U,EAAA8U,OAAA,KAAAxhC,EAAAqE,kBAAAqoB,GAAA8U,MAEA9U,GAAA8U,SAAA9U,EAAA6U,SAAA7U,EAAA6U,OAAA7U,EAAA8U,aAAA9U,GAAA8U,QACA9U,EAAA6U,OAAA7U,EAAA6U,OAAA,GAAAzhC,KAAA++B,OAAAlpB,OAAA+W,EAAA6U,OAAA,IACA7U,EAAAkU,MAnUA,GAWAa,GACAl8B,EAZAL,EAAAZ,EACA6a,EAAA2f,EACAoC,EAAA1B,EACAwB,EAAA3B,EACAl6B,EAAAP,EACA+7B,GAAA,EAAAvtB,KACAqsB,MAAArsB,wBACAsjB,EAAA,IACAhe,EAAA4c,EAAAyM,gBACA37B,KACAS,EAAApE,EAAA1C,SAAA,sBAGA2hC,EAAA,IACAT,EAAA,IACA96B,EAAA,CAoWA,OApVAo6B,GAAAta,UAAA,SAAA+b,EAAAtZ,GACA,GAAAtlB,GAAA4+B,EAAA5+B,UAAA4+B,EAAA5+B,YAAA4+B,CACA5+B,GAAAo9B,SAAA,SAAApB,GACA4C,IAAA5+B,EACAuyB,EAAAqM,EAAAtZ,GAEAtlB,EAAA+3B,YAAA9D,KAAA,WACA7xB,EAAA1F,KAAAK,WACA6Y,QACAunB,KAAA,uBAAA7X,KAAArmB,MAAAvC,KAAAK,WAAAuoB,GACAkY,SAKAL,EAAA0B,QAAA,SAAA7+B,EAAA2M,GACAwwB,EAAA2B,QAAA9+B,EAAA,WACA,GAAA++B,GAAAriC,KAAA++B,OAAA9uB,EACAqxB,EAAA,kBAAArxB,KAAA1N,MAAAvC,KAAAK,WAAA4P,CACA,OAAAoyB,GAAAf,KAIAb,EAAA2B,QAAA,SAAA9+B,EAAA2M,GACAwwB,EAAAta,UAAA7iB,EAAA,WACA,GAAAuG,GAAAwV,EAAA9c,MAAAvC,KAAAK,WACA2W,EAAAhX,KAAA++B,OACA93B,EAAAyO,EAAA7L,GACAmP,EAAAhC,EAAAnB,OAAA5O,GACAq6B,EAAA,kBAAArxB,KAAA1N,MAAAvC,KAAAK,WAAA4P,CACA,OAAAmxB,GAAAxa,EAAAD,EAAA3P,EAAAsqB,GAAAr6B,EAAA+R,GAAAnP,EAAA81B,MAIAc,EAAA6B,YAAA,SAAAh/B,EAAAY,EAAAC,GACAs8B,EAAAta,UAAA7iB,EAAA,WACA,MAAA89B,GAAAphC,KAAA++B,OAAAnY,UACA,kBAAA1iB,KAAA3B,MAAAvC,KAAAK,WAAA6D,EACA,kBAAAC,KAAA5B,MAAAvC,KAAAK,WAAA8D,GACAkb,EAAA9c,MAAAvC,KAAAK,WAAAs/B,MAIAc,EAAA8B,YAAA,SAAAj/B,EAAAY,EAAAC,GACAs8B,EAAAta,UAAA7iB,EAAA,WACA,GAAAuG,GAAAwV,EAAA9c,MAAAvC,KAAAK,WACAH,EAAAF,KAAA++B,OACAl4B,EAAA6O,EAAA7L,EACA,OAAAu3B,GAAA5e,EAAAoE,UAAA/f,EAAA,GAAAA,EAAA,IAAA8f,MAAAzmB,EAAA+P,GAAA2W,UACA,kBAAA1iB,MAAA3B,MAAAvC,KAAAK,YAAA6D,EACA,kBAAAC,MAAA5B,MAAAvC,KAAAK,YAAA8D,GACA0F,EAAA81B,MAyDAoB,EAAAl/B,WACAqX,MAAA,WAKA,MAJA,OAAAlZ,KAAAiE,SACAjE,KAAA2lB,MAAArf,EAAA1E,KAAA5B,MAAA,EACAA,KAAAwiC,KAAA,UAEAxiC,MAEAygC,KAAA,SAAAla,EAAAqC,GAMA,MALA5oB,MAAA6F,OAAA,UAAA0gB,IAAAvmB,KAAA6F,MAAA,GAAA+iB,EAAA/S,OAAA7V,KAAA6F,MAAA,KACA7F,KAAAyhC,QAAA,UAAAlb,IAAAvmB,KAAAyhC,OAAA,GAAA7Y,EAAA/S,OAAA7V,KAAAyhC,OAAA,KACAzhC,KAAA0hC,QAAA,UAAAnb,IAAAvmB,KAAA0hC,OAAA,GAAA9Y,EAAA/S,OAAA7V,KAAA0hC,OAAA,KACA1hC,KAAAoC,KAAA28B,OAAAnW,EACA5oB,KAAAwiC,KAAA,QACAxiC,MAEA8gC,IAAA,WAMA,MALA,OAAA9gC,KAAAiE,SACAqC,EAAA4wB,OAAAl3B,KAAA2lB,MAAA,GACA3lB,KAAA2lB,OAAA,EACA3lB,KAAAwiC,KAAA,QAEAxiC,MAEAwiC,KAAA,SAAAphC,GACAwB,EAAAoE,YAAA,GAAA63B,GAAA4B,EAAAr/B,EAAApB,KAAAoC,KAAA28B,QAAAh4B,EAAAxE,MAAAwE,GAAA3F,EAAApB,KAAAoC,KAAApC,KAAAqC,SAkKAo+B,EAAAS,WAAA,SAAA3gC,GACA,MAAAF,WAAAC,QAAA4gC,EAAA,kBAAA3gC,KAAA0E,GAAA1E,GAAAkgC,GAAAS,GAGAT,EAAAr7B,OAAA,SAAA7E,GACA,MAAAF,WAAAC,QAAA8E,EAAA,kBAAA7E,KAAA0E,IAAA1E,GAAAkgC,GAAAr7B,GAGAq7B,EAAAp7B,UAAA,SAAA9E,GACA,MAAAF,WAAAC,QAAA+E,EAAA,kBAAA9E,KAAA0E,IAAA1E,GAAAkgC,GAAAp7B,GAGAo7B,EAAAphB,OAAA,SAAA9e,GACA,MAAAF,WAAAC,QAAA+e,EAAA,kBAAA9e,KAAA0E,KAAA1E,EAAA,OAAAA,EAAA,SAAAA,EAAA,OAAAA,EAAA,SAAAkgC,GAAAphB,GAGAohB,EAAAI,YAAA,SAAAtgC,GACA,MAAAF,WAAAC,QAAAugC,EAAA,IAAAtgC,EAAA,GAAAsgC,EAAA,IAAAtgC,EAAA,GAAAkgC,IAAAI,EAAA,GAAAA,EAAA,KAGAJ,EAAAd,gBAAA,SAAAp/B,GACA,MAAAF,WAAAC,QAAAq/B,EAAA,OAAAp/B,EAAA,MAAAo/B,EAAA,OAAAp/B,EAAA,MAAAo/B,EAAA,OAAAp/B,EAAA,MAAAo/B,EAAA,OAAAp/B,EAAA,MAAAkgC,KAAAd,EAAA,MAAAA,EAAA,QAAAA,EAAA,MAAAA,EAAA,SAGAc,EAAAW,UAAA,SAAA7gC,GACA,MAAAF,WAAAC,QAAA8gC,EAAA7gC,EAAAkgC,GAAAW,GAGAX,EAAA7J,SAAA,SAAAr2B,GACA,MAAAF,WAAAC,QAAAs2B,GAAAr2B,EAAAkgC,GAAA7J,GAGA6J,EAAA7nB,YAAA,SAAArY,GACA,MAAAF,WAAAC,QAAAsY,EAAArY,EAAAkgC,GAAA7nB,GAGA6nB,EAAA1+B,GAAA,WACA,GAAAR,GAAAwF,EAAAhF,GAAAQ,MAAAwE,EAAA1G,UACA,OAAAkB,KAAAwF,EAAA05B,EAAAl/B,GAGAk/B,EAAAv5B,cAAA,SAAA3G,GACA,MAAAF,WAAAC,QAAA+F,GAAA9F,QAAAkgC,GAAAt5B,KAAAC,KAAAf,IAGAo6B,EAGA7gC,GAAA6gC,OACA7gC,EAAA6iC,cAAAtc,EACAvmB,EAAA8iC,aAAAlgB,EAEAhgB,OAAAC,eAAA7C,EAAA,cAA8C2B,OAAA,OPojJxCohC,IACA,SAAUhjC,EAAQC,EAASC,IQviKjC,SAAAC,EAAAC,GACAA,EAAAH,IAGCI,KAAA,SAAAJ,GAA4B,YAyE7B,SAAAgjC,GAAAC,EAAAtqB,GACA,GAAAvU,GAAAuU,EAAAvU,GACA8+B,EAAAvqB,EAAAuqB,KACAC,EAAA,MAAAxqB,EAAAwqB,cAA4CxqB,EAAAwqB,WAC5Ch1B,EAAAa,EAAAi0B,EAAAtqB,EACA,cAAAvU,GAAA,MAAA8+B,GAAuC1hC,KAAA,UAAA2hC,aAAAh1B,YACvC,MAAA+0B,GAAwB1hC,KAAA,UAAA4C,KAAA++B,aAAAh1B,aACf3M,KAAA,UAAA4C,KAAA8+B,OAAAC,aAAAh1B,YAGT,QAAAa,GAAAi0B,EAAAtqB,GAIA,QAAAyB,GAAA7Z,EAAAiY,GACAA,EAAA9X,QAAA8X,EAAAL,KACA,QAAAtN,GAAAu4B,EAAA7iC,EAAA,GAAAA,KAAA8P,EAAA,EAAA7P,EAAAqK,EAAAnK,OAA2D2P,EAAA7P,IAAO6P,EAClEmI,EAAAxW,KAAAqhC,EAAAx4B,EAAAwF,MAEA9P,GAAA,GAAAuhB,EAAAtJ,EAAAhY,GAGA,QAAAuG,GAAAE,GACA,MAAAo8B,GAAAp8B,GAGA,QAAA+Q,GAAAorB,GAEA,OADA5qB,MACAjY,EAAA,EAAAC,EAAA4iC,EAAA1iC,OAAoCH,EAAAC,IAAOD,EAAA6Z,EAAAgpB,EAAA7iC,GAAAiY,EAE3C,OADAA,GAAA9X,OAAA,GAAA8X,EAAAxW,KAAAwW,EAAA;AACAA,EAGA,QAAAb,GAAAyrB,GAEA,IADA,GAAA5qB,GAAAR,EAAAorB,GACA5qB,EAAA9X,OAAA,GAAA8X,EAAAxW,KAAAwW,EAAA,GACA,OAAAA,GAGA,QAAAmB,GAAAypB,GACA,MAAAA,GAAAjiC,IAAAwW,GAGA,QAAAxJ,GAAAwK,GACA,GAAApK,GAAA/M,EAAAmX,EAAAnX,IACA,QAAAA,GACA,gCAAyCA,OAAA8tB,WAAA3W,EAAA2W,WAAAnuB,IAAAgN,GACzC,aAAAI,EAAAxH,EAAA4R,EAAApK,YAAuD,MACvD,kBAAAA,EAAAoK,EAAApK,YAAApN,IAAA4F,EAAgE,MAChE,kBAAAwH,EAAAyJ,EAAAW,EAAAyqB,KAAoD,MACpD,uBAAA70B,EAAAoK,EAAAyqB,KAAAjiC,IAAA6W,EAA6D,MAC7D,eAAAzJ,EAAAoL,EAAAhB,EAAAyqB,KAAoD,MACpD,oBAAA70B,EAAAoK,EAAAyqB,KAAAjiC,IAAAwY,EAA6D,MAC7D,qBAEA,OAAYnY,OAAA+M,eA5CZ,GAAA80B,GAAA9c,EAAA0c,EAAA1c,WACA6c,EAAAH,EAAAG,IA8CA,OAAAj1B,GAAAwK,GAiFA,QAAA2qB,GAAAL,EAAAM,EAAA/9B,GACA,GAAA49B,GAAA7iC,EAAAC,CACA,IAAAC,UAAAC,OAAA,EAAA0iC,EAAAI,EAAAP,EAAAM,EAAA/9B,OACA,KAAAjF,EAAA,EAAA6iC,EAAA,GAAA1gC,OAAAlC,EAAAyiC,EAAAG,KAAA1iC,QAA8DH,EAAAC,IAAOD,EAAA6iC,EAAA7iC,IACrE,QAAUiB,KAAA,kBAAA4hC,KAAAK,EAAAR,EAAAG,IAGV,QAAAI,GAAAP,EAAAM,EAAA/9B,GAKA,QAAAk+B,GAAAnjC,GACA,GAAAwZ,GAAAxZ,EAAA,GAAAA,KACAojC,EAAA5pB,KAAA4pB,EAAA5pB,QAAA/X,MAAkDzB,IAAAysB,EAAA4W,IAGlD,QAAAC,GAAAT,GACAA,EAAAlqB,QAAAwqB,GAGA,QAAAI,GAAAV,GACAA,EAAAlqB,QAAA2qB,GAGA,QAAAE,GAAAX,GACAA,EAAAlqB,QAAA4qB,GAGA,QAAA31B,GAAAwK,GACA,OAAAirB,EAAAjrB,IAAAnX,MACA,yBAAAmX,EAAA2W,WAAApW,QAAA/K,EAAgE,MAChE,kBAAA01B,EAAAlrB,EAAAyqB,KAA0C,MAC1C,qCAAAU,EAAAnrB,EAAAyqB,KAA+D,MAC/D,oBAAAW,EAAAprB,EAAAyqB,OA1BA,GAEAQ,GAFAR,KACAO,IAmCA,OANAx1B,GAAAo1B,GAEAI,EAAAzqB,QAAA,MAAA1T,EACA,SAAAw+B,GAAyBZ,EAAAphC,KAAAgiC,EAAA,GAAAzjC,IACzB,SAAAyjC,GAAyBx+B,EAAAw+B,EAAA,GAAAhX,EAAAgX,IAAAtjC,OAAA,GAAAssB,IAAAoW,EAAAphC,KAAAgiC,EAAA,GAAAzjC,KAEzB6iC,EAGA,QAAAa,GAAAtsB,GAEA,IADA,GAAA9M,GAAAtK,GAAA,EAAAC,EAAAmX,EAAAjX,OAAAmN,EAAA8J,EAAAnX,EAAA,GAAAkQ,EAAA,IACAnQ,EAAAC,GAAAqK,EAAAgD,IAAA8J,EAAApX,GAAAmQ,GAAA7F,EAAA,GAAAgD,EAAA,GAAAhD,EAAA,GAAAgD,EAAA,EACA,OAAAtG,MAAAgL,IAAA7B,GAOA,QAAAwzB,GAAAjB,EAAAkB,GAOA,QAAAh2B,GAAAwK,GACA,OAAAA,EAAAnX,MACA,yBAAAmX,EAAA2W,WAAApW,QAAA/K,EAAgE,MAChE,eAAAi2B,EAAAzrB,EAAAyqB,KAAsC,MACtC,oBAAAzqB,EAAAyqB,KAAAlqB,QAAAkrB,IAIA,QAAAA,GAAAzqB,GACAA,EAAAT,QAAA,SAAAvB,GACAA,EAAAuB,QAAA,SAAAkB,IACAiqB,EAAAjqB,IAAA,GAAAA,OAAAiqB,EAAAjqB,QAAApY,KAAA2X,OAGA2qB,EAAAtiC,KAAA2X,GAGA,QAAAjJ,GAAAiH,GACA,MAAAssB,GAAAj1B,EAAAi0B,GAA4CzhC,KAAA,UAAA4hC,MAAAzrB,KAA8BpJ,YAAA,IAxB1E,GAAA81B,MACAC,KACAxJ,IAmDA,OAjDAqJ,GAAAjrB,QAAA/K,GAuBAm2B,EAAAprB,QAAA,SAAAS,GACA,IAAAA,EAAAhZ,EAAA,CACA,GAAAm2B,MACAyN,GAAA5qB,EAGA,KAFAA,EAAAhZ,EAAA,EACAm6B,EAAA94B,KAAA80B,GACAnd,EAAA4qB,EAAApsB,OACA2e,EAAA90B,KAAA2X,GACAA,EAAAT,QAAA,SAAAvB,GACAA,EAAAuB,QAAA,SAAAkB,GACAiqB,EAAAjqB,EAAA,GAAAA,KAAAlB,QAAA,SAAAS,GACAA,EAAAhZ,IACAgZ,EAAAhZ,EAAA,EACA4jC,EAAAviC,KAAA2X,aASA2qB,EAAAprB,QAAA,SAAAS,SACAA,GAAAhZ,KAIAa,KAAA,eACA4hC,KAAAtI,EAAA35B,IAAA,SAAAmjC,GACA,GAAA9jC,GAAA4iC,IAmBA,IAhBAkB,EAAAprB,QAAA,SAAAS,GACAA,EAAAT,QAAA,SAAAvB,GACAA,EAAAuB,QAAA,SAAAkB,GACAiqB,EAAAjqB,EAAA,GAAAA,KAAA1Z,OAAA,GACA0iC,EAAAphC,KAAAoY,SAOAgpB,EAAAK,EAAAR,EAAAG,IAKA5iC,EAAA4iC,EAAA1iC,QAAA,EACA,OAAA8jC,GAAAlkC,EAAAC,EAAA,EAAA8P,EAAAK,EAAA0yB,EAAA,IAAiD7iC,EAAAC,IAAOD,GACxDikC,EAAA9zB,EAAA0yB,EAAA7iC,KAAA8P,IACA/P,EAAA8iC,EAAA,GAAAA,EAAA,GAAAA,EAAA7iC,GAAA6iC,EAAA7iC,GAAAD,EAAA+P,EAAAm0B,EAKA,OAAApB,MA/VA,GAAAxgB,GAAA,SAAAte,GACA,MAAAA,IAGAiiB,EAAA,SAAAA,GACA,SAAAA,EAAA,MAAA3D,EACA,IAAArO,GACAC,EACA8Y,EAAA/G,EAAAQ,MAAA,GACAwG,EAAAhH,EAAAQ,MAAA,GACAviB,EAAA+hB,EAAAS,UAAA,GACAviB,EAAA8hB,EAAAS,UAAA,EACA,iBAAAyd,EAAAlkC,GACAA,IAAAgU,EAAAC,EAAA,EACA,IAAAuF,GAAA,EAAAvZ,EAAAikC,EAAA/jC,OAAAgkC,EAAA,GAAAhiC,OAAAlC,EAGA,KAFAkkC,EAAA,IAAAnwB,GAAAkwB,EAAA,IAAAnX,EAAA9oB,EACAkgC,EAAA,IAAAlwB,GAAAiwB,EAAA,IAAAlX,EAAA9oB,EACAsV,EAAAvZ,GAAAkkC,EAAA3qB,GAAA0qB,EAAA1qB,MACA,OAAA2qB,KAIAxB,EAAA,SAAAD,GAIA,QAAA0B,GAAA19B,GACAA,EAAA3G,EAAA2G,GACAA,EAAA,GAAAsN,MAAAtN,EAAA,IACAA,EAAA,GAAA4W,MAAA5W,EAAA,IACAA,EAAA,GAAAuN,MAAAvN,EAAA,IACAA,EAAA,GAAA6W,MAAA7W,EAAA,IAGA,QAAA29B,GAAAjsB,GACA,OAAAA,EAAAnX,MACA,yBAAAmX,EAAA2W,WAAApW,QAAA0rB,EAAoE,MACpE,aAAAD,EAAAhsB,EAAApK,YAA6C,MAC7C,kBAAAoK,EAAApK,YAAA2K,QAAAyrB,IAfA,GAAAhe,GAAArmB,EAAAimB,EAAA0c,EAAA1c,WACAhS,EAAAb,IAAAc,EAAAD,EAAAsJ,GAAAtJ,EAAAuJ,GAAAvJ,CAkBA0uB,GAAAG,KAAAlqB,QAAA,SAAAkB,GAEA,IADA,GAAAnT,GAAA1G,GAAA,EAAAC,EAAA4Z,EAAA1Z,SACAH,EAAAC,GACAyG,EAAA3G,EAAA8Z,EAAA7Z,MACA0G,EAAA,GAAAsN,MAAAtN,EAAA,IACAA,EAAA,GAAA4W,MAAA5W,EAAA,IACAA,EAAA,GAAAuN,MAAAvN,EAAA,IACAA,EAAA,GAAA6W,MAAA7W,EAAA,KAIA,KAAA0f,IAAAsc,GAAAkB,QACAS,EAAA3B,EAAAkB,QAAAxd,GAGA,QAAApS,EAAAC,EAAAqJ,EAAAC,IAGAgE,EAAA,SAAArI,EAAAjZ,GAEA,IADA,GAAAF,GAAAyZ,EAAAN,EAAA/Y,OAAAH,EAAAwZ,EAAAvZ,EACAD,IAAAwZ,GAAAzZ,EAAAmZ,EAAAlZ,GAAAkZ,EAAAlZ,KAAAkZ,EAAAM,GAAAN,EAAAM,GAAAzZ,GAGAiT,EAAA,SAAA0vB,EAAAtqB,GACA,6BAAAA,EAAAnX,MACSA,KAAA,oBAAAqtB,SAAAlW,EAAA2W,WAAAnuB,IAAA,SAAAwX,GAAmE,MAAAqqB,GAAAC,EAAAtqB,MAC5EqqB,EAAAC,EAAAtqB,IAgEA8qB,EAAA,SAAAR,EAAAG,GAiDA,QAAAyB,GAAAtkC,GACA,GAAA6Y,GAAAgB,EAAA6oB,EAAAG,KAAA7iC,EAAA,GAAAA,KAAA8G,EAAA+S,EAAA,EAGA,OAFA6oB,GAAA1c,WAAAnN,GAAA,KAAAgB,EAAAlB,QAAA,SAAAipB,GAAmE/oB,EAAA,IAAA+oB,EAAA,GAAA/oB,EAAA,IAAA+oB,EAAA,MACnE/oB,EAAAgB,IAAA1Z,OAAA,GACAH,EAAA,GAAA6Y,EAAA/R,MAAA+R,GAGA,QAAA0rB,GAAAC,EAAAC,GACA,OAAA30B,KAAA00B,GAAA,CACA,GAAAtY,GAAAsY,EAAA10B,SACA20B,GAAAvY,EAAAnT,aACAmT,GAAAnT,YACAmT,GAAAyU,IACAzU,EAAAvT,QAAA,SAAA3Y,GAA6B0kC,EAAA1kC,EAAA,GAAAA,KAAA,IAC7B2kC,EAAAljC,KAAAyqB,IA9DA,GAAAwY,MACAD,KACAD,KACAG,KACAC,GAAA,CAkEA,OA/DA/B,GAAAlqB,QAAA,SAAA3Y,EAAAwZ,GACA,GAAAzZ,GAAA8Z,EAAA6oB,EAAAG,KAAA7iC,EAAA,GAAAA,IACA6Z,GAAA1Z,OAAA,IAAA0Z,EAAA,QAAAA,EAAA,QACA9Z,EAAA8iC,IAAA+B,GAAA/B,EAAA+B,GAAA5kC,EAAA6iC,EAAArpB,GAAAzZ,KAIA8iC,EAAAlqB,QAAA,SAAA3Y,GACA,GAGAksB,GAAAO,EAHA/iB,EAAA46B,EAAAtkC,GACA+Y,EAAArP,EAAA,GACAi3B,EAAAj3B,EAAA,EAGA,IAAAwiB,EAAAsY,EAAAzrB,GAIA,SAHAyrB,GAAAtY,EAAAyU,KACAzU,EAAAzqB,KAAAzB,GACAksB,EAAAyU,MACAlU,EAAAgY,EAAA9D,GAAA,OACA8D,GAAAhY,EAAA1T,MACA,IAAA8rB,GAAApY,IAAAP,MAAA1qB,OAAAirB,EACAgY,GAAAI,EAAA9rB,MAAAmT,EAAAnT,OAAAyrB,EAAAK,EAAAlE,IAAAlU,EAAAkU,KAAAkE,MAEAJ,GAAAvY,EAAAnT,OAAAyrB,EAAAtY,EAAAyU,KAAAzU,MAEK,IAAAA,EAAAuY,EAAA9D,GAIL,SAHA8D,GAAAvY,EAAAnT,OACAmT,EAAA4Y,QAAA9kC,GACAksB,EAAAnT,QACA0T,EAAA+X,EAAAzrB,GAAA,OACAyrB,GAAA/X,EAAAkU,IACA,IAAAoE,GAAAtY,IAAAP,IAAAO,EAAAjrB,OAAA0qB,EACAuY,GAAAM,EAAAhsB,MAAA0T,EAAA1T,OAAAyrB,EAAAO,EAAApE,IAAAzU,EAAAyU,KAAAoE,MAEAN,GAAAvY,EAAAnT,OAAAyrB,EAAAtY,EAAAyU,KAAAzU,MAGAA,IAAAlsB,GACAykC,EAAAvY,EAAAnT,SAAAyrB,EAAAtY,EAAAyU,OAAAzU,IAsBAqY,EAAAC,EAAAC,GACAF,EAAAE,EAAAD,GACA3B,EAAAlqB,QAAA,SAAA3Y,GAA4B0kC,EAAA1kC,EAAA,GAAAA,MAAA2kC,EAAAljC,MAAAzB,MAE5B2kC,GAGAK,EAAA,SAAAtC,GACA,MAAAj0B,GAAAi0B,EAAAK,EAAA3gC,MAAAvC,KAAAK,aAwDA2a,EAAA,SAAA6nB,GACA,MAAAj0B,GAAAi0B,EAAAiB,EAAAvhC,MAAAvC,KAAAK,aA4FA+kC,EAAA,SAAA36B,EAAAvG,GAEA,IADA,GAAAmhC,GAAA,EAAAC,EAAA76B,EAAAnK,OACA+kC,EAAAC,GAAA,CACA,GAAAC,GAAAF,EAAAC,IAAA,CACA76B,GAAA86B,GAAArhC,EAAAmhC,EAAAE,EAAA,EACAD,EAAAC,EAEA,MAAAF,IAGAlB,EAAA,SAAAJ,GAIA,QAAAnsB,GAAAorB,EAAA7iC,GACA6iC,EAAAlqB,QAAA,SAAArO,GACAA,EAAA,IAAAA,KACA,IAAA8N,GAAAitB,EAAA/6B,EACA8N,KAAA3W,KAAAzB,GACAqlC,EAAA/6B,IAAAtK,KAIA,QAAAoZ,GAAAypB,EAAA7iC,GACA6iC,EAAAlqB,QAAA,SAAAkB,GAAgCpC,EAAAoC,EAAA7Z,KAGhC,QAAA4N,GAAAwK,EAAApY,GACA,uBAAAoY,EAAAnX,KAAAmX,EAAA2W,WAAApW,QAAA,SAAAP,GAA2ExK,EAAAwK,EAAApY,KAC3EoY,EAAAnX,OAAAqkC,MAAAltB,EAAAnX,MAAAmX,EAAAyqB,KAAA7iC,GAlBA,GAAAqlC,MACArB,EAAAJ,EAAAhjC,IAAA,WAA0C,WAoB1C0kC,GACA5W,WAAAjX,EACAkX,gBAAAvV,EACAwV,QAAAxV,EACAyV,aAAA,SAAAgU,EAAA7iC,GAAqC6iC,EAAAlqB,QAAA,SAAAkB,GAA6BT,EAAAS,EAAA7Z,MAGlE4jC,GAAAjrB,QAAA/K,EAEA,QAAA5N,KAAAqlC,GACA,OAAAE,GAAAF,EAAArlC,GAAAmV,EAAAowB,EAAAplC,OAAAqZ,EAAA,EAAkEA,EAAArE,IAAOqE,EACzE,OAAA1J,GAAA0J,EAAA,EAAyB1J,EAAAqF,IAAOrF,EAAA,CAChC,GAAA7P,GAAAulC,EAAAD,EAAA/rB,GAAAisB,EAAAF,EAAAz1B,IACA7P,EAAA+jC,EAAAwB,IAAAxlC,EAAAilC,EAAAhlC,EAAAwlC,SAAAxlC,EAAA82B,OAAA/2B,EAAA,EAAAylC,IACAxlC,EAAA+jC,EAAAyB,IAAAzlC,EAAAilC,EAAAhlC,EAAAulC,SAAAvlC,EAAA82B,OAAA/2B,EAAA,EAAAwlC,GAKA,MAAAxB,IAGA0B,EAAA,SAAA1f,GACA,SAAAA,EAAA,MAAA3D,EACA,IAAArO,GACAC,EACA8Y,EAAA/G,EAAAQ,MAAA,GACAwG,EAAAhH,EAAAQ,MAAA,GACAviB,EAAA+hB,EAAAS,UAAA,GACAviB,EAAA8hB,EAAAS,UAAA,EACA,iBAAAyd,EAAAlkC,GACAA,IAAAgU,EAAAC,EAAA,EACA,IAAAuF,GAAA,EACAvZ,EAAAikC,EAAA/jC,OACAgkC,EAAA,GAAAhiC,OAAAlC,GACAqd,EAAAtW,KAAA2+B,OAAAzB,EAAA,GAAAjgC,GAAA8oB,GACAxP,EAAAvW,KAAA2+B,OAAAzB,EAAA,GAAAhgC,GAAA8oB,EAGA,KAFAmX,EAAA,GAAA7mB,EAAAtJ,IAAAsJ,EACA6mB,EAAA,GAAA5mB,EAAAtJ,IAAAsJ,EACA/D,EAAAvZ,GAAAkkC,EAAA3qB,GAAA0qB,EAAA1qB,MACA,OAAA2qB,KAIAyB,EAAA,SAAAlD,EAAA1c,GAcA,QAAA6f,GAAAr/B,GACA,MAAAzG,GAAAyG,GAGA,QAAAs/B,GAAA5B,GACA,GAAAC,EACA,QAAAD,EAAAjjC,MACA,yBAAAkjC,GAA2CljC,KAAA,qBAAA8tB,WAAAmV,EAAAnV,WAAAnuB,IAAAklC,GAAgF,MAC3H,aAAA3B,GAA8BljC,KAAA,QAAA+M,YAAA63B,EAAA3B,EAAAl2B,aAA8D,MAC5F,kBAAAm2B,GAAmCljC,KAAA,aAAA+M,YAAAk2B,EAAAl2B,YAAApN,IAAAilC,GAAuE,MAC1G,eAAA3B,GAKA,MAHA,OAAAA,EAAArgC,KAAAsgC,EAAAtgC,GAAAqgC,EAAArgC,IACA,MAAAqgC,EAAAvB,OAAAwB,EAAAxB,KAAAuB,EAAAvB,MACA,MAAAuB,EAAAtB,aAAAuB,EAAAvB,WAAAsB,EAAAtB,YACAuB,EAGA,QAAA4B,GAAA7B,GACA,GAAAx9B,GAAA1G,EAAA,EAAAwZ,EAAA,EAAAvZ,EAAAikC,EAAA/jC,OAAAgkC,EAAA,GAAAhiC,OAAAlC,EAEA,KADAkkC,EAAA,GAAApkC,EAAAmkC,EAAA,QACAlkC,EAAAC,KAAAyG,EAAA3G,EAAAmkC,EAAAlkC,OAAA,IAAA0G,EAAA,MAAAy9B,EAAA3qB,KAAA9S,EAGA,OAFA,KAAA8S,IAAA2qB,EAAA3qB,MAAA,MACA2qB,EAAAhkC,OAAAqZ,EACA2qB,EArCA,GAAAzB,EAAA1c,UAAA,SAAA3lB,OAAA,oBAEA,IAAA2lB,KAAAQ,MAMAwf,EAAAtD,EAAAC,SANA,CACA,MAAA1iC,EAAA+G,KAAAi/B,MAAAjgB,KAAA,YAAA3lB,OAAA,eACA2lC,GAAAtD,EAAAC,QAAAD,EACA,IAAAziC,GAAA+T,EAAAgyB,EAAA,GAAA/xB,EAAA+xB,EAAA,GAAA1oB,EAAA0oB,EAAA,GAAAzoB,EAAAyoB,EAAA,EACAhgB,IAAiBQ,OAAAlJ,EAAAtJ,GAAAsJ,EAAAtJ,IAAA/T,EAAA,KAAAsd,EAAAtJ,GAAAsJ,EAAAtJ,IAAAhU,EAAA,MAAAwmB,WAAAzS,EAAAC,IAKjB,GAAA+xB,GAAA5f,EAAArmB,EAAA2lC,EAAA1f,GAAAkgB,EAAAxD,EAAAkB,QAAAuC,IA6BA,KAAA/f,IAAA8f,GAAAC,EAAA/f,GAAA0f,EAAAI,EAAA9f,GAEA,QACAnlB,KAAA,WACA0hC,KAAAqD,EACAhgB,YACA4d,QAAAuC,EACAtD,KAAAH,EAAAG,KAAAjiC,IAAAmlC,IAIAtmC,GAAAkjC,OACAljC,EAAAuT,UACAvT,EAAAulC,OACAvlC,EAAAsjC,WACAtjC,EAAAob,QACApb,EAAAkkC,YACAlkC,EAAAukC,YACAvkC,EAAAmmC,WACAnmC,EAAAumB,YACAvmB,EAAAimC,cAEArjC,OAAAC,eAAA7C,EAAA,cAA8C2B,OAAA,ORijKxCglC,GACA,SAAU5mC,EAAQC,EAASC,GSxiLjC,GAAA2mC,GAAA3mC,EAAA,KACA4mC,EAAA5mC,EAAA,KAEA6mC,EAAAD,CACAC,GAAAF,KACAE,EAAAD,KAEA9mC,EAAAC,QAAA8mC,GT+iLMC,GACA,SAAUhnC,EAAQC,GU9iLxB,QAAAgnC,GAAAC,EAAAC,GACA,GAAA3mC,GAAA2mC,GAAA,EACAC,EAAAC,CACA,OAAAD,GAAAF,EAAA1mC,MAAA4mC,EAAAF,EAAA1mC,MACA4mC,EAAAF,EAAA1mC,MAAA4mC,EAAAF,EAAA1mC,MAAA,IACA4mC,EAAAF,EAAA1mC,MAAA4mC,EAAAF,EAAA1mC,MAAA,IACA4mC,EAAAF,EAAA1mC,MAAA4mC,EAAAF,EAAA1mC,MAAA,IACA4mC,EAAAF,EAAA1mC,MAAA4mC,EAAAF,EAAA1mC,MAAA,IACA4mC,EAAAF,EAAA1mC,MAAA4mC,EAAAF,EAAA1mC,MACA4mC,EAAAF,EAAA1mC,MAAA4mC,EAAAF,EAAA1mC,MACA4mC,EAAAF,EAAA1mC,MAAA4mC,EAAAF,EAAA1mC,MAdA,OADA6mC,MACA7mC,EAAA,EAAeA,EAAA,MAASA,EACxB6mC,EAAA7mC,MAAA,KAAAqgC,SAAA,IAAAyG,OAAA,EAgBAtnC,GAAAC,QAAAgnC,GV8jLMM,GACA,SAAUvnC,EAAQC,GW/kLxB,GAAAunC,GAAA,4BAAAC,OAAAD,gBAAArS,KAAAsS,SACA,8BAAAC,SAAAF,gBAAArS,KAAAuS,SACA,IAAAF,EAAA,CAEA,GAAAG,GAAA,GAAAC,YAAA,GAEA5nC,GAAAC,QAAA,WAEA,MADAunC,GAAAG,GACAA,OAEC,CAKD,GAAAE,GAAA,GAAAllC,OAAA,GAEA3C,GAAAC,QAAA,WACA,OAAA6X,GAAAtX,EAAA,EAAsBA,EAAA,GAAQA,IAC9B,OAAAA,KAAAsX,EAAA,WAAAtQ,KAAAsgC,UACAD,EAAArnC,GAAAsX,MAAA,EAAAtX,IAAA,MAGA,OAAAqnC,MX8lLME,IACA,SAAU/nC,EAAQC,EAASC,GY5mLjC,QAAA2mC,GAAAmB,EAAAd,EAAAC,GACA,GAAA3mC,GAAA0mC,GAAAC,GAAA,EACAr5B,EAAAo5B,KAEAc,QACA,IAAA/R,GAAA+R,EAAA/R,MAAAgS,EACAC,EAAA7d,SAAA2d,EAAAE,SAAAF,EAAAE,SAAAC,CAKA,UAAAlS,GAAA,MAAAiS,EAAA,CACA,GAAAE,GAAAC,GACA,OAAApS,IAEAA,EAAAgS,GACA,EAAAG,EAAA,GACAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,KAGA,MAAAF,IAEAA,EAAAC,EAAA,OAAAC,EAAA,MAAAA,EAAA,KAQA,GAAAE,GAAAje,SAAA2d,EAAAM,MAAAN,EAAAM,OAAA,GAAAtT,OAAAuT,UAIAC,EAAAne,SAAA2d,EAAAQ,MAAAR,EAAAQ,MAAAC,EAAA,EAGAC,EAAAJ,EAAAK,GAAAH,EAAAC,GAAA,GAcA,IAXAC,EAAA,GAAAre,SAAA2d,EAAAE,WACAA,IAAA,UAKAQ,EAAA,GAAAJ,EAAAK,IAAAte,SAAA2d,EAAAQ,QACAA,EAAA,GAIAA,GAAA,IACA,SAAA3nC,OAAA,kDAGA8nC,GAAAL,EACAG,EAAAD,EACAL,EAAAD,EAGAI,GAAA,WAGA,IAAAM,IAAA,eAAAN,GAAAE,GAAA,UACA16B,GAAAtN,KAAAooC,IAAA,OACA96B,EAAAtN,KAAAooC,IAAA,OACA96B,EAAAtN,KAAAooC,IAAA,MACA96B,EAAAtN,KAAA,IAAAooC,CAGA,IAAAC,GAAAP,EAAA,wBACAx6B,GAAAtN,KAAAqoC,IAAA,MACA/6B,EAAAtN,KAAA,IAAAqoC,EAGA/6B,EAAAtN,KAAAqoC,IAAA,SACA/6B,EAAAtN,KAAAqoC,IAAA,OAGA/6B,EAAAtN,KAAA0nC,IAAA,MAGAp6B,EAAAtN,KAAA,IAAA0nC,CAGA,QAAAznC,GAAA,EAAiBA,EAAA,IAAOA,EACxBqN,EAAAtN,EAAAC,GAAAw1B,EAAAx1B,EAGA,OAAAymC,KAAAD,EAAAn5B,GAzGA,GAQAm6B,GACAE,EATAE,EAAAnoC,EAAA,IACA+mC,EAAA/mC,EAAA,IAWAyoC,EAAA,EACAF,EAAA,CA+FAzoC,GAAAC,QAAA4mC,GZmoLMiC,IACA,SAAU9oC,EAAQC,EAASC,Ga7uLjC,QAAA4mC,GAAAkB,EAAAd,EAAAC,GACA,GAAA3mC,GAAA0mC,GAAAC,GAAA,CAEA,sBACAD,EAAA,WAAAc,EAAA,GAAArlC,OAAA,SACAqlC,EAAA,MAEAA,OAEA,IAAAH,GAAAG,EAAAF,SAAAE,EAAAK,SAOA,IAJAR,EAAA,MAAAA,EAAA,MACAA,EAAA,MAAAA,EAAA,OAGAX,EACA,OAAA6B,GAAA,EAAoBA,EAAA,KAASA,EAC7B7B,EAAA1mC,EAAAuoC,GAAAlB,EAAAkB,EAIA,OAAA7B,IAAAD,EAAAY,GAzBA,GAAAQ,GAAAnoC,EAAA,IACA+mC,EAAA/mC,EAAA,GA2BAF,GAAAC,QAAA6mC,GbuvLMkC,IACA,SAAUhpC,EAAQC,EAASC,GAEhC,YAoBA,SAAS+oC,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,QAASF,GAEvF,QAASG,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAInU,WAAU,qCAEhH,QAASoU,GAA2BhT,EAAMh0B,GAAQ,IAAKg0B,EAAQ,KAAM,IAAIiT,gBAAe,4DAAgE,QAAOjnC,GAAyB,gBAATA,IAAqC,kBAATA,GAA8Bg0B,EAAPh0B,EAElO,QAASknC,GAAUC,EAAUC,GAAc,GAA0B,kBAAfA,IAA4C,OAAfA,EAAuB,KAAM,IAAIxU,WAAU,iEAAoEwU,GAAeD,GAASznC,UAAYW,OAAO0zB,OAAOqT,GAAcA,EAAW1nC,WAAaC,aAAeP,MAAO+nC,EAAUE,YAAY,EAAOC,UAAU,EAAMC,cAAc,KAAeH,IAAY/mC,OAAOmnC,eAAiBnnC,OAAOmnC,eAAeL,EAAUC,GAAcD,EAASM,UAAYL,GAxBje3pC,EAAQkpC,YAAa,CcxxLtB,IAAAe,GAAAhqC,EAAA,Gd4xLKiqC,EAAUlB,EAAuBiB,Gc3xLtCE,EAAAlqC,EAAA,KACAmqC,EAAAnqC,EAAA,IACAoqC,EAAApqC,EAAA,GdiyLKqqC,EAActB,EAAuBqB,GchyL1CE,EAAAtqC,EAAA,KdoyLKuqC,EAAaxB,EAAuBuB,GclyLnCE,Ed4yLgB,SAAUC,GAG7B,QAASD,KACP,GAAIE,GAAOC,EAAOC,CAElBzB,GAAgBhpC,KAAMqqC,EAEtB,KAAK,GAAIK,GAAOrqC,UAAUC,OAAQ+B,EAAOC,MAAMooC,GAAOC,EAAO,EAAGA,EAAOD,EAAMC,IAC3EtoC,EAAKsoC,GAAQtqC,UAAUsqC,EAGzB,OAAeJ,GAASC,EAAQrB,EAA2BnpC,KAAMsqC,EAAWnoC,KAAKI,MAAM+nC,GAAatqC,MAAM2B,OAAOU,KAAiBmoC,EcvzLrI1U,OACE3P,UAAW,MdwzLPqkB,Ec/yLNI,cAAgB,WACK,SAAfZ,EAAAlnC,MAAM1B,MACRopC,EAAKK,UAAW1kB,UAAW6jB,EAAAlnC,MAAMqjB,adizL/BqkB,Ec9yLNM,gBAAkB,SAAAvpC,GAAS,GACjBwpC,GAAgBP,EAAKQ,MAArBD,WACRA,GAAYxpC,IdgzLRipC,Ec9yLNS,gBAAkB,WAAM,GACdC,GAAgBV,EAAKQ,MAArBE,WACRA,MdkyLQT,EAcJF,EAAQpB,EAA2BqB,EAAOC,GA2C/C,MApEApB,GAAUgB,EAAgBC,GA4B1BD,EAAexoC,Ucr0LhBspC,kBdq0L8C,Ycp0L5C,EAAAnB,EAAAzmC,QAASvD,KAAKorC,UAAUjpC,MACtB,EAAA4nC,EAAAtJ,QACGI,aAAa,GAAK,KAClB9+B,GAAG,OAAQ/B,KAAK4qC,iBdq0LtBP,EAAexoC,UcpzLhBwpC,OdozLmC,WcpzL1B,GAAAC,GAAAtrC,KAAAurC,EACiDvrC,KAAKgrC,MAArDQ,EADDD,EACCC,UAAWC,EADZF,EACYE,YAAaC,EADzBH,EACyBG,SAAUC,EADnCJ,EACmCI,UAClCxlB,EAAcnmB,KAAK81B,MAAnB3P,SACR,OACE2jB,GAAAf,QAAA6C,cAAA,OACE1kB,MAAOwkB,EACPtkB,OAAQukB,EACRE,IAAK,SAAAC,GACHR,EAAKF,SAAWU,GAElBC,QAAA,OAAgBL,EAAhB,IAA4BC,EAC5BK,oBAAoB,iBACpBlC,EAAAf,QAAA6C,cAAA,KACEzlB,UACgB,OAAdA,EAAA,aACiBA,EAAUjiB,EAD3B,KACiCiiB,EAAUhiB,EAD3C,WAEMgiB,EAAUlW,EAFhB,IAII,MAEN65B,EAAAf,QAAA6C,cAAAxB,EAAArB,SACE7hB,MAAOwkB,EACPtkB,OAAQ,IACR6kB,MAAOT,EACPU,WAAYT,EACZU,WAAYnsC,KAAK8qC,gBACjBsB,UAAWpsC,KAAKirC,qBd8zLlBZ,GACPR,EAAOwC,UcxzLVhC,GAAeiC,WACbZ,SAAUxB,EAAAnB,QAAUwD,OACpBZ,UAAWzB,EAAAnB,QAAUwD,OACrBxB,YAAab,EAAAnB,QAAUyD,KACvBtB,YAAahB,EAAAnB,QAAUyD,KACvBhB,UAAWtB,EAAAnB,QAAU0D,QACnBvC,EAAAnB,QAAU2D,OACRC,MAAOzC,EAAAnB,QAAU6D,OACjBC,SAAU3C,EAAAnB,QAAU6D,UAGxBnB,YAAavB,EAAAnB,QAAU0D,QACrBvC,EAAAnB,QAAU2D,OACRI,KAAM5C,EAAAnB,QAAU6D,OAChBG,OAAQ7C,EAAAnB,QAAUwD,OAClBS,SAAU9C,EAAAnB,QAAUwD,OACpBU,UAAW/C,EAAAnB,QAAUwD,OACrBW,KAAMhD,EAAAnB,QAAUwD,OAChBvrC,KAAMkpC,EAAAnB,QAAU6D,OAChB91B,OAAQozB,EAAAnB,QAAUwD,OAClBY,YAAajD,EAAAnB,QAAU6D,Wd0zL5BhtC,EAAQmpC,QctzLMsB,EduzLd1qC,EAAOC,QAAUA,EAAiB,SAI7BwtC,IACA,SAAUztC,EAAQC,EAASC,GAEhC,YAgCA,SAAS+oC,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,QAASF,GAEvF,QAASG,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAInU,WAAU,qCAEhH,QAASoU,GAA2BhT,EAAMh0B,GAAQ,IAAKg0B,EAAQ,KAAM,IAAIiT,gBAAe,4DAAgE,QAAOjnC,GAAyB,gBAATA,IAAqC,kBAATA,GAA8Bg0B,EAAPh0B,EAElO,QAASknC,GAAUC,EAAUC,GAAc,GAA0B,kBAAfA,IAA4C,OAAfA,EAAuB,KAAM,IAAIxU,WAAU,iEAAoEwU,GAAeD,GAASznC,UAAYW,OAAO0zB,OAAOqT,GAAcA,EAAW1nC,WAAaC,aAAeP,MAAO+nC,EAAUE,YAAY,EAAOC,UAAU,EAAMC,cAAc,KAAeH,IAAY/mC,OAAOmnC,eAAiBnnC,OAAOmnC,eAAeL,EAAUC,GAAcD,EAASM,UAAYL,GApCje3pC,EAAQkpC,YAAa,Cex5LtB,IAAAuE,GAAAxtC,EAAA,KACAgqC,EAAAhqC,EAAA,Gf65LKiqC,EAAUlB,EAAuBiB,Ge55LtCyD,EAAAztC,EAAA,KACA0tC,EAAA1tC,EAAA,Ifi6LK2tC,EAAc5E,EAAuB2E,Geh6L1CE,EAAA5tC,EAAA,Ifo6LK6tC,EAAU9E,EAAuB6E,Gen6LtCE,EAAA9tC,EAAA,Kfu6LK+tC,EAAmBhF,EAAuB+E,Get6L/CE,EAAAhuC,EAAA,Kf06LKiuC,EAAkBlF,EAAuBiF,Gez6L9CE,EAAAluC,EAAA,Kf66LKmuC,EAAqBpF,EAAuBmF,Ge36L3CE,Efq7LoB,SAAU3D,GAGjC,QAAS2D,KACP,GAAI1D,GAAOC,EAAOC,CAElBzB,GAAgBhpC,KAAMiuC,EAEtB,KAAK,GAAIvD,GAAOrqC,UAAUC,OAAQ+B,EAAOC,MAAMooC,GAAOC,EAAO,EAAGA,EAAOD,EAAMC,IAC3EtoC,EAAKsoC,GAAQtqC,UAAUsqC,EAGzB,OAAeJ,GAASC,EAAQrB,EAA2BnpC,KAAMsqC,EAAWnoC,KAAKI,MAAM+nC,GAAatqC,MAAM2B,OAAOU,KAAiBmoC,Ee/7LrI1U,OACEoY,WAAW,EACXC,SAAS,EACTC,iBAAiB,EACjBC,cACAC,WAAY,EACZC,YAAa,EACbC,WACAC,YACAC,WACAC,efg8LInE,Een4LNoE,cAAgB,SAAArtC,GACd,MAAe,GAARA,Gfo4LHipC,Eel4LNqE,mBAAqB,WAAM,GACjBP,GAAe9D,EAAK1U,MAApBwY,WACJQ,EAAe,EACfC,EAAgB,CAChBvE,GAAKwE,gBACPF,EAAetE,EAAKwE,eAAeC,wBAAwB/nB,MAC3D6nB,EAAgBvE,EAAKwE,eAAeC,wBAAwB7nB,OAE5D0nB,EACEtE,EAAKwE,eAAeC,wBAAwB/nB,OAAS,IACjDsjB,EAAKoE,cACHpE,EAAKwE,eAAeC,wBAAwB/nB,OAE9CsjB,EAAKwE,eAAeC,wBAAwB/nB,MAClD6nB,EACEvE,EAAKwE,eAAeC,wBAAwB/nB,OAAS,IACjDsjB,EAAKoE,cACHpE,EAAKwE,eAAeC,wBAAwB7nB,QAE9CojB,EAAKwE,eAAeC,wBAAwB7nB,OAE9C0nB,IAAiBR,GACnB9D,EAAKK,UACHyD,WAAYQ,EACZP,YAAaQ,MAIjBD,EAAela,OAAOsa,YAAc,IAAM,IAAMta,OAAOsa,WACvDH,EAAgBvE,EAAKoE,cAAcha,OAAOua,aACtCL,IAAiBR,GACnB9D,EAAKK,UACHyD,WAAYQ,EACZP,YAAaQ,KAInBvE,EAAK4E,af03LD5E,Ee72LN4E,UAAY,WAAM,GAAAC,GACgB7E,EAAK1U,MAA7B4Y,EADQW,EACRX,QAASC,EADDU,EACCV,WACXW,EAAaZ,EAAQ3tC,IAAI,SAAC8D,EAAG1E,GACjC,OACEwsC,OAAO,EAAAU,EAAAxc,WAAUjL,WAAW4kB,EAAKljB,WAAWziB,GAC5CgoC,0BAA4B,EAAI6B,EAAQpuC,OAAUH,EAAlD,OAGEovC,EAAeZ,EAAW5tC,IAAI,SAAA8D,GAClC,OACE7D,KAAM6D,EAAEk+B,WAAW/hC,KACnBksC,KAAMsC,SAAS3qC,EAAEk+B,WAAWmK,KAAM,IAClCJ,KAAMjoC,EAAEk+B,WAAW0M,KACnBtC,YAAatoC,EAAEk+B,WAAW2M,SAC1B54B,OAAQ0zB,EAAKmF,gBAAgBH,SAAS3qC,EAAEk+B,WAAWmK,KAAM,KACzDF,SAAUxC,EAAKljB,WACbsoB,OAAO/qC,EAAEk+B,WAAW8M,SACpBD,OAAO/qC,EAAEk+B,WAAW+M,UACnB,GACH7C,UAAWzC,EAAKljB,WACdsoB,OAAO/qC,EAAEk+B,WAAW8M,SACpBD,OAAO/qC,EAAEk+B,WAAW+M,UACnB,GACH/C,OAAQyC,SAAS3qC,EAAEk+B,WAAWmK,KAAM,KAAO,SAAW,EAAI,KAG9D1C,GAAKK,UAAW2D,QAASe,EAAcd,SAAUa,Kf22L7C9E,Eez2LNmF,gBAAkB,SAAApuC,GAChB,GAAM0f,GAAQ,QAEd,SAAQ,GACN,IAAK1f,IAAS0f,EACZ,MAAO,EACT,KAAK1f,IAAiB,EAAR0f,EACZ,MAAO,EACT,KAAK1f,IAAiB,EAAR0f,EACZ,MAAO,EACT,KAAK1f,IAAiB,GAAR0f,EACZ,MAAO,EACT,KAAK1f,IAAiB,IAAR0f,EACZ,MAAO,EACT,SACE,MAAO,Mf22LPupB,EevxLNuF,gBAAkB,SAAAxuC,GAChBipC,EAAKK,UAAWuD,iBAAiB,EAAMC,WAAY9sC,KfwxL/CipC,EetxLNwF,eAAiB,WACfxF,EAAKK,UAAWuD,iBAAiB,EAAOC,iBfuxLpC7D,EerxLNyF,sBAAwB,WACtBzF,EAAKK,UACHqD,WAAW,Kf4rLLzD,EA2FJF,EAAQpB,EAA2BqB,EAAOC,GAoN/C,MA1TApB,GAAU4E,EAAoB3D,GA2G9B2D,EAAmBpsC,UenhMpBspC,kBfmhMkD,WenhM9B,GAAAG,GAAAtrC,IACI,oBAAX40B,UACT50B,KAAK6uC,qBACLja,OAAOsb,iBAAiB,SAAUlwC,KAAK6uC,qBAEzCprC,WAAW,WACT,GAAM0sC,GAAYC,KAAKC,MAAM7C,EAAAzE,QAAUuH,eAAe,aAChDC,EAAcH,KAAKC,MAAM7C,EAAAzE,QAAUuH,eAAe,WACxD,IAAKH,EAGE,CACL,GAAMb,GAAaa,EAAUpvC,IAAI,SAAC8D,EAAG1E,GACnC,OACEwsC,OAAO,EAAAU,EAAAxc,WAAUjL,WAAW0lB,EAAKhkB,WAAWziB,GAC5CgoC,0BAA4B,EAAIsD,EAAU7vC,OAAUH,EAApD,OAGEovC,EAAegB,EAAYxvC,IAAI,SAAA8D,GACnC,OACE7D,KAAM6D,EAAEk+B,WAAW/hC,KACnBksC,KAAMsC,SAAS3qC,EAAEk+B,WAAWmK,KAAM,IAClCJ,KAAMjoC,EAAEk+B,WAAW0M,KACnBtC,YAAatoC,EAAEk+B,WAAW2M,SAC1B54B,OAAQw0B,EAAKqE,gBAAgBH,SAAS3qC,EAAEk+B,WAAWmK,KAAM,KACzDF,SAAU1B,EAAKhkB,WACbsoB,OAAO/qC,EAAEk+B,WAAW8M,SACpBD,OAAO/qC,EAAEk+B,WAAW+M,UACnB,GACH7C,UAAW3B,EAAKhkB,WACdsoB,OAAO/qC,EAAEk+B,WAAW8M,SACpBD,OAAO/qC,EAAEk+B,WAAW+M,UACnB,GACH/C,OAAQyC,SAAS3qC,EAAEk+B,WAAWmK,KAAM,KAAO,SAAW,EAAI,KAG9D5B,GAAKT,UACH2D,QAASe,EACTZ,WAAY4B,EACZ9B,SAAUa,EACVZ,QAASyB,QA/BX7E,GAAKkF,YACLlF,EAAKmF,mBAuCN,OfkhMJxC,EAAmBpsC,UehhMpB6uC,qBfghMqD,We/gM7B,mBAAX9b,SACTA,OAAO+b,oBAAoB,SAAU3wC,KAAK6uC,qBfwhM7CZ,EAAmBpsC,Uex+LpBylB,Qfw+LwC,Wex+L9B,GAAAspB,GAC4B5wC,KAAK81B,MAAjCwY,EADAsC,EACAtC,WAAYC,EADZqC,EACYrC,WACpB,OAAID,GAAa,KACR,EAAAjB,EAAApb,eACJtL,MAAM2nB,GACN1nB,WAAW0nB,EAAa,EAAGC,EAAc,KAEvC,EAAAlB,EAAApb,eACJtL,MAAM,KACNC,WAAW0nB,EAAa,EAAGC,EAAc,Kf6+L7CN,EAAmBpsC,Ue17LpB4uC,gBf07LgD,We17L9B,GAAAI,GAAA7wC,IAChB8wC,OAAM,oDACHC,KAAK,SAAAC,GACJ,MAAOA,GAASC,SAEjBF,KAAK,SAAA94B,GACJ,GAAMs3B,GAAet3B,EAAOwW,SAAS1tB,IAAI,SAAA8D,GACvC,OACE7D,KAAM6D,EAAEk+B,WAAW/hC,KACnBksC,KAAMsC,SAAS3qC,EAAEk+B,WAAWmK,KAAM,IAClCJ,KAAMjoC,EAAEk+B,WAAW0M,KACnBtC,YAAatoC,EAAEk+B,WAAW2M,SAC1B54B,OAAQ+5B,EAAKlB,gBAAgBH,SAAS3qC,EAAEk+B,WAAWmK,KAAM,KACzDF,SAAU6D,EAAKvpB,WACbsoB,OAAO/qC,EAAEk+B,WAAW8M,SACpBD,OAAO/qC,EAAEk+B,WAAW+M,UACnB,GACH7C,UAAW4D,EAAKvpB,WACdsoB,OAAO/qC,EAAEk+B,WAAW8M,SACpBD,OAAO/qC,EAAEk+B,WAAW+M,UACnB,GACH/C,OAAQyC,SAAS3qC,EAAEk+B,WAAWmK,KAAM,KAAO,SAAW,EAAI,KAG9DM,GAAAzE,QAAUmI,eAAe,UAAWj5B,EAAOwW,UAC3CoiB,EAAKhG,UACH2D,QAASe,EACTZ,WAAY12B,EAAOwW,aAGtB0iB,MAAM,SAAAC,GACLC,QAAQvlB,IAAI,wCACZulB,QAAQvlB,IAAR,kCACoCskB,KAAKkB,UAAUF,EAAK,KAAM,IAE9DC,QAAQvlB,IAAI,wCACZ+kB,EAAKhG,UAAWsD,SAAS,Ofq7L9BF,EAAmBpsC,Uej7LpB2uC,Ufi7L0C,Wej7L9B,GAAAe,GAAAvxC,IACV8wC,OAAM,sCACHC,KAAK,SAAAC,GACJ,MAAOA,GAASC,SAEjBF,KAAK,SAAA94B,GACJ,GAAMu5B,IAAa,EAAAlE,EAAAn6B,SAAQ8E,EAAQA,EAAO8rB,QAAQ0N,WAAWhjB,QAE7D4iB,SAAQvlB,IAAI,wCACZulB,QAAQvlB,IAAR,wBAC0BskB,KAAKkB,UAAUE,EAAY,KAAM,IAE3DH,QAAQvlB,IAAI,uCAEZ,IAAM4lB,GAAeF,EAAWzwC,IAAI,SAAC8D,EAAG1E,GACtC,OACEwsC,OAAO,EAAAU,EAAAxc,WAAUjL,WAAW2rB,EAAKjqB,WAAWziB,GAC5CgoC,0BAA4B,EAAI2E,EAAWlxC,OAAUH,EAArD,MAGJqtC,GAAAzE,QAAUmI,eAAe,WAAYM,GACrCD,EAAK1G,UACH4D,SAAUiD,EACVhD,QAAS8C,MAGZL,MAAM,SAAAC,GACLC,QAAQvlB,IAAI,wCACZulB,QAAQvlB,IAAR,gCACkCskB,KAAKkB,UAAUF,EAAK,KAAM,IAE5DC,QAAQvlB,IAAI,wCACZylB,EAAK1G,UAAWsD,SAAS,Ofu7L9BF,EAAmBpsC,Uen6LpBwpC,Ofm6LuC,Wen6L9B,GAAAsG,GAAA3xC,KAAA4xC,EAUH5xC,KAAK81B,MARPqY,EAFKyD,EAELzD,QACAD,EAHK0D,EAGL1D,UACAO,EAJKmD,EAILnD,SACAD,EALKoD,EAKLpD,QACAJ,EANKwD,EAMLxD,gBACAC,EAPKuD,EAOLvD,WACAC,EARKsD,EAQLtD,WACAC,EATKqD,EASLrD,WAEF,OAAIJ,GAEArE,EAAAf,QAAA6C,cAAA,OAAKiG,UAAW7D,EAAAjF,QAAO+I,YAAvB,iDAKA5D,EAEApE,EAAAf,QAAA6C,cAAA8B,EAAA3E,SACEgJ,UAAU,QACVC,gBAAiBhyC,KAAKiwC,wBAKxBxB,EAASnuC,OAETwpC,EAAAf,QAAA6C,cAAA,OACEC,IAAK,SAAAC,GACH6F,EAAK3C,eAAiBlD,IAExBhC,EAAAf,QAAA6C,cAAA,OAAKiG,UAAW7D,EAAAjF,QAAO+I,YAAvB,gCACAhI,EAAAf,QAAA6C,cAAA,OAAKiG,UAAW7D,EAAAjF,QAAOkJ,gBACrBnI,EAAAf,QAAA6C,cAAA,WACE9B,EAAAf,QAAA6C,cAAAgC,EAAA7E,SACE2C,SAAU4C,EACV3C,UAAW4C,EACX/C,UAAWiD,EACXhD,YAAa+C,EACbzD,YAAa/qC,KAAK+vC,gBAClB7E,YAAalrC,KAAKgwC,kBAGtBlG,EAAAf,QAAA6C,cAAA,WACE9B,EAAAf,QAAA6C,cAAAkC,EAAA/E,SAAemJ,KAAM9D,EAAkBC,EAAa,UAnB9D,Qf08LMJ,GACPpE,EAAOwC,UAETzsC,GAAQmpC,Qej7LMkF,Efk7LdtuC,EAAOC,QAAUA,EAAiB,SAI7BuyC,IACA,SAAUxyC,EAAQC,EAASC,GAEhC,YAYA,SAAS+oC,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,QAASF,GAEvF,QAASG,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAInU,WAAU,qCAEhH,QAASoU,GAA2BhT,EAAMh0B,GAAQ,IAAKg0B,EAAQ,KAAM,IAAIiT,gBAAe,4DAAgE,QAAOjnC,GAAyB,gBAATA,IAAqC,kBAATA,GAA8Bg0B,EAAPh0B,EAElO,QAASknC,GAAUC,EAAUC,GAAc,GAA0B,kBAAfA,IAA4C,OAAfA,EAAuB,KAAM,IAAIxU,WAAU,iEAAoEwU,GAAeD,GAASznC,UAAYW,OAAO0zB,OAAOqT,GAAcA,EAAW1nC,WAAaC,aAAeP,MAAO+nC,EAAUE,YAAY,EAAOC,UAAU,EAAMC,cAAc,KAAeH,IAAY/mC,OAAOmnC,eAAiBnnC,OAAOmnC,eAAeL,EAAUC,GAAcD,EAASM,UAAYL,GAhBje3pC,EAAQkpC,YAAa,CgBtwMtB,IAAAe,GAAAhqC,EAAA,GhB0wMKiqC,EAAUlB,EAAuBiB,GgBzwMtCI,EAAApqC,EAAA,GhB6wMKqqC,EAActB,EAAuBqB,GgB3wMpCmI,EhBqxMa,SAAUC,GAG1B,QAASD,KACP,GAAI7H,GAAOC,EAAOC,CAElBzB,GAAgBhpC,KAAMoyC,EAEtB,KAAK,GAAI1H,GAAOrqC,UAAUC,OAAQ+B,EAAOC,MAAMooC,GAAOC,EAAO,EAAGA,EAAOD,EAAMC,IAC3EtoC,EAAKsoC,GAAQtqC,UAAUsqC,EAGzB,OAAeJ,GAASC,EAAQrB,EAA2BnpC,KAAMqyC,EAAelwC,KAAKI,MAAM8vC,GAAiBryC,MAAM2B,OAAOU,KAAiBmoC,EgBhyM7I8H,QAAU,WAAM,GAAAC,GACqB/H,EAAKQ,MAAhCkH,EADMK,EACNL,KAAMM,EADAD,EACAC,gBACdA,IACExxC,KAAMkxC,EAAKO,WACXC,YAAaR,EAAKQ,YAClBC,UAAWT,EAAKU,SAASC,UAAU,EAAG,GACtCC,WAAYZ,EAAKhF,KACjBF,SAAU4C,OAAOsC,EAAKa,cAAcC,QAAQ,GAC5C/F,UAAW2C,OAAOsC,EAAKe,eAAeD,QAAQ,MhBqyM5CxI,EgBlyMN0I,OAAS,WAAM,GACLC,GAAoB3I,EAAKQ,MAAzBmI,eACRA,MhBmxMQ1I,EAiBJF,EAAQpB,EAA2BqB,EAAOC,GAsB/C,MAlDApB,GAAU+I,EAAaC,GA+BvBD,EAAYvwC,UgBryMbwpC,OhBqyMgC,WgBryMvB,GACC6G,GAASlyC,KAAKgrC,MAAdkH,IACR,OACEpI,GAAAf,QAAA6C,cAAA,UACErlB,IAAA,UAAe2rB,EAAKkB,SAApB,IACAC,KAAK,UACLC,YAAapB,EAAKqB,WAClBC,OAAO,UACP3B,UAAU,SACV18B,GAAI+8B,EAAKa,aACT39B,GAAI88B,EAAKe,cACTx7B,EAAGy6B,EAAKuB,WACRC,YAAa1zC,KAAKsyC,QAClBqB,QAAS3zC,KAAKsyC,QACdsB,WAAY5zC,KAAKkzC,OACjBW,OAAQ7zC,KAAKkzC,UhByyMXd,GACPvI,EAAOiK,cgBryMV1B,GAAY9F,WACV4F,KAAMhI,EAAAnB,QAAU2D,OACd+F,WAAYvI,EAAAnB,QAAU6D,OACtB8F,YAAaxI,EAAAnB,QAAU6D,OACvBgG,SAAU1I,EAAAnB,QAAU6D,OACpBM,KAAMhD,EAAAnB,QAAUwD,OAChBwG,aAAc7I,EAAAnB,QAAUwD,OACxB0G,cAAe/I,EAAAnB,QAAUwD,OACzB6G,SAAUlJ,EAAAnB,QAAUwD,OACpBkH,WAAYvJ,EAAAnB,QAAUwD,OACtBgH,WAAYrJ,EAAAnB,QAAUwD,SAExBiG,iBAAkBtI,EAAAnB,QAAUyD,KAC5B2G,gBAAiBjJ,EAAAnB,QAAUyD,MhByyM5B5sC,EAAQmpC,QgBvyMMqJ,EhBwyMdzyC,EAAOC,QAAUA,EAAiB,SAI7Bm0C,IACA,SAAUp0C,EAAQC,EAASC,GAEhC,YAgBA,SAAS+oC,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,QAASF,GAdvFjpC,EAAQkpC,YAAa,CiBv2MtB,IAAAmB,GAAApqC,EAAA,GjB22MKqqC,EAActB,EAAuBqB,GiB12M1CJ,EAAAhqC,EAAA,GjB82MKiqC,EAAUlB,EAAuBiB,GiB72MtCkE,EAAAluC,EAAA,KjBi3MKmuC,EAAqBpF,EAAuBmF,GiB/2M3CiG,EAAiB,WACrB,MACElK,GAAAf,QAAA6C,cAAA,SACE9B,EAAAf,QAAA6C,cAAA,QAAMiG,UAAW7D,EAAAjF,QAAOkL,aAAxB,wCAMAC,EAAiB,SAAA3yC,GACrB,MACEuoC,GAAAf,QAAA6C,cAAA,SACE9B,EAAAf,QAAA6C,cAAA,QAAMiG,UAAW7D,EAAAjF,QAAOkL,aAAxB,MACM1yC,EAAMoxC,UADZ,0BAC8CpxC,EAAMuxC,WADpD,aAC0E,IACvEvxC,EAAMmxC,YAFT,qBAEwCnxC,EAAMyrC,SAF9C,aAEkE,IAC/DzrC,EAAM0rC,aAMTkH,EAAgB,SAAAC,GAAc,GAAXlC,GAAWkC,EAAXlC,IACvB,OACEpI,GAAAf,QAAA6C,cAAA,OAAKiG,UAAW7D,EAAAjF,QAAOsL,kBACpBnC,EAAOgC,EAAehC,GAAQ8B,KAIrCG,GAAc7H,WACZ4F,KAAMhI,EAAAnB,QAAU2D,OACd1rC,KAAMkpC,EAAAnB,QAAU6D,OAChB8F,YAAaxI,EAAAnB,QAAU6D,OACvB+F,UAAWzI,EAAAnB,QAAU6D,OACrBkG,WAAY5I,EAAAnB,QAAUwD,OACtBS,SAAU9C,EAAAnB,QAAU6D,OACpBK,UAAW/C,EAAAnB,QAAU6D,UjBq4MxBhtC,EAAQmpC,QiBl4MMoL,EjBm4Mdx0C,EAAOC,QAAUA,EAAiB,SAI7B00C,IACA,SAAU30C,EAAQC,EAASC,GAEhC,YAoBA,SAAS+oC,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,QAASF,GAEvF,QAASG,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAInU,WAAU,qCAEhH,QAASoU,GAA2BhT,EAAMh0B,GAAQ,IAAKg0B,EAAQ,KAAM,IAAIiT,gBAAe,4DAAgE,QAAOjnC,GAAyB,gBAATA,IAAqC,kBAATA,GAA8Bg0B,EAAPh0B,EAElO,QAASknC,GAAUC,EAAUC,GAAc,GAA0B,kBAAfA,IAA4C,OAAfA,EAAuB,KAAM,IAAIxU,WAAU,iEAAoEwU,GAAeD,GAASznC,UAAYW,OAAO0zB,OAAOqT,GAAcA,EAAW1nC,WAAaC,aAAeP,MAAO+nC,EAAUE,YAAY,EAAOC,UAAU,EAAMC,cAAc,KAAeH,IAAY/mC,OAAOmnC,eAAiBnnC,OAAOmnC,eAAeL,EAAUC,GAAcD,EAASM,UAAYL,GAxBje3pC,EAAQkpC,YAAa,CkBt7MtB,IAAAmB,GAAApqC,EAAA,GlB07MKqqC,EAActB,EAAuBqB,GkBz7M1CsK,EAAA10C,EAAA,IlB67MK20C,EAAS5L,EAAuB2L,GkB57MrC1K,EAAAhqC,EAAA,GlBg8MKiqC,EAAUlB,EAAuBiB,GkB/7MtC4K,EAAA50C,EAAA,KlBm8MK60C,EAAgB9L,EAAuB6L,GkBj8MtCE,ElB28MU,SAAUtC,GAGvB,QAASsC,KACP,GAAIpK,GAAOC,EAAOC,CAElBzB,GAAgBhpC,KAAM20C,EAEtB,KAAK,GAAIjK,GAAOrqC,UAAUC,OAAQ+B,EAAOC,MAAMooC,GAAOC,EAAO,EAAGA,EAAOD,EAAMC,IAC3EtoC,EAAKsoC,GAAQtqC,UAAUsqC,EAGzB,OAAeJ,GAASC,EAAQrB,EAA2BnpC,KAAMqyC,EAAelwC,KAAKI,MAAM8vC,GAAiBryC,MAAM2B,OAAOU,KAAiBmoC,EkBt9M7IoK,aAAe,SAAArzC,GAAS,GACd4qC,GAAe3B,EAAKQ,MAApBmB,UACRA,GAAW5qC,IlBw9MPipC,EkBt9MNqK,aAAe,WAAM,GACXzI,GAAc5B,EAAKQ,MAAnBoB,SACRA,MlBg9MQ3B,EAQJF,EAAQpB,EAA2BqB,EAAOC,GA+C/C,MAlEApB,GAAUsL,EAAUtC,GAsBpBsC,EAAS9yC,UkBz9MVwpC,OlBy9M6B,WkBz9MpB,GAAAC,GAAAtrC,KAAAurC,EACuBvrC,KAAKgrC,MAA3BiB,EADDV,EACCU,MAAOC,EADRX,EACQW,WAET4I,EAAc7I,EAAMlrC,IAAI,SAAA8D,GAAA,MAC5BilC,GAAAf,QAAA6C,cAAA,QACErlB,IAAA,QAAaiuB,EAAAzL,QAAKtC,KAClB5hC,EAAGA,EAAE8nC,MACL0G,KAAMxuC,EAAEgoC,SACR2G,OAAO,UACPuB,YAAa,OAIXxE,EAAcrE,EAAWnrC,IAAI,SAACuU,EAAGpR,GAAJ,MACjC4lC,GAAAf,QAAA6C,cAAA8I,EAAA3L,SACExiB,IAAA,UAAejR,EAAEtU,KAAjB,UAA+BsU,EAAEo9B,YACjCR,MACEO,WAAYn9B,EAAEtU,KACd0xC,YAAap9B,EAAE63B,YACfyF,SAAUt9B,EAAEw3B,KACZI,KAAM53B,EAAE43B,KACR6F,aAAcz9B,EAAE03B,SAChBiG,cAAe39B,EAAE23B,UACjBmG,SAAUlvC,EACVuvC,WAAYn+B,EAAEwB,OACdy8B,WAAYj+B,EAAEy3B,QAEhByF,iBAAkBlH,EAAKsJ,aACvBzB,gBAAiB7H,EAAKuJ,gBAG1B,OACE/K,GAAAf,QAAA6C,cAAA,SACGkJ,EACAvE,IlBm+MCoE,GACP9K,EAAOiK,ckB/9MVa,GAASrI,WACPL,MAAO/B,EAAAnB,QAAU0D,QACfvC,EAAAnB,QAAU2D,OACRC,MAAOzC,EAAAnB,QAAU6D,OACjBC,SAAU3C,EAAAnB,QAAU6D,UAGxBT,WAAYjC,EAAAnB,QAAUyD,KACtBJ,UAAWlC,EAAAnB,QAAUyD,KACrBN,WAAYhC,EAAAnB,QAAU0D,QACpBvC,EAAAnB,QAAU2D,OACRI,KAAM5C,EAAAnB,QAAU6D,OAChBG,OAAQ7C,EAAAnB,QAAUwD,OAClBS,SAAU9C,EAAAnB,QAAUwD,OACpBU,UAAW/C,EAAAnB,QAAUwD,OACrBW,KAAMhD,EAAAnB,QAAUwD,OAChBvrC,KAAMkpC,EAAAnB,QAAU6D,OAChB91B,OAAQozB,EAAAnB,QAAUwD,OAClBY,YAAajD,EAAAnB,QAAU6D,WlBi+M5BhtC,EAAQmpC,QkB79MM4L,ElB89Mdh1C,EAAOC,QAAUA,EAAiB,SAI7Bo1C,IACA,SAAUr1C,EAAQC,GmB7iNxBD,EAAAC,SAAkBqyC,eAAA,0FAAAH,WAAA,sFAAAmC,YAAA,uFAAAI,iBAAA,8FnBojNZY,IACA,SAAUt1C,EAAQC,EAASC,GAEhC,YAgBA,SAAS+oC,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,QAASF,GAdvFjpC,EAAQkpC,YAAa,CoB1jNtB,IAAAe,GAAAhqC,EAAA,GpB8jNKiqC,EAAUlB,EAAuBiB,GoB7jNtCqL,EAAAr1C,EAAA,IpBikNKs1C,EAAgBvM,EAAuBsM,GoBhkN5CE,EAAAv1C,EAAA,KpBokNKw1C,EAAuBzM,EAAuBwM,GoBlkN7CE,EAAiB,WACrB,MACExL,GAAAf,QAAA6C,cAAA,WACE9B,EAAAf,QAAA6C,cAAAuJ,EAAApM,SACEwM,MAAM,wBACNC,OAEIx0C,KAAM,cACNy0C,QAAS,sDAGTz0C,KAAM,WACNy0C,QAAS,0CAETz0C,KAAM,SAAUy0C,QAAS,oBAG/B3L,EAAAf,QAAA6C,cAAAyJ,EAAAtM,QAAA,OpBskNLnpC,GAAQmpC,QoBlkNMuM,EpBmkNd31C,EAAOC,QAAUA,EAAiB","file":"component---src-pages-globeview-js-ed6be67a524f91b26450.js","sourcesContent":["webpackJsonp([234182462816062],{\n\n/***/ 68:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t// https://d3js.org/d3-dispatch/ Version 1.0.3. Copyright 2017 Mike Bostock.\n\t(function (global, factory) {\n\t\t true ? factory(exports) :\n\t\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t\t(factory((global.d3 = global.d3 || {})));\n\t}(this, (function (exports) { 'use strict';\n\t\n\tvar noop = {value: function() {}};\n\t\n\tfunction dispatch() {\n\t  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {\n\t    if (!(t = arguments[i] + \"\") || (t in _)) throw new Error(\"illegal type: \" + t);\n\t    _[t] = [];\n\t  }\n\t  return new Dispatch(_);\n\t}\n\t\n\tfunction Dispatch(_) {\n\t  this._ = _;\n\t}\n\t\n\tfunction parseTypenames(typenames, types) {\n\t  return typenames.trim().split(/^|\\s+/).map(function(t) {\n\t    var name = \"\", i = t.indexOf(\".\");\n\t    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);\n\t    if (t && !types.hasOwnProperty(t)) throw new Error(\"unknown type: \" + t);\n\t    return {type: t, name: name};\n\t  });\n\t}\n\t\n\tDispatch.prototype = dispatch.prototype = {\n\t  constructor: Dispatch,\n\t  on: function(typename, callback) {\n\t    var _ = this._,\n\t        T = parseTypenames(typename + \"\", _),\n\t        t,\n\t        i = -1,\n\t        n = T.length;\n\t\n\t    // If no callback was specified, return the callback of the given type and name.\n\t    if (arguments.length < 2) {\n\t      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;\n\t      return;\n\t    }\n\t\n\t    // If a type was specified, set the callback for the given type and name.\n\t    // Otherwise, if a null callback was specified, remove callbacks of the given name.\n\t    if (callback != null && typeof callback !== \"function\") throw new Error(\"invalid callback: \" + callback);\n\t    while (++i < n) {\n\t      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);\n\t      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);\n\t    }\n\t\n\t    return this;\n\t  },\n\t  copy: function() {\n\t    var copy = {}, _ = this._;\n\t    for (var t in _) copy[t] = _[t].slice();\n\t    return new Dispatch(copy);\n\t  },\n\t  call: function(type, that) {\n\t    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];\n\t    if (!this._.hasOwnProperty(type)) throw new Error(\"unknown type: \" + type);\n\t    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);\n\t  },\n\t  apply: function(type, that, args) {\n\t    if (!this._.hasOwnProperty(type)) throw new Error(\"unknown type: \" + type);\n\t    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);\n\t  }\n\t};\n\t\n\tfunction get(type, name) {\n\t  for (var i = 0, n = type.length, c; i < n; ++i) {\n\t    if ((c = type[i]).name === name) {\n\t      return c.value;\n\t    }\n\t  }\n\t}\n\t\n\tfunction set(type, name, callback) {\n\t  for (var i = 0, n = type.length; i < n; ++i) {\n\t    if (type[i].name === name) {\n\t      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));\n\t      break;\n\t    }\n\t  }\n\t  if (callback != null) type.push({name: name, value: callback});\n\t  return type;\n\t}\n\t\n\texports.dispatch = dispatch;\n\t\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\t\n\t})));\n\n\n/***/ }),\n\n/***/ 190:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t// https://d3js.org/d3-drag/ Version 1.2.1. Copyright 2017 Mike Bostock.\n\t(function (global, factory) {\n\t\t true ? factory(exports, __webpack_require__(68), __webpack_require__(21)) :\n\t\ttypeof define === 'function' && define.amd ? define(['exports', 'd3-dispatch', 'd3-selection'], factory) :\n\t\t(factory((global.d3 = global.d3 || {}),global.d3,global.d3));\n\t}(this, (function (exports,d3Dispatch,d3Selection) { 'use strict';\n\t\n\tfunction nopropagation() {\n\t  d3Selection.event.stopImmediatePropagation();\n\t}\n\t\n\tvar noevent = function() {\n\t  d3Selection.event.preventDefault();\n\t  d3Selection.event.stopImmediatePropagation();\n\t};\n\t\n\tvar nodrag = function(view) {\n\t  var root = view.document.documentElement,\n\t      selection = d3Selection.select(view).on(\"dragstart.drag\", noevent, true);\n\t  if (\"onselectstart\" in root) {\n\t    selection.on(\"selectstart.drag\", noevent, true);\n\t  } else {\n\t    root.__noselect = root.style.MozUserSelect;\n\t    root.style.MozUserSelect = \"none\";\n\t  }\n\t};\n\t\n\tfunction yesdrag(view, noclick) {\n\t  var root = view.document.documentElement,\n\t      selection = d3Selection.select(view).on(\"dragstart.drag\", null);\n\t  if (noclick) {\n\t    selection.on(\"click.drag\", noevent, true);\n\t    setTimeout(function() { selection.on(\"click.drag\", null); }, 0);\n\t  }\n\t  if (\"onselectstart\" in root) {\n\t    selection.on(\"selectstart.drag\", null);\n\t  } else {\n\t    root.style.MozUserSelect = root.__noselect;\n\t    delete root.__noselect;\n\t  }\n\t}\n\t\n\tvar constant = function(x) {\n\t  return function() {\n\t    return x;\n\t  };\n\t};\n\t\n\tfunction DragEvent(target, type, subject, id, active, x, y, dx, dy, dispatch$$1) {\n\t  this.target = target;\n\t  this.type = type;\n\t  this.subject = subject;\n\t  this.identifier = id;\n\t  this.active = active;\n\t  this.x = x;\n\t  this.y = y;\n\t  this.dx = dx;\n\t  this.dy = dy;\n\t  this._ = dispatch$$1;\n\t}\n\t\n\tDragEvent.prototype.on = function() {\n\t  var value = this._.on.apply(this._, arguments);\n\t  return value === this._ ? this : value;\n\t};\n\t\n\t// Ignore right-click, since that should open the context menu.\n\tfunction defaultFilter() {\n\t  return !d3Selection.event.button;\n\t}\n\t\n\tfunction defaultContainer() {\n\t  return this.parentNode;\n\t}\n\t\n\tfunction defaultSubject(d) {\n\t  return d == null ? {x: d3Selection.event.x, y: d3Selection.event.y} : d;\n\t}\n\t\n\tfunction defaultTouchable() {\n\t  return \"ontouchstart\" in this;\n\t}\n\t\n\tvar drag = function() {\n\t  var filter = defaultFilter,\n\t      container = defaultContainer,\n\t      subject = defaultSubject,\n\t      touchable = defaultTouchable,\n\t      gestures = {},\n\t      listeners = d3Dispatch.dispatch(\"start\", \"drag\", \"end\"),\n\t      active = 0,\n\t      mousedownx,\n\t      mousedowny,\n\t      mousemoving,\n\t      touchending,\n\t      clickDistance2 = 0;\n\t\n\t  function drag(selection) {\n\t    selection\n\t        .on(\"mousedown.drag\", mousedowned)\n\t      .filter(touchable)\n\t        .on(\"touchstart.drag\", touchstarted)\n\t        .on(\"touchmove.drag\", touchmoved)\n\t        .on(\"touchend.drag touchcancel.drag\", touchended)\n\t        .style(\"touch-action\", \"none\")\n\t        .style(\"-webkit-tap-highlight-color\", \"rgba(0,0,0,0)\");\n\t  }\n\t\n\t  function mousedowned() {\n\t    if (touchending || !filter.apply(this, arguments)) return;\n\t    var gesture = beforestart(\"mouse\", container.apply(this, arguments), d3Selection.mouse, this, arguments);\n\t    if (!gesture) return;\n\t    d3Selection.select(d3Selection.event.view).on(\"mousemove.drag\", mousemoved, true).on(\"mouseup.drag\", mouseupped, true);\n\t    nodrag(d3Selection.event.view);\n\t    nopropagation();\n\t    mousemoving = false;\n\t    mousedownx = d3Selection.event.clientX;\n\t    mousedowny = d3Selection.event.clientY;\n\t    gesture(\"start\");\n\t  }\n\t\n\t  function mousemoved() {\n\t    noevent();\n\t    if (!mousemoving) {\n\t      var dx = d3Selection.event.clientX - mousedownx, dy = d3Selection.event.clientY - mousedowny;\n\t      mousemoving = dx * dx + dy * dy > clickDistance2;\n\t    }\n\t    gestures.mouse(\"drag\");\n\t  }\n\t\n\t  function mouseupped() {\n\t    d3Selection.select(d3Selection.event.view).on(\"mousemove.drag mouseup.drag\", null);\n\t    yesdrag(d3Selection.event.view, mousemoving);\n\t    noevent();\n\t    gestures.mouse(\"end\");\n\t  }\n\t\n\t  function touchstarted() {\n\t    if (!filter.apply(this, arguments)) return;\n\t    var touches = d3Selection.event.changedTouches,\n\t        c = container.apply(this, arguments),\n\t        n = touches.length, i, gesture;\n\t\n\t    for (i = 0; i < n; ++i) {\n\t      if (gesture = beforestart(touches[i].identifier, c, d3Selection.touch, this, arguments)) {\n\t        nopropagation();\n\t        gesture(\"start\");\n\t      }\n\t    }\n\t  }\n\t\n\t  function touchmoved() {\n\t    var touches = d3Selection.event.changedTouches,\n\t        n = touches.length, i, gesture;\n\t\n\t    for (i = 0; i < n; ++i) {\n\t      if (gesture = gestures[touches[i].identifier]) {\n\t        noevent();\n\t        gesture(\"drag\");\n\t      }\n\t    }\n\t  }\n\t\n\t  function touchended() {\n\t    var touches = d3Selection.event.changedTouches,\n\t        n = touches.length, i, gesture;\n\t\n\t    if (touchending) clearTimeout(touchending);\n\t    touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!\n\t    for (i = 0; i < n; ++i) {\n\t      if (gesture = gestures[touches[i].identifier]) {\n\t        nopropagation();\n\t        gesture(\"end\");\n\t      }\n\t    }\n\t  }\n\t\n\t  function beforestart(id, container, point, that, args) {\n\t    var p = point(container, id), s, dx, dy,\n\t        sublisteners = listeners.copy();\n\t\n\t    if (!d3Selection.customEvent(new DragEvent(drag, \"beforestart\", s, id, active, p[0], p[1], 0, 0, sublisteners), function() {\n\t      if ((d3Selection.event.subject = s = subject.apply(that, args)) == null) return false;\n\t      dx = s.x - p[0] || 0;\n\t      dy = s.y - p[1] || 0;\n\t      return true;\n\t    })) return;\n\t\n\t    return function gesture(type) {\n\t      var p0 = p, n;\n\t      switch (type) {\n\t        case \"start\": gestures[id] = gesture, n = active++; break;\n\t        case \"end\": delete gestures[id], --active; // nobreak\n\t        case \"drag\": p = point(container, id), n = active; break;\n\t      }\n\t      d3Selection.customEvent(new DragEvent(drag, type, s, id, n, p[0] + dx, p[1] + dy, p[0] - p0[0], p[1] - p0[1], sublisteners), sublisteners.apply, sublisteners, [type, that, args]);\n\t    };\n\t  }\n\t\n\t  drag.filter = function(_) {\n\t    return arguments.length ? (filter = typeof _ === \"function\" ? _ : constant(!!_), drag) : filter;\n\t  };\n\t\n\t  drag.container = function(_) {\n\t    return arguments.length ? (container = typeof _ === \"function\" ? _ : constant(_), drag) : container;\n\t  };\n\t\n\t  drag.subject = function(_) {\n\t    return arguments.length ? (subject = typeof _ === \"function\" ? _ : constant(_), drag) : subject;\n\t  };\n\t\n\t  drag.touchable = function(_) {\n\t    return arguments.length ? (touchable = typeof _ === \"function\" ? _ : constant(!!_), drag) : touchable;\n\t  };\n\t\n\t  drag.on = function() {\n\t    var value = listeners.on.apply(listeners, arguments);\n\t    return value === listeners ? drag : value;\n\t  };\n\t\n\t  drag.clickDistance = function(_) {\n\t    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);\n\t  };\n\t\n\t  return drag;\n\t};\n\t\n\texports.drag = drag;\n\texports.dragDisable = nodrag;\n\texports.dragEnable = yesdrag;\n\t\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\t\n\t})));\n\n\n/***/ }),\n\n/***/ 362:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t// https://d3js.org/d3-ease/ Version 1.0.3. Copyright 2017 Mike Bostock.\n\t(function (global, factory) {\n\t\t true ? factory(exports) :\n\t\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t\t(factory((global.d3 = global.d3 || {})));\n\t}(this, (function (exports) { 'use strict';\n\t\n\tfunction linear(t) {\n\t  return +t;\n\t}\n\t\n\tfunction quadIn(t) {\n\t  return t * t;\n\t}\n\t\n\tfunction quadOut(t) {\n\t  return t * (2 - t);\n\t}\n\t\n\tfunction quadInOut(t) {\n\t  return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;\n\t}\n\t\n\tfunction cubicIn(t) {\n\t  return t * t * t;\n\t}\n\t\n\tfunction cubicOut(t) {\n\t  return --t * t * t + 1;\n\t}\n\t\n\tfunction cubicInOut(t) {\n\t  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;\n\t}\n\t\n\tvar exponent = 3;\n\t\n\tvar polyIn = (function custom(e) {\n\t  e = +e;\n\t\n\t  function polyIn(t) {\n\t    return Math.pow(t, e);\n\t  }\n\t\n\t  polyIn.exponent = custom;\n\t\n\t  return polyIn;\n\t})(exponent);\n\t\n\tvar polyOut = (function custom(e) {\n\t  e = +e;\n\t\n\t  function polyOut(t) {\n\t    return 1 - Math.pow(1 - t, e);\n\t  }\n\t\n\t  polyOut.exponent = custom;\n\t\n\t  return polyOut;\n\t})(exponent);\n\t\n\tvar polyInOut = (function custom(e) {\n\t  e = +e;\n\t\n\t  function polyInOut(t) {\n\t    return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;\n\t  }\n\t\n\t  polyInOut.exponent = custom;\n\t\n\t  return polyInOut;\n\t})(exponent);\n\t\n\tvar pi = Math.PI;\n\tvar halfPi = pi / 2;\n\t\n\tfunction sinIn(t) {\n\t  return 1 - Math.cos(t * halfPi);\n\t}\n\t\n\tfunction sinOut(t) {\n\t  return Math.sin(t * halfPi);\n\t}\n\t\n\tfunction sinInOut(t) {\n\t  return (1 - Math.cos(pi * t)) / 2;\n\t}\n\t\n\tfunction expIn(t) {\n\t  return Math.pow(2, 10 * t - 10);\n\t}\n\t\n\tfunction expOut(t) {\n\t  return 1 - Math.pow(2, -10 * t);\n\t}\n\t\n\tfunction expInOut(t) {\n\t  return ((t *= 2) <= 1 ? Math.pow(2, 10 * t - 10) : 2 - Math.pow(2, 10 - 10 * t)) / 2;\n\t}\n\t\n\tfunction circleIn(t) {\n\t  return 1 - Math.sqrt(1 - t * t);\n\t}\n\t\n\tfunction circleOut(t) {\n\t  return Math.sqrt(1 - --t * t);\n\t}\n\t\n\tfunction circleInOut(t) {\n\t  return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;\n\t}\n\t\n\tvar b1 = 4 / 11;\n\tvar b2 = 6 / 11;\n\tvar b3 = 8 / 11;\n\tvar b4 = 3 / 4;\n\tvar b5 = 9 / 11;\n\tvar b6 = 10 / 11;\n\tvar b7 = 15 / 16;\n\tvar b8 = 21 / 22;\n\tvar b9 = 63 / 64;\n\tvar b0 = 1 / b1 / b1;\n\t\n\tfunction bounceIn(t) {\n\t  return 1 - bounceOut(1 - t);\n\t}\n\t\n\tfunction bounceOut(t) {\n\t  return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;\n\t}\n\t\n\tfunction bounceInOut(t) {\n\t  return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;\n\t}\n\t\n\tvar overshoot = 1.70158;\n\t\n\tvar backIn = (function custom(s) {\n\t  s = +s;\n\t\n\t  function backIn(t) {\n\t    return t * t * ((s + 1) * t - s);\n\t  }\n\t\n\t  backIn.overshoot = custom;\n\t\n\t  return backIn;\n\t})(overshoot);\n\t\n\tvar backOut = (function custom(s) {\n\t  s = +s;\n\t\n\t  function backOut(t) {\n\t    return --t * t * ((s + 1) * t + s) + 1;\n\t  }\n\t\n\t  backOut.overshoot = custom;\n\t\n\t  return backOut;\n\t})(overshoot);\n\t\n\tvar backInOut = (function custom(s) {\n\t  s = +s;\n\t\n\t  function backInOut(t) {\n\t    return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;\n\t  }\n\t\n\t  backInOut.overshoot = custom;\n\t\n\t  return backInOut;\n\t})(overshoot);\n\t\n\tvar tau = 2 * Math.PI;\n\tvar amplitude = 1;\n\tvar period = 0.3;\n\t\n\tvar elasticIn = (function custom(a, p) {\n\t  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);\n\t\n\t  function elasticIn(t) {\n\t    return a * Math.pow(2, 10 * --t) * Math.sin((s - t) / p);\n\t  }\n\t\n\t  elasticIn.amplitude = function(a) { return custom(a, p * tau); };\n\t  elasticIn.period = function(p) { return custom(a, p); };\n\t\n\t  return elasticIn;\n\t})(amplitude, period);\n\t\n\tvar elasticOut = (function custom(a, p) {\n\t  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);\n\t\n\t  function elasticOut(t) {\n\t    return 1 - a * Math.pow(2, -10 * (t = +t)) * Math.sin((t + s) / p);\n\t  }\n\t\n\t  elasticOut.amplitude = function(a) { return custom(a, p * tau); };\n\t  elasticOut.period = function(p) { return custom(a, p); };\n\t\n\t  return elasticOut;\n\t})(amplitude, period);\n\t\n\tvar elasticInOut = (function custom(a, p) {\n\t  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);\n\t\n\t  function elasticInOut(t) {\n\t    return ((t = t * 2 - 1) < 0\n\t        ? a * Math.pow(2, 10 * t) * Math.sin((s - t) / p)\n\t        : 2 - a * Math.pow(2, -10 * t) * Math.sin((s + t) / p)) / 2;\n\t  }\n\t\n\t  elasticInOut.amplitude = function(a) { return custom(a, p * tau); };\n\t  elasticInOut.period = function(p) { return custom(a, p); };\n\t\n\t  return elasticInOut;\n\t})(amplitude, period);\n\t\n\texports.easeLinear = linear;\n\texports.easeQuad = quadInOut;\n\texports.easeQuadIn = quadIn;\n\texports.easeQuadOut = quadOut;\n\texports.easeQuadInOut = quadInOut;\n\texports.easeCubic = cubicInOut;\n\texports.easeCubicIn = cubicIn;\n\texports.easeCubicOut = cubicOut;\n\texports.easeCubicInOut = cubicInOut;\n\texports.easePoly = polyInOut;\n\texports.easePolyIn = polyIn;\n\texports.easePolyOut = polyOut;\n\texports.easePolyInOut = polyInOut;\n\texports.easeSin = sinInOut;\n\texports.easeSinIn = sinIn;\n\texports.easeSinOut = sinOut;\n\texports.easeSinInOut = sinInOut;\n\texports.easeExp = expInOut;\n\texports.easeExpIn = expIn;\n\texports.easeExpOut = expOut;\n\texports.easeExpInOut = expInOut;\n\texports.easeCircle = circleInOut;\n\texports.easeCircleIn = circleIn;\n\texports.easeCircleOut = circleOut;\n\texports.easeCircleInOut = circleInOut;\n\texports.easeBounce = bounceOut;\n\texports.easeBounceIn = bounceIn;\n\texports.easeBounceOut = bounceOut;\n\texports.easeBounceInOut = bounceInOut;\n\texports.easeBack = backInOut;\n\texports.easeBackIn = backIn;\n\texports.easeBackOut = backOut;\n\texports.easeBackInOut = backInOut;\n\texports.easeElastic = elasticOut;\n\texports.easeElasticIn = elasticIn;\n\texports.easeElasticOut = elasticOut;\n\texports.easeElasticInOut = elasticInOut;\n\t\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\t\n\t})));\n\n\n/***/ }),\n\n/***/ 191:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t// https://d3js.org/d3-geo/ Version 1.10.0. Copyright 2018 Mike Bostock.\n\t(function (global, factory) {\n\t\t true ? factory(exports, __webpack_require__(120)) :\n\t\ttypeof define === 'function' && define.amd ? define(['exports', 'd3-array'], factory) :\n\t\t(factory((global.d3 = global.d3 || {}),global.d3));\n\t}(this, (function (exports,d3Array) { 'use strict';\n\t\n\t// Adds floating point numbers with twice the normal precision.\n\t// Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and\n\t// Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)\n\t// 305–363 (1997).\n\t// Code adapted from GeographicLib by Charles F. F. Karney,\n\t// http://geographiclib.sourceforge.net/\n\t\n\tfunction adder() {\n\t  return new Adder;\n\t}\n\t\n\tfunction Adder() {\n\t  this.reset();\n\t}\n\t\n\tAdder.prototype = {\n\t  constructor: Adder,\n\t  reset: function() {\n\t    this.s = // rounded value\n\t    this.t = 0; // exact error\n\t  },\n\t  add: function(y) {\n\t    add(temp, y, this.t);\n\t    add(this, temp.s, this.s);\n\t    if (this.s) this.t += temp.t;\n\t    else this.s = temp.t;\n\t  },\n\t  valueOf: function() {\n\t    return this.s;\n\t  }\n\t};\n\t\n\tvar temp = new Adder;\n\t\n\tfunction add(adder, a, b) {\n\t  var x = adder.s = a + b,\n\t      bv = x - a,\n\t      av = x - bv;\n\t  adder.t = (a - av) + (b - bv);\n\t}\n\t\n\tvar epsilon = 1e-6;\n\tvar epsilon2 = 1e-12;\n\tvar pi = Math.PI;\n\tvar halfPi = pi / 2;\n\tvar quarterPi = pi / 4;\n\tvar tau = pi * 2;\n\t\n\tvar degrees = 180 / pi;\n\tvar radians = pi / 180;\n\t\n\tvar abs = Math.abs;\n\tvar atan = Math.atan;\n\tvar atan2 = Math.atan2;\n\tvar cos = Math.cos;\n\tvar ceil = Math.ceil;\n\tvar exp = Math.exp;\n\t\n\tvar log = Math.log;\n\tvar pow = Math.pow;\n\tvar sin = Math.sin;\n\tvar sign = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };\n\tvar sqrt = Math.sqrt;\n\tvar tan = Math.tan;\n\t\n\tfunction acos(x) {\n\t  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);\n\t}\n\t\n\tfunction asin(x) {\n\t  return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);\n\t}\n\t\n\tfunction haversin(x) {\n\t  return (x = sin(x / 2)) * x;\n\t}\n\t\n\tfunction noop() {}\n\t\n\tfunction streamGeometry(geometry, stream) {\n\t  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {\n\t    streamGeometryType[geometry.type](geometry, stream);\n\t  }\n\t}\n\t\n\tvar streamObjectType = {\n\t  Feature: function(object, stream) {\n\t    streamGeometry(object.geometry, stream);\n\t  },\n\t  FeatureCollection: function(object, stream) {\n\t    var features = object.features, i = -1, n = features.length;\n\t    while (++i < n) streamGeometry(features[i].geometry, stream);\n\t  }\n\t};\n\t\n\tvar streamGeometryType = {\n\t  Sphere: function(object, stream) {\n\t    stream.sphere();\n\t  },\n\t  Point: function(object, stream) {\n\t    object = object.coordinates;\n\t    stream.point(object[0], object[1], object[2]);\n\t  },\n\t  MultiPoint: function(object, stream) {\n\t    var coordinates = object.coordinates, i = -1, n = coordinates.length;\n\t    while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);\n\t  },\n\t  LineString: function(object, stream) {\n\t    streamLine(object.coordinates, stream, 0);\n\t  },\n\t  MultiLineString: function(object, stream) {\n\t    var coordinates = object.coordinates, i = -1, n = coordinates.length;\n\t    while (++i < n) streamLine(coordinates[i], stream, 0);\n\t  },\n\t  Polygon: function(object, stream) {\n\t    streamPolygon(object.coordinates, stream);\n\t  },\n\t  MultiPolygon: function(object, stream) {\n\t    var coordinates = object.coordinates, i = -1, n = coordinates.length;\n\t    while (++i < n) streamPolygon(coordinates[i], stream);\n\t  },\n\t  GeometryCollection: function(object, stream) {\n\t    var geometries = object.geometries, i = -1, n = geometries.length;\n\t    while (++i < n) streamGeometry(geometries[i], stream);\n\t  }\n\t};\n\t\n\tfunction streamLine(coordinates, stream, closed) {\n\t  var i = -1, n = coordinates.length - closed, coordinate;\n\t  stream.lineStart();\n\t  while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);\n\t  stream.lineEnd();\n\t}\n\t\n\tfunction streamPolygon(coordinates, stream) {\n\t  var i = -1, n = coordinates.length;\n\t  stream.polygonStart();\n\t  while (++i < n) streamLine(coordinates[i], stream, 1);\n\t  stream.polygonEnd();\n\t}\n\t\n\tfunction geoStream(object, stream) {\n\t  if (object && streamObjectType.hasOwnProperty(object.type)) {\n\t    streamObjectType[object.type](object, stream);\n\t  } else {\n\t    streamGeometry(object, stream);\n\t  }\n\t}\n\t\n\tvar areaRingSum = adder();\n\t\n\tvar areaSum = adder();\n\tvar lambda00;\n\tvar phi00;\n\tvar lambda0;\n\tvar cosPhi0;\n\tvar sinPhi0;\n\t\n\tvar areaStream = {\n\t  point: noop,\n\t  lineStart: noop,\n\t  lineEnd: noop,\n\t  polygonStart: function() {\n\t    areaRingSum.reset();\n\t    areaStream.lineStart = areaRingStart;\n\t    areaStream.lineEnd = areaRingEnd;\n\t  },\n\t  polygonEnd: function() {\n\t    var areaRing = +areaRingSum;\n\t    areaSum.add(areaRing < 0 ? tau + areaRing : areaRing);\n\t    this.lineStart = this.lineEnd = this.point = noop;\n\t  },\n\t  sphere: function() {\n\t    areaSum.add(tau);\n\t  }\n\t};\n\t\n\tfunction areaRingStart() {\n\t  areaStream.point = areaPointFirst;\n\t}\n\t\n\tfunction areaRingEnd() {\n\t  areaPoint(lambda00, phi00);\n\t}\n\t\n\tfunction areaPointFirst(lambda, phi) {\n\t  areaStream.point = areaPoint;\n\t  lambda00 = lambda, phi00 = phi;\n\t  lambda *= radians, phi *= radians;\n\t  lambda0 = lambda, cosPhi0 = cos(phi = phi / 2 + quarterPi), sinPhi0 = sin(phi);\n\t}\n\t\n\tfunction areaPoint(lambda, phi) {\n\t  lambda *= radians, phi *= radians;\n\t  phi = phi / 2 + quarterPi; // half the angular distance from south pole\n\t\n\t  // Spherical excess E for a spherical triangle with vertices: south pole,\n\t  // previous point, current point.  Uses a formula derived from Cagnoli’s\n\t  // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).\n\t  var dLambda = lambda - lambda0,\n\t      sdLambda = dLambda >= 0 ? 1 : -1,\n\t      adLambda = sdLambda * dLambda,\n\t      cosPhi = cos(phi),\n\t      sinPhi = sin(phi),\n\t      k = sinPhi0 * sinPhi,\n\t      u = cosPhi0 * cosPhi + k * cos(adLambda),\n\t      v = k * sdLambda * sin(adLambda);\n\t  areaRingSum.add(atan2(v, u));\n\t\n\t  // Advance the previous points.\n\t  lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;\n\t}\n\t\n\tfunction area(object) {\n\t  areaSum.reset();\n\t  geoStream(object, areaStream);\n\t  return areaSum * 2;\n\t}\n\t\n\tfunction spherical(cartesian) {\n\t  return [atan2(cartesian[1], cartesian[0]), asin(cartesian[2])];\n\t}\n\t\n\tfunction cartesian(spherical) {\n\t  var lambda = spherical[0], phi = spherical[1], cosPhi = cos(phi);\n\t  return [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi)];\n\t}\n\t\n\tfunction cartesianDot(a, b) {\n\t  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n\t}\n\t\n\tfunction cartesianCross(a, b) {\n\t  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];\n\t}\n\t\n\t// TODO return a\n\tfunction cartesianAddInPlace(a, b) {\n\t  a[0] += b[0], a[1] += b[1], a[2] += b[2];\n\t}\n\t\n\tfunction cartesianScale(vector, k) {\n\t  return [vector[0] * k, vector[1] * k, vector[2] * k];\n\t}\n\t\n\t// TODO return d\n\tfunction cartesianNormalizeInPlace(d) {\n\t  var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);\n\t  d[0] /= l, d[1] /= l, d[2] /= l;\n\t}\n\t\n\tvar lambda0$1;\n\tvar phi0;\n\tvar lambda1;\n\tvar phi1;\n\tvar lambda2;\n\tvar lambda00$1;\n\tvar phi00$1;\n\tvar p0;\n\tvar deltaSum = adder();\n\tvar ranges;\n\tvar range$1;\n\t\n\tvar boundsStream = {\n\t  point: boundsPoint,\n\t  lineStart: boundsLineStart,\n\t  lineEnd: boundsLineEnd,\n\t  polygonStart: function() {\n\t    boundsStream.point = boundsRingPoint;\n\t    boundsStream.lineStart = boundsRingStart;\n\t    boundsStream.lineEnd = boundsRingEnd;\n\t    deltaSum.reset();\n\t    areaStream.polygonStart();\n\t  },\n\t  polygonEnd: function() {\n\t    areaStream.polygonEnd();\n\t    boundsStream.point = boundsPoint;\n\t    boundsStream.lineStart = boundsLineStart;\n\t    boundsStream.lineEnd = boundsLineEnd;\n\t    if (areaRingSum < 0) lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);\n\t    else if (deltaSum > epsilon) phi1 = 90;\n\t    else if (deltaSum < -epsilon) phi0 = -90;\n\t    range$1[0] = lambda0$1, range$1[1] = lambda1;\n\t  }\n\t};\n\t\n\tfunction boundsPoint(lambda, phi) {\n\t  ranges.push(range$1 = [lambda0$1 = lambda, lambda1 = lambda]);\n\t  if (phi < phi0) phi0 = phi;\n\t  if (phi > phi1) phi1 = phi;\n\t}\n\t\n\tfunction linePoint(lambda, phi) {\n\t  var p = cartesian([lambda * radians, phi * radians]);\n\t  if (p0) {\n\t    var normal = cartesianCross(p0, p),\n\t        equatorial = [normal[1], -normal[0], 0],\n\t        inflection = cartesianCross(equatorial, normal);\n\t    cartesianNormalizeInPlace(inflection);\n\t    inflection = spherical(inflection);\n\t    var delta = lambda - lambda2,\n\t        sign$$1 = delta > 0 ? 1 : -1,\n\t        lambdai = inflection[0] * degrees * sign$$1,\n\t        phii,\n\t        antimeridian = abs(delta) > 180;\n\t    if (antimeridian ^ (sign$$1 * lambda2 < lambdai && lambdai < sign$$1 * lambda)) {\n\t      phii = inflection[1] * degrees;\n\t      if (phii > phi1) phi1 = phii;\n\t    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign$$1 * lambda2 < lambdai && lambdai < sign$$1 * lambda)) {\n\t      phii = -inflection[1] * degrees;\n\t      if (phii < phi0) phi0 = phii;\n\t    } else {\n\t      if (phi < phi0) phi0 = phi;\n\t      if (phi > phi1) phi1 = phi;\n\t    }\n\t    if (antimeridian) {\n\t      if (lambda < lambda2) {\n\t        if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;\n\t      } else {\n\t        if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;\n\t      }\n\t    } else {\n\t      if (lambda1 >= lambda0$1) {\n\t        if (lambda < lambda0$1) lambda0$1 = lambda;\n\t        if (lambda > lambda1) lambda1 = lambda;\n\t      } else {\n\t        if (lambda > lambda2) {\n\t          if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;\n\t        } else {\n\t          if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;\n\t        }\n\t      }\n\t    }\n\t  } else {\n\t    ranges.push(range$1 = [lambda0$1 = lambda, lambda1 = lambda]);\n\t  }\n\t  if (phi < phi0) phi0 = phi;\n\t  if (phi > phi1) phi1 = phi;\n\t  p0 = p, lambda2 = lambda;\n\t}\n\t\n\tfunction boundsLineStart() {\n\t  boundsStream.point = linePoint;\n\t}\n\t\n\tfunction boundsLineEnd() {\n\t  range$1[0] = lambda0$1, range$1[1] = lambda1;\n\t  boundsStream.point = boundsPoint;\n\t  p0 = null;\n\t}\n\t\n\tfunction boundsRingPoint(lambda, phi) {\n\t  if (p0) {\n\t    var delta = lambda - lambda2;\n\t    deltaSum.add(abs(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);\n\t  } else {\n\t    lambda00$1 = lambda, phi00$1 = phi;\n\t  }\n\t  areaStream.point(lambda, phi);\n\t  linePoint(lambda, phi);\n\t}\n\t\n\tfunction boundsRingStart() {\n\t  areaStream.lineStart();\n\t}\n\t\n\tfunction boundsRingEnd() {\n\t  boundsRingPoint(lambda00$1, phi00$1);\n\t  areaStream.lineEnd();\n\t  if (abs(deltaSum) > epsilon) lambda0$1 = -(lambda1 = 180);\n\t  range$1[0] = lambda0$1, range$1[1] = lambda1;\n\t  p0 = null;\n\t}\n\t\n\t// Finds the left-right distance between two longitudes.\n\t// This is almost the same as (lambda1 - lambda0 + 360°) % 360°, except that we want\n\t// the distance between ±180° to be 360°.\n\tfunction angle(lambda0, lambda1) {\n\t  return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;\n\t}\n\t\n\tfunction rangeCompare(a, b) {\n\t  return a[0] - b[0];\n\t}\n\t\n\tfunction rangeContains(range$$1, x) {\n\t  return range$$1[0] <= range$$1[1] ? range$$1[0] <= x && x <= range$$1[1] : x < range$$1[0] || range$$1[1] < x;\n\t}\n\t\n\tfunction bounds(feature) {\n\t  var i, n, a, b, merged, deltaMax, delta;\n\t\n\t  phi1 = lambda1 = -(lambda0$1 = phi0 = Infinity);\n\t  ranges = [];\n\t  geoStream(feature, boundsStream);\n\t\n\t  // First, sort ranges by their minimum longitudes.\n\t  if (n = ranges.length) {\n\t    ranges.sort(rangeCompare);\n\t\n\t    // Then, merge any ranges that overlap.\n\t    for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {\n\t      b = ranges[i];\n\t      if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {\n\t        if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];\n\t        if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];\n\t      } else {\n\t        merged.push(a = b);\n\t      }\n\t    }\n\t\n\t    // Finally, find the largest gap between the merged ranges.\n\t    // The final bounding box will be the inverse of this gap.\n\t    for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {\n\t      b = merged[i];\n\t      if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0$1 = b[0], lambda1 = a[1];\n\t    }\n\t  }\n\t\n\t  ranges = range$1 = null;\n\t\n\t  return lambda0$1 === Infinity || phi0 === Infinity\n\t      ? [[NaN, NaN], [NaN, NaN]]\n\t      : [[lambda0$1, phi0], [lambda1, phi1]];\n\t}\n\t\n\tvar W0;\n\tvar W1;\n\tvar X0;\n\tvar Y0;\n\tvar Z0;\n\tvar X1;\n\tvar Y1;\n\tvar Z1;\n\tvar X2;\n\tvar Y2;\n\tvar Z2;\n\tvar lambda00$2;\n\tvar phi00$2;\n\tvar x0;\n\tvar y0;\n\tvar z0; // previous point\n\t\n\tvar centroidStream = {\n\t  sphere: noop,\n\t  point: centroidPoint,\n\t  lineStart: centroidLineStart,\n\t  lineEnd: centroidLineEnd,\n\t  polygonStart: function() {\n\t    centroidStream.lineStart = centroidRingStart;\n\t    centroidStream.lineEnd = centroidRingEnd;\n\t  },\n\t  polygonEnd: function() {\n\t    centroidStream.lineStart = centroidLineStart;\n\t    centroidStream.lineEnd = centroidLineEnd;\n\t  }\n\t};\n\t\n\t// Arithmetic mean of Cartesian vectors.\n\tfunction centroidPoint(lambda, phi) {\n\t  lambda *= radians, phi *= radians;\n\t  var cosPhi = cos(phi);\n\t  centroidPointCartesian(cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi));\n\t}\n\t\n\tfunction centroidPointCartesian(x, y, z) {\n\t  ++W0;\n\t  X0 += (x - X0) / W0;\n\t  Y0 += (y - Y0) / W0;\n\t  Z0 += (z - Z0) / W0;\n\t}\n\t\n\tfunction centroidLineStart() {\n\t  centroidStream.point = centroidLinePointFirst;\n\t}\n\t\n\tfunction centroidLinePointFirst(lambda, phi) {\n\t  lambda *= radians, phi *= radians;\n\t  var cosPhi = cos(phi);\n\t  x0 = cosPhi * cos(lambda);\n\t  y0 = cosPhi * sin(lambda);\n\t  z0 = sin(phi);\n\t  centroidStream.point = centroidLinePoint;\n\t  centroidPointCartesian(x0, y0, z0);\n\t}\n\t\n\tfunction centroidLinePoint(lambda, phi) {\n\t  lambda *= radians, phi *= radians;\n\t  var cosPhi = cos(phi),\n\t      x = cosPhi * cos(lambda),\n\t      y = cosPhi * sin(lambda),\n\t      z = sin(phi),\n\t      w = atan2(sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);\n\t  W1 += w;\n\t  X1 += w * (x0 + (x0 = x));\n\t  Y1 += w * (y0 + (y0 = y));\n\t  Z1 += w * (z0 + (z0 = z));\n\t  centroidPointCartesian(x0, y0, z0);\n\t}\n\t\n\tfunction centroidLineEnd() {\n\t  centroidStream.point = centroidPoint;\n\t}\n\t\n\t// See J. E. Brock, The Inertia Tensor for a Spherical Triangle,\n\t// J. Applied Mechanics 42, 239 (1975).\n\tfunction centroidRingStart() {\n\t  centroidStream.point = centroidRingPointFirst;\n\t}\n\t\n\tfunction centroidRingEnd() {\n\t  centroidRingPoint(lambda00$2, phi00$2);\n\t  centroidStream.point = centroidPoint;\n\t}\n\t\n\tfunction centroidRingPointFirst(lambda, phi) {\n\t  lambda00$2 = lambda, phi00$2 = phi;\n\t  lambda *= radians, phi *= radians;\n\t  centroidStream.point = centroidRingPoint;\n\t  var cosPhi = cos(phi);\n\t  x0 = cosPhi * cos(lambda);\n\t  y0 = cosPhi * sin(lambda);\n\t  z0 = sin(phi);\n\t  centroidPointCartesian(x0, y0, z0);\n\t}\n\t\n\tfunction centroidRingPoint(lambda, phi) {\n\t  lambda *= radians, phi *= radians;\n\t  var cosPhi = cos(phi),\n\t      x = cosPhi * cos(lambda),\n\t      y = cosPhi * sin(lambda),\n\t      z = sin(phi),\n\t      cx = y0 * z - z0 * y,\n\t      cy = z0 * x - x0 * z,\n\t      cz = x0 * y - y0 * x,\n\t      m = sqrt(cx * cx + cy * cy + cz * cz),\n\t      w = asin(m), // line weight = angle\n\t      v = m && -w / m; // area weight multiplier\n\t  X2 += v * cx;\n\t  Y2 += v * cy;\n\t  Z2 += v * cz;\n\t  W1 += w;\n\t  X1 += w * (x0 + (x0 = x));\n\t  Y1 += w * (y0 + (y0 = y));\n\t  Z1 += w * (z0 + (z0 = z));\n\t  centroidPointCartesian(x0, y0, z0);\n\t}\n\t\n\tfunction centroid(object) {\n\t  W0 = W1 =\n\t  X0 = Y0 = Z0 =\n\t  X1 = Y1 = Z1 =\n\t  X2 = Y2 = Z2 = 0;\n\t  geoStream(object, centroidStream);\n\t\n\t  var x = X2,\n\t      y = Y2,\n\t      z = Z2,\n\t      m = x * x + y * y + z * z;\n\t\n\t  // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.\n\t  if (m < epsilon2) {\n\t    x = X1, y = Y1, z = Z1;\n\t    // If the feature has zero length, fall back to arithmetic mean of point vectors.\n\t    if (W1 < epsilon) x = X0, y = Y0, z = Z0;\n\t    m = x * x + y * y + z * z;\n\t    // If the feature still has an undefined ccentroid, then return.\n\t    if (m < epsilon2) return [NaN, NaN];\n\t  }\n\t\n\t  return [atan2(y, x) * degrees, asin(z / sqrt(m)) * degrees];\n\t}\n\t\n\tfunction constant(x) {\n\t  return function() {\n\t    return x;\n\t  };\n\t}\n\t\n\tfunction compose(a, b) {\n\t\n\t  function compose(x, y) {\n\t    return x = a(x, y), b(x[0], x[1]);\n\t  }\n\t\n\t  if (a.invert && b.invert) compose.invert = function(x, y) {\n\t    return x = b.invert(x, y), x && a.invert(x[0], x[1]);\n\t  };\n\t\n\t  return compose;\n\t}\n\t\n\tfunction rotationIdentity(lambda, phi) {\n\t  return [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];\n\t}\n\t\n\trotationIdentity.invert = rotationIdentity;\n\t\n\tfunction rotateRadians(deltaLambda, deltaPhi, deltaGamma) {\n\t  return (deltaLambda %= tau) ? (deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma))\n\t    : rotationLambda(deltaLambda))\n\t    : (deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma)\n\t    : rotationIdentity);\n\t}\n\t\n\tfunction forwardRotationLambda(deltaLambda) {\n\t  return function(lambda, phi) {\n\t    return lambda += deltaLambda, [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];\n\t  };\n\t}\n\t\n\tfunction rotationLambda(deltaLambda) {\n\t  var rotation = forwardRotationLambda(deltaLambda);\n\t  rotation.invert = forwardRotationLambda(-deltaLambda);\n\t  return rotation;\n\t}\n\t\n\tfunction rotationPhiGamma(deltaPhi, deltaGamma) {\n\t  var cosDeltaPhi = cos(deltaPhi),\n\t      sinDeltaPhi = sin(deltaPhi),\n\t      cosDeltaGamma = cos(deltaGamma),\n\t      sinDeltaGamma = sin(deltaGamma);\n\t\n\t  function rotation(lambda, phi) {\n\t    var cosPhi = cos(phi),\n\t        x = cos(lambda) * cosPhi,\n\t        y = sin(lambda) * cosPhi,\n\t        z = sin(phi),\n\t        k = z * cosDeltaPhi + x * sinDeltaPhi;\n\t    return [\n\t      atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),\n\t      asin(k * cosDeltaGamma + y * sinDeltaGamma)\n\t    ];\n\t  }\n\t\n\t  rotation.invert = function(lambda, phi) {\n\t    var cosPhi = cos(phi),\n\t        x = cos(lambda) * cosPhi,\n\t        y = sin(lambda) * cosPhi,\n\t        z = sin(phi),\n\t        k = z * cosDeltaGamma - y * sinDeltaGamma;\n\t    return [\n\t      atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),\n\t      asin(k * cosDeltaPhi - x * sinDeltaPhi)\n\t    ];\n\t  };\n\t\n\t  return rotation;\n\t}\n\t\n\tfunction rotation(rotate) {\n\t  rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);\n\t\n\t  function forward(coordinates) {\n\t    coordinates = rotate(coordinates[0] * radians, coordinates[1] * radians);\n\t    return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;\n\t  }\n\t\n\t  forward.invert = function(coordinates) {\n\t    coordinates = rotate.invert(coordinates[0] * radians, coordinates[1] * radians);\n\t    return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;\n\t  };\n\t\n\t  return forward;\n\t}\n\t\n\t// Generates a circle centered at [0°, 0°], with a given radius and precision.\n\tfunction circleStream(stream, radius, delta, direction, t0, t1) {\n\t  if (!delta) return;\n\t  var cosRadius = cos(radius),\n\t      sinRadius = sin(radius),\n\t      step = direction * delta;\n\t  if (t0 == null) {\n\t    t0 = radius + direction * tau;\n\t    t1 = radius - step / 2;\n\t  } else {\n\t    t0 = circleRadius(cosRadius, t0);\n\t    t1 = circleRadius(cosRadius, t1);\n\t    if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * tau;\n\t  }\n\t  for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {\n\t    point = spherical([cosRadius, -sinRadius * cos(t), -sinRadius * sin(t)]);\n\t    stream.point(point[0], point[1]);\n\t  }\n\t}\n\t\n\t// Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].\n\tfunction circleRadius(cosRadius, point) {\n\t  point = cartesian(point), point[0] -= cosRadius;\n\t  cartesianNormalizeInPlace(point);\n\t  var radius = acos(-point[1]);\n\t  return ((-point[2] < 0 ? -radius : radius) + tau - epsilon) % tau;\n\t}\n\t\n\tfunction circle() {\n\t  var center = constant([0, 0]),\n\t      radius = constant(90),\n\t      precision = constant(6),\n\t      ring,\n\t      rotate,\n\t      stream = {point: point};\n\t\n\t  function point(x, y) {\n\t    ring.push(x = rotate(x, y));\n\t    x[0] *= degrees, x[1] *= degrees;\n\t  }\n\t\n\t  function circle() {\n\t    var c = center.apply(this, arguments),\n\t        r = radius.apply(this, arguments) * radians,\n\t        p = precision.apply(this, arguments) * radians;\n\t    ring = [];\n\t    rotate = rotateRadians(-c[0] * radians, -c[1] * radians, 0).invert;\n\t    circleStream(stream, r, p, 1);\n\t    c = {type: \"Polygon\", coordinates: [ring]};\n\t    ring = rotate = null;\n\t    return c;\n\t  }\n\t\n\t  circle.center = function(_) {\n\t    return arguments.length ? (center = typeof _ === \"function\" ? _ : constant([+_[0], +_[1]]), circle) : center;\n\t  };\n\t\n\t  circle.radius = function(_) {\n\t    return arguments.length ? (radius = typeof _ === \"function\" ? _ : constant(+_), circle) : radius;\n\t  };\n\t\n\t  circle.precision = function(_) {\n\t    return arguments.length ? (precision = typeof _ === \"function\" ? _ : constant(+_), circle) : precision;\n\t  };\n\t\n\t  return circle;\n\t}\n\t\n\tfunction clipBuffer() {\n\t  var lines = [],\n\t      line;\n\t  return {\n\t    point: function(x, y) {\n\t      line.push([x, y]);\n\t    },\n\t    lineStart: function() {\n\t      lines.push(line = []);\n\t    },\n\t    lineEnd: noop,\n\t    rejoin: function() {\n\t      if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));\n\t    },\n\t    result: function() {\n\t      var result = lines;\n\t      lines = [];\n\t      line = null;\n\t      return result;\n\t    }\n\t  };\n\t}\n\t\n\tfunction pointEqual(a, b) {\n\t  return abs(a[0] - b[0]) < epsilon && abs(a[1] - b[1]) < epsilon;\n\t}\n\t\n\tfunction Intersection(point, points, other, entry) {\n\t  this.x = point;\n\t  this.z = points;\n\t  this.o = other; // another intersection\n\t  this.e = entry; // is an entry?\n\t  this.v = false; // visited\n\t  this.n = this.p = null; // next & previous\n\t}\n\t\n\t// A generalized polygon clipping algorithm: given a polygon that has been cut\n\t// into its visible line segments, and rejoins the segments by interpolating\n\t// along the clip edge.\n\tfunction clipRejoin(segments, compareIntersection, startInside, interpolate, stream) {\n\t  var subject = [],\n\t      clip = [],\n\t      i,\n\t      n;\n\t\n\t  segments.forEach(function(segment) {\n\t    if ((n = segment.length - 1) <= 0) return;\n\t    var n, p0 = segment[0], p1 = segment[n], x;\n\t\n\t    // If the first and last points of a segment are coincident, then treat as a\n\t    // closed ring. TODO if all rings are closed, then the winding order of the\n\t    // exterior ring should be checked.\n\t    if (pointEqual(p0, p1)) {\n\t      stream.lineStart();\n\t      for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);\n\t      stream.lineEnd();\n\t      return;\n\t    }\n\t\n\t    subject.push(x = new Intersection(p0, segment, null, true));\n\t    clip.push(x.o = new Intersection(p0, null, x, false));\n\t    subject.push(x = new Intersection(p1, segment, null, false));\n\t    clip.push(x.o = new Intersection(p1, null, x, true));\n\t  });\n\t\n\t  if (!subject.length) return;\n\t\n\t  clip.sort(compareIntersection);\n\t  link(subject);\n\t  link(clip);\n\t\n\t  for (i = 0, n = clip.length; i < n; ++i) {\n\t    clip[i].e = startInside = !startInside;\n\t  }\n\t\n\t  var start = subject[0],\n\t      points,\n\t      point;\n\t\n\t  while (1) {\n\t    // Find first unvisited intersection.\n\t    var current = start,\n\t        isSubject = true;\n\t    while (current.v) if ((current = current.n) === start) return;\n\t    points = current.z;\n\t    stream.lineStart();\n\t    do {\n\t      current.v = current.o.v = true;\n\t      if (current.e) {\n\t        if (isSubject) {\n\t          for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);\n\t        } else {\n\t          interpolate(current.x, current.n.x, 1, stream);\n\t        }\n\t        current = current.n;\n\t      } else {\n\t        if (isSubject) {\n\t          points = current.p.z;\n\t          for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);\n\t        } else {\n\t          interpolate(current.x, current.p.x, -1, stream);\n\t        }\n\t        current = current.p;\n\t      }\n\t      current = current.o;\n\t      points = current.z;\n\t      isSubject = !isSubject;\n\t    } while (!current.v);\n\t    stream.lineEnd();\n\t  }\n\t}\n\t\n\tfunction link(array) {\n\t  if (!(n = array.length)) return;\n\t  var n,\n\t      i = 0,\n\t      a = array[0],\n\t      b;\n\t  while (++i < n) {\n\t    a.n = b = array[i];\n\t    b.p = a;\n\t    a = b;\n\t  }\n\t  a.n = b = array[0];\n\t  b.p = a;\n\t}\n\t\n\tvar sum = adder();\n\t\n\tfunction polygonContains(polygon, point) {\n\t  var lambda = point[0],\n\t      phi = point[1],\n\t      sinPhi = sin(phi),\n\t      normal = [sin(lambda), -cos(lambda), 0],\n\t      angle = 0,\n\t      winding = 0;\n\t\n\t  sum.reset();\n\t\n\t  if (sinPhi === 1) phi = halfPi + epsilon;\n\t  else if (sinPhi === -1) phi = -halfPi - epsilon;\n\t\n\t  for (var i = 0, n = polygon.length; i < n; ++i) {\n\t    if (!(m = (ring = polygon[i]).length)) continue;\n\t    var ring,\n\t        m,\n\t        point0 = ring[m - 1],\n\t        lambda0 = point0[0],\n\t        phi0 = point0[1] / 2 + quarterPi,\n\t        sinPhi0 = sin(phi0),\n\t        cosPhi0 = cos(phi0);\n\t\n\t    for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {\n\t      var point1 = ring[j],\n\t          lambda1 = point1[0],\n\t          phi1 = point1[1] / 2 + quarterPi,\n\t          sinPhi1 = sin(phi1),\n\t          cosPhi1 = cos(phi1),\n\t          delta = lambda1 - lambda0,\n\t          sign$$1 = delta >= 0 ? 1 : -1,\n\t          absDelta = sign$$1 * delta,\n\t          antimeridian = absDelta > pi,\n\t          k = sinPhi0 * sinPhi1;\n\t\n\t      sum.add(atan2(k * sign$$1 * sin(absDelta), cosPhi0 * cosPhi1 + k * cos(absDelta)));\n\t      angle += antimeridian ? delta + sign$$1 * tau : delta;\n\t\n\t      // Are the longitudes either side of the point’s meridian (lambda),\n\t      // and are the latitudes smaller than the parallel (phi)?\n\t      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {\n\t        var arc = cartesianCross(cartesian(point0), cartesian(point1));\n\t        cartesianNormalizeInPlace(arc);\n\t        var intersection = cartesianCross(normal, arc);\n\t        cartesianNormalizeInPlace(intersection);\n\t        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);\n\t        if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {\n\t          winding += antimeridian ^ delta >= 0 ? 1 : -1;\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  // First, determine whether the South pole is inside or outside:\n\t  //\n\t  // It is inside if:\n\t  // * the polygon winds around it in a clockwise direction.\n\t  // * the polygon does not (cumulatively) wind around it, but has a negative\n\t  //   (counter-clockwise) area.\n\t  //\n\t  // Second, count the (signed) number of times a segment crosses a lambda\n\t  // from the point to the South pole.  If it is zero, then the point is the\n\t  // same side as the South pole.\n\t\n\t  return (angle < -epsilon || angle < epsilon && sum < -epsilon) ^ (winding & 1);\n\t}\n\t\n\tfunction clip(pointVisible, clipLine, interpolate, start) {\n\t  return function(sink) {\n\t    var line = clipLine(sink),\n\t        ringBuffer = clipBuffer(),\n\t        ringSink = clipLine(ringBuffer),\n\t        polygonStarted = false,\n\t        polygon,\n\t        segments,\n\t        ring;\n\t\n\t    var clip = {\n\t      point: point,\n\t      lineStart: lineStart,\n\t      lineEnd: lineEnd,\n\t      polygonStart: function() {\n\t        clip.point = pointRing;\n\t        clip.lineStart = ringStart;\n\t        clip.lineEnd = ringEnd;\n\t        segments = [];\n\t        polygon = [];\n\t      },\n\t      polygonEnd: function() {\n\t        clip.point = point;\n\t        clip.lineStart = lineStart;\n\t        clip.lineEnd = lineEnd;\n\t        segments = d3Array.merge(segments);\n\t        var startInside = polygonContains(polygon, start);\n\t        if (segments.length) {\n\t          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n\t          clipRejoin(segments, compareIntersection, startInside, interpolate, sink);\n\t        } else if (startInside) {\n\t          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n\t          sink.lineStart();\n\t          interpolate(null, null, 1, sink);\n\t          sink.lineEnd();\n\t        }\n\t        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;\n\t        segments = polygon = null;\n\t      },\n\t      sphere: function() {\n\t        sink.polygonStart();\n\t        sink.lineStart();\n\t        interpolate(null, null, 1, sink);\n\t        sink.lineEnd();\n\t        sink.polygonEnd();\n\t      }\n\t    };\n\t\n\t    function point(lambda, phi) {\n\t      if (pointVisible(lambda, phi)) sink.point(lambda, phi);\n\t    }\n\t\n\t    function pointLine(lambda, phi) {\n\t      line.point(lambda, phi);\n\t    }\n\t\n\t    function lineStart() {\n\t      clip.point = pointLine;\n\t      line.lineStart();\n\t    }\n\t\n\t    function lineEnd() {\n\t      clip.point = point;\n\t      line.lineEnd();\n\t    }\n\t\n\t    function pointRing(lambda, phi) {\n\t      ring.push([lambda, phi]);\n\t      ringSink.point(lambda, phi);\n\t    }\n\t\n\t    function ringStart() {\n\t      ringSink.lineStart();\n\t      ring = [];\n\t    }\n\t\n\t    function ringEnd() {\n\t      pointRing(ring[0][0], ring[0][1]);\n\t      ringSink.lineEnd();\n\t\n\t      var clean = ringSink.clean(),\n\t          ringSegments = ringBuffer.result(),\n\t          i, n = ringSegments.length, m,\n\t          segment,\n\t          point;\n\t\n\t      ring.pop();\n\t      polygon.push(ring);\n\t      ring = null;\n\t\n\t      if (!n) return;\n\t\n\t      // No intersections.\n\t      if (clean & 1) {\n\t        segment = ringSegments[0];\n\t        if ((m = segment.length - 1) > 0) {\n\t          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n\t          sink.lineStart();\n\t          for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);\n\t          sink.lineEnd();\n\t        }\n\t        return;\n\t      }\n\t\n\t      // Rejoin connected segments.\n\t      // TODO reuse ringBuffer.rejoin()?\n\t      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));\n\t\n\t      segments.push(ringSegments.filter(validSegment));\n\t    }\n\t\n\t    return clip;\n\t  };\n\t}\n\t\n\tfunction validSegment(segment) {\n\t  return segment.length > 1;\n\t}\n\t\n\t// Intersections are sorted along the clip edge. For both antimeridian cutting\n\t// and circle clipping, the same comparison is used.\n\tfunction compareIntersection(a, b) {\n\t  return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon : halfPi - a[1])\n\t       - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon : halfPi - b[1]);\n\t}\n\t\n\tvar clipAntimeridian = clip(\n\t  function() { return true; },\n\t  clipAntimeridianLine,\n\t  clipAntimeridianInterpolate,\n\t  [-pi, -halfPi]\n\t);\n\t\n\t// Takes a line and cuts into visible segments. Return values: 0 - there were\n\t// intersections or the line was empty; 1 - no intersections; 2 - there were\n\t// intersections, and the first and last segments should be rejoined.\n\tfunction clipAntimeridianLine(stream) {\n\t  var lambda0 = NaN,\n\t      phi0 = NaN,\n\t      sign0 = NaN,\n\t      clean; // no intersections\n\t\n\t  return {\n\t    lineStart: function() {\n\t      stream.lineStart();\n\t      clean = 1;\n\t    },\n\t    point: function(lambda1, phi1) {\n\t      var sign1 = lambda1 > 0 ? pi : -pi,\n\t          delta = abs(lambda1 - lambda0);\n\t      if (abs(delta - pi) < epsilon) { // line crosses a pole\n\t        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi : -halfPi);\n\t        stream.point(sign0, phi0);\n\t        stream.lineEnd();\n\t        stream.lineStart();\n\t        stream.point(sign1, phi0);\n\t        stream.point(lambda1, phi0);\n\t        clean = 0;\n\t      } else if (sign0 !== sign1 && delta >= pi) { // line crosses antimeridian\n\t        if (abs(lambda0 - sign0) < epsilon) lambda0 -= sign0 * epsilon; // handle degeneracies\n\t        if (abs(lambda1 - sign1) < epsilon) lambda1 -= sign1 * epsilon;\n\t        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);\n\t        stream.point(sign0, phi0);\n\t        stream.lineEnd();\n\t        stream.lineStart();\n\t        stream.point(sign1, phi0);\n\t        clean = 0;\n\t      }\n\t      stream.point(lambda0 = lambda1, phi0 = phi1);\n\t      sign0 = sign1;\n\t    },\n\t    lineEnd: function() {\n\t      stream.lineEnd();\n\t      lambda0 = phi0 = NaN;\n\t    },\n\t    clean: function() {\n\t      return 2 - clean; // if intersections, rejoin first and last segments\n\t    }\n\t  };\n\t}\n\t\n\tfunction clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {\n\t  var cosPhi0,\n\t      cosPhi1,\n\t      sinLambda0Lambda1 = sin(lambda0 - lambda1);\n\t  return abs(sinLambda0Lambda1) > epsilon\n\t      ? atan((sin(phi0) * (cosPhi1 = cos(phi1)) * sin(lambda1)\n\t          - sin(phi1) * (cosPhi0 = cos(phi0)) * sin(lambda0))\n\t          / (cosPhi0 * cosPhi1 * sinLambda0Lambda1))\n\t      : (phi0 + phi1) / 2;\n\t}\n\t\n\tfunction clipAntimeridianInterpolate(from, to, direction, stream) {\n\t  var phi;\n\t  if (from == null) {\n\t    phi = direction * halfPi;\n\t    stream.point(-pi, phi);\n\t    stream.point(0, phi);\n\t    stream.point(pi, phi);\n\t    stream.point(pi, 0);\n\t    stream.point(pi, -phi);\n\t    stream.point(0, -phi);\n\t    stream.point(-pi, -phi);\n\t    stream.point(-pi, 0);\n\t    stream.point(-pi, phi);\n\t  } else if (abs(from[0] - to[0]) > epsilon) {\n\t    var lambda = from[0] < to[0] ? pi : -pi;\n\t    phi = direction * lambda / 2;\n\t    stream.point(-lambda, phi);\n\t    stream.point(0, phi);\n\t    stream.point(lambda, phi);\n\t  } else {\n\t    stream.point(to[0], to[1]);\n\t  }\n\t}\n\t\n\tfunction clipCircle(radius) {\n\t  var cr = cos(radius),\n\t      delta = 6 * radians,\n\t      smallRadius = cr > 0,\n\t      notHemisphere = abs(cr) > epsilon; // TODO optimise for this common case\n\t\n\t  function interpolate(from, to, direction, stream) {\n\t    circleStream(stream, radius, delta, direction, from, to);\n\t  }\n\t\n\t  function visible(lambda, phi) {\n\t    return cos(lambda) * cos(phi) > cr;\n\t  }\n\t\n\t  // Takes a line and cuts into visible segments. Return values used for polygon\n\t  // clipping: 0 - there were intersections or the line was empty; 1 - no\n\t  // intersections 2 - there were intersections, and the first and last segments\n\t  // should be rejoined.\n\t  function clipLine(stream) {\n\t    var point0, // previous point\n\t        c0, // code for previous point\n\t        v0, // visibility of previous point\n\t        v00, // visibility of first point\n\t        clean; // no intersections\n\t    return {\n\t      lineStart: function() {\n\t        v00 = v0 = false;\n\t        clean = 1;\n\t      },\n\t      point: function(lambda, phi) {\n\t        var point1 = [lambda, phi],\n\t            point2,\n\t            v = visible(lambda, phi),\n\t            c = smallRadius\n\t              ? v ? 0 : code(lambda, phi)\n\t              : v ? code(lambda + (lambda < 0 ? pi : -pi), phi) : 0;\n\t        if (!point0 && (v00 = v0 = v)) stream.lineStart();\n\t        // Handle degeneracies.\n\t        // TODO ignore if not clipping polygons.\n\t        if (v !== v0) {\n\t          point2 = intersect(point0, point1);\n\t          if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2)) {\n\t            point1[0] += epsilon;\n\t            point1[1] += epsilon;\n\t            v = visible(point1[0], point1[1]);\n\t          }\n\t        }\n\t        if (v !== v0) {\n\t          clean = 0;\n\t          if (v) {\n\t            // outside going in\n\t            stream.lineStart();\n\t            point2 = intersect(point1, point0);\n\t            stream.point(point2[0], point2[1]);\n\t          } else {\n\t            // inside going out\n\t            point2 = intersect(point0, point1);\n\t            stream.point(point2[0], point2[1]);\n\t            stream.lineEnd();\n\t          }\n\t          point0 = point2;\n\t        } else if (notHemisphere && point0 && smallRadius ^ v) {\n\t          var t;\n\t          // If the codes for two points are different, or are both zero,\n\t          // and there this segment intersects with the small circle.\n\t          if (!(c & c0) && (t = intersect(point1, point0, true))) {\n\t            clean = 0;\n\t            if (smallRadius) {\n\t              stream.lineStart();\n\t              stream.point(t[0][0], t[0][1]);\n\t              stream.point(t[1][0], t[1][1]);\n\t              stream.lineEnd();\n\t            } else {\n\t              stream.point(t[1][0], t[1][1]);\n\t              stream.lineEnd();\n\t              stream.lineStart();\n\t              stream.point(t[0][0], t[0][1]);\n\t            }\n\t          }\n\t        }\n\t        if (v && (!point0 || !pointEqual(point0, point1))) {\n\t          stream.point(point1[0], point1[1]);\n\t        }\n\t        point0 = point1, v0 = v, c0 = c;\n\t      },\n\t      lineEnd: function() {\n\t        if (v0) stream.lineEnd();\n\t        point0 = null;\n\t      },\n\t      // Rejoin first and last segments if there were intersections and the first\n\t      // and last points were visible.\n\t      clean: function() {\n\t        return clean | ((v00 && v0) << 1);\n\t      }\n\t    };\n\t  }\n\t\n\t  // Intersects the great circle between a and b with the clip circle.\n\t  function intersect(a, b, two) {\n\t    var pa = cartesian(a),\n\t        pb = cartesian(b);\n\t\n\t    // We have two planes, n1.p = d1 and n2.p = d2.\n\t    // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 ⨯ n2).\n\t    var n1 = [1, 0, 0], // normal\n\t        n2 = cartesianCross(pa, pb),\n\t        n2n2 = cartesianDot(n2, n2),\n\t        n1n2 = n2[0], // cartesianDot(n1, n2),\n\t        determinant = n2n2 - n1n2 * n1n2;\n\t\n\t    // Two polar points.\n\t    if (!determinant) return !two && a;\n\t\n\t    var c1 =  cr * n2n2 / determinant,\n\t        c2 = -cr * n1n2 / determinant,\n\t        n1xn2 = cartesianCross(n1, n2),\n\t        A = cartesianScale(n1, c1),\n\t        B = cartesianScale(n2, c2);\n\t    cartesianAddInPlace(A, B);\n\t\n\t    // Solve |p(t)|^2 = 1.\n\t    var u = n1xn2,\n\t        w = cartesianDot(A, u),\n\t        uu = cartesianDot(u, u),\n\t        t2 = w * w - uu * (cartesianDot(A, A) - 1);\n\t\n\t    if (t2 < 0) return;\n\t\n\t    var t = sqrt(t2),\n\t        q = cartesianScale(u, (-w - t) / uu);\n\t    cartesianAddInPlace(q, A);\n\t    q = spherical(q);\n\t\n\t    if (!two) return q;\n\t\n\t    // Two intersection points.\n\t    var lambda0 = a[0],\n\t        lambda1 = b[0],\n\t        phi0 = a[1],\n\t        phi1 = b[1],\n\t        z;\n\t\n\t    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;\n\t\n\t    var delta = lambda1 - lambda0,\n\t        polar = abs(delta - pi) < epsilon,\n\t        meridian = polar || delta < epsilon;\n\t\n\t    if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;\n\t\n\t    // Check that the first point is between a and b.\n\t    if (meridian\n\t        ? polar\n\t          ? phi0 + phi1 > 0 ^ q[1] < (abs(q[0] - lambda0) < epsilon ? phi0 : phi1)\n\t          : phi0 <= q[1] && q[1] <= phi1\n\t        : delta > pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {\n\t      var q1 = cartesianScale(u, (-w + t) / uu);\n\t      cartesianAddInPlace(q1, A);\n\t      return [q, spherical(q1)];\n\t    }\n\t  }\n\t\n\t  // Generates a 4-bit vector representing the location of a point relative to\n\t  // the small circle's bounding box.\n\t  function code(lambda, phi) {\n\t    var r = smallRadius ? radius : pi - radius,\n\t        code = 0;\n\t    if (lambda < -r) code |= 1; // left\n\t    else if (lambda > r) code |= 2; // right\n\t    if (phi < -r) code |= 4; // below\n\t    else if (phi > r) code |= 8; // above\n\t    return code;\n\t  }\n\t\n\t  return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi, radius - pi]);\n\t}\n\t\n\tfunction clipLine(a, b, x0, y0, x1, y1) {\n\t  var ax = a[0],\n\t      ay = a[1],\n\t      bx = b[0],\n\t      by = b[1],\n\t      t0 = 0,\n\t      t1 = 1,\n\t      dx = bx - ax,\n\t      dy = by - ay,\n\t      r;\n\t\n\t  r = x0 - ax;\n\t  if (!dx && r > 0) return;\n\t  r /= dx;\n\t  if (dx < 0) {\n\t    if (r < t0) return;\n\t    if (r < t1) t1 = r;\n\t  } else if (dx > 0) {\n\t    if (r > t1) return;\n\t    if (r > t0) t0 = r;\n\t  }\n\t\n\t  r = x1 - ax;\n\t  if (!dx && r < 0) return;\n\t  r /= dx;\n\t  if (dx < 0) {\n\t    if (r > t1) return;\n\t    if (r > t0) t0 = r;\n\t  } else if (dx > 0) {\n\t    if (r < t0) return;\n\t    if (r < t1) t1 = r;\n\t  }\n\t\n\t  r = y0 - ay;\n\t  if (!dy && r > 0) return;\n\t  r /= dy;\n\t  if (dy < 0) {\n\t    if (r < t0) return;\n\t    if (r < t1) t1 = r;\n\t  } else if (dy > 0) {\n\t    if (r > t1) return;\n\t    if (r > t0) t0 = r;\n\t  }\n\t\n\t  r = y1 - ay;\n\t  if (!dy && r < 0) return;\n\t  r /= dy;\n\t  if (dy < 0) {\n\t    if (r > t1) return;\n\t    if (r > t0) t0 = r;\n\t  } else if (dy > 0) {\n\t    if (r < t0) return;\n\t    if (r < t1) t1 = r;\n\t  }\n\t\n\t  if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;\n\t  if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;\n\t  return true;\n\t}\n\t\n\tvar clipMax = 1e9;\n\tvar clipMin = -clipMax;\n\t\n\t// TODO Use d3-polygon’s polygonContains here for the ring check?\n\t// TODO Eliminate duplicate buffering in clipBuffer and polygon.push?\n\t\n\tfunction clipRectangle(x0, y0, x1, y1) {\n\t\n\t  function visible(x, y) {\n\t    return x0 <= x && x <= x1 && y0 <= y && y <= y1;\n\t  }\n\t\n\t  function interpolate(from, to, direction, stream) {\n\t    var a = 0, a1 = 0;\n\t    if (from == null\n\t        || (a = corner(from, direction)) !== (a1 = corner(to, direction))\n\t        || comparePoint(from, to) < 0 ^ direction > 0) {\n\t      do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);\n\t      while ((a = (a + direction + 4) % 4) !== a1);\n\t    } else {\n\t      stream.point(to[0], to[1]);\n\t    }\n\t  }\n\t\n\t  function corner(p, direction) {\n\t    return abs(p[0] - x0) < epsilon ? direction > 0 ? 0 : 3\n\t        : abs(p[0] - x1) < epsilon ? direction > 0 ? 2 : 1\n\t        : abs(p[1] - y0) < epsilon ? direction > 0 ? 1 : 0\n\t        : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon\n\t  }\n\t\n\t  function compareIntersection(a, b) {\n\t    return comparePoint(a.x, b.x);\n\t  }\n\t\n\t  function comparePoint(a, b) {\n\t    var ca = corner(a, 1),\n\t        cb = corner(b, 1);\n\t    return ca !== cb ? ca - cb\n\t        : ca === 0 ? b[1] - a[1]\n\t        : ca === 1 ? a[0] - b[0]\n\t        : ca === 2 ? a[1] - b[1]\n\t        : b[0] - a[0];\n\t  }\n\t\n\t  return function(stream) {\n\t    var activeStream = stream,\n\t        bufferStream = clipBuffer(),\n\t        segments,\n\t        polygon,\n\t        ring,\n\t        x__, y__, v__, // first point\n\t        x_, y_, v_, // previous point\n\t        first,\n\t        clean;\n\t\n\t    var clipStream = {\n\t      point: point,\n\t      lineStart: lineStart,\n\t      lineEnd: lineEnd,\n\t      polygonStart: polygonStart,\n\t      polygonEnd: polygonEnd\n\t    };\n\t\n\t    function point(x, y) {\n\t      if (visible(x, y)) activeStream.point(x, y);\n\t    }\n\t\n\t    function polygonInside() {\n\t      var winding = 0;\n\t\n\t      for (var i = 0, n = polygon.length; i < n; ++i) {\n\t        for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {\n\t          a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];\n\t          if (a1 <= y1) { if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding; }\n\t          else { if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding; }\n\t        }\n\t      }\n\t\n\t      return winding;\n\t    }\n\t\n\t    // Buffer geometry within a polygon and then clip it en masse.\n\t    function polygonStart() {\n\t      activeStream = bufferStream, segments = [], polygon = [], clean = true;\n\t    }\n\t\n\t    function polygonEnd() {\n\t      var startInside = polygonInside(),\n\t          cleanInside = clean && startInside,\n\t          visible = (segments = d3Array.merge(segments)).length;\n\t      if (cleanInside || visible) {\n\t        stream.polygonStart();\n\t        if (cleanInside) {\n\t          stream.lineStart();\n\t          interpolate(null, null, 1, stream);\n\t          stream.lineEnd();\n\t        }\n\t        if (visible) {\n\t          clipRejoin(segments, compareIntersection, startInside, interpolate, stream);\n\t        }\n\t        stream.polygonEnd();\n\t      }\n\t      activeStream = stream, segments = polygon = ring = null;\n\t    }\n\t\n\t    function lineStart() {\n\t      clipStream.point = linePoint;\n\t      if (polygon) polygon.push(ring = []);\n\t      first = true;\n\t      v_ = false;\n\t      x_ = y_ = NaN;\n\t    }\n\t\n\t    // TODO rather than special-case polygons, simply handle them separately.\n\t    // Ideally, coincident intersection points should be jittered to avoid\n\t    // clipping issues.\n\t    function lineEnd() {\n\t      if (segments) {\n\t        linePoint(x__, y__);\n\t        if (v__ && v_) bufferStream.rejoin();\n\t        segments.push(bufferStream.result());\n\t      }\n\t      clipStream.point = point;\n\t      if (v_) activeStream.lineEnd();\n\t    }\n\t\n\t    function linePoint(x, y) {\n\t      var v = visible(x, y);\n\t      if (polygon) ring.push([x, y]);\n\t      if (first) {\n\t        x__ = x, y__ = y, v__ = v;\n\t        first = false;\n\t        if (v) {\n\t          activeStream.lineStart();\n\t          activeStream.point(x, y);\n\t        }\n\t      } else {\n\t        if (v && v_) activeStream.point(x, y);\n\t        else {\n\t          var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],\n\t              b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];\n\t          if (clipLine(a, b, x0, y0, x1, y1)) {\n\t            if (!v_) {\n\t              activeStream.lineStart();\n\t              activeStream.point(a[0], a[1]);\n\t            }\n\t            activeStream.point(b[0], b[1]);\n\t            if (!v) activeStream.lineEnd();\n\t            clean = false;\n\t          } else if (v) {\n\t            activeStream.lineStart();\n\t            activeStream.point(x, y);\n\t            clean = false;\n\t          }\n\t        }\n\t      }\n\t      x_ = x, y_ = y, v_ = v;\n\t    }\n\t\n\t    return clipStream;\n\t  };\n\t}\n\t\n\tfunction extent() {\n\t  var x0 = 0,\n\t      y0 = 0,\n\t      x1 = 960,\n\t      y1 = 500,\n\t      cache,\n\t      cacheStream,\n\t      clip;\n\t\n\t  return clip = {\n\t    stream: function(stream) {\n\t      return cache && cacheStream === stream ? cache : cache = clipRectangle(x0, y0, x1, y1)(cacheStream = stream);\n\t    },\n\t    extent: function(_) {\n\t      return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [[x0, y0], [x1, y1]];\n\t    }\n\t  };\n\t}\n\t\n\tvar lengthSum = adder();\n\tvar lambda0$2;\n\tvar sinPhi0$1;\n\tvar cosPhi0$1;\n\t\n\tvar lengthStream = {\n\t  sphere: noop,\n\t  point: noop,\n\t  lineStart: lengthLineStart,\n\t  lineEnd: noop,\n\t  polygonStart: noop,\n\t  polygonEnd: noop\n\t};\n\t\n\tfunction lengthLineStart() {\n\t  lengthStream.point = lengthPointFirst;\n\t  lengthStream.lineEnd = lengthLineEnd;\n\t}\n\t\n\tfunction lengthLineEnd() {\n\t  lengthStream.point = lengthStream.lineEnd = noop;\n\t}\n\t\n\tfunction lengthPointFirst(lambda, phi) {\n\t  lambda *= radians, phi *= radians;\n\t  lambda0$2 = lambda, sinPhi0$1 = sin(phi), cosPhi0$1 = cos(phi);\n\t  lengthStream.point = lengthPoint;\n\t}\n\t\n\tfunction lengthPoint(lambda, phi) {\n\t  lambda *= radians, phi *= radians;\n\t  var sinPhi = sin(phi),\n\t      cosPhi = cos(phi),\n\t      delta = abs(lambda - lambda0$2),\n\t      cosDelta = cos(delta),\n\t      sinDelta = sin(delta),\n\t      x = cosPhi * sinDelta,\n\t      y = cosPhi0$1 * sinPhi - sinPhi0$1 * cosPhi * cosDelta,\n\t      z = sinPhi0$1 * sinPhi + cosPhi0$1 * cosPhi * cosDelta;\n\t  lengthSum.add(atan2(sqrt(x * x + y * y), z));\n\t  lambda0$2 = lambda, sinPhi0$1 = sinPhi, cosPhi0$1 = cosPhi;\n\t}\n\t\n\tfunction length(object) {\n\t  lengthSum.reset();\n\t  geoStream(object, lengthStream);\n\t  return +lengthSum;\n\t}\n\t\n\tvar coordinates = [null, null];\n\tvar object = {type: \"LineString\", coordinates: coordinates};\n\t\n\tfunction distance(a, b) {\n\t  coordinates[0] = a;\n\t  coordinates[1] = b;\n\t  return length(object);\n\t}\n\t\n\tvar containsObjectType = {\n\t  Feature: function(object, point) {\n\t    return containsGeometry(object.geometry, point);\n\t  },\n\t  FeatureCollection: function(object, point) {\n\t    var features = object.features, i = -1, n = features.length;\n\t    while (++i < n) if (containsGeometry(features[i].geometry, point)) return true;\n\t    return false;\n\t  }\n\t};\n\t\n\tvar containsGeometryType = {\n\t  Sphere: function() {\n\t    return true;\n\t  },\n\t  Point: function(object, point) {\n\t    return containsPoint(object.coordinates, point);\n\t  },\n\t  MultiPoint: function(object, point) {\n\t    var coordinates = object.coordinates, i = -1, n = coordinates.length;\n\t    while (++i < n) if (containsPoint(coordinates[i], point)) return true;\n\t    return false;\n\t  },\n\t  LineString: function(object, point) {\n\t    return containsLine(object.coordinates, point);\n\t  },\n\t  MultiLineString: function(object, point) {\n\t    var coordinates = object.coordinates, i = -1, n = coordinates.length;\n\t    while (++i < n) if (containsLine(coordinates[i], point)) return true;\n\t    return false;\n\t  },\n\t  Polygon: function(object, point) {\n\t    return containsPolygon(object.coordinates, point);\n\t  },\n\t  MultiPolygon: function(object, point) {\n\t    var coordinates = object.coordinates, i = -1, n = coordinates.length;\n\t    while (++i < n) if (containsPolygon(coordinates[i], point)) return true;\n\t    return false;\n\t  },\n\t  GeometryCollection: function(object, point) {\n\t    var geometries = object.geometries, i = -1, n = geometries.length;\n\t    while (++i < n) if (containsGeometry(geometries[i], point)) return true;\n\t    return false;\n\t  }\n\t};\n\t\n\tfunction containsGeometry(geometry, point) {\n\t  return geometry && containsGeometryType.hasOwnProperty(geometry.type)\n\t      ? containsGeometryType[geometry.type](geometry, point)\n\t      : false;\n\t}\n\t\n\tfunction containsPoint(coordinates, point) {\n\t  return distance(coordinates, point) === 0;\n\t}\n\t\n\tfunction containsLine(coordinates, point) {\n\t  var ab = distance(coordinates[0], coordinates[1]),\n\t      ao = distance(coordinates[0], point),\n\t      ob = distance(point, coordinates[1]);\n\t  return ao + ob <= ab + epsilon;\n\t}\n\t\n\tfunction containsPolygon(coordinates, point) {\n\t  return !!polygonContains(coordinates.map(ringRadians), pointRadians(point));\n\t}\n\t\n\tfunction ringRadians(ring) {\n\t  return ring = ring.map(pointRadians), ring.pop(), ring;\n\t}\n\t\n\tfunction pointRadians(point) {\n\t  return [point[0] * radians, point[1] * radians];\n\t}\n\t\n\tfunction contains(object, point) {\n\t  return (object && containsObjectType.hasOwnProperty(object.type)\n\t      ? containsObjectType[object.type]\n\t      : containsGeometry)(object, point);\n\t}\n\t\n\tfunction graticuleX(y0, y1, dy) {\n\t  var y = d3Array.range(y0, y1 - epsilon, dy).concat(y1);\n\t  return function(x) { return y.map(function(y) { return [x, y]; }); };\n\t}\n\t\n\tfunction graticuleY(x0, x1, dx) {\n\t  var x = d3Array.range(x0, x1 - epsilon, dx).concat(x1);\n\t  return function(y) { return x.map(function(x) { return [x, y]; }); };\n\t}\n\t\n\tfunction graticule() {\n\t  var x1, x0, X1, X0,\n\t      y1, y0, Y1, Y0,\n\t      dx = 10, dy = dx, DX = 90, DY = 360,\n\t      x, y, X, Y,\n\t      precision = 2.5;\n\t\n\t  function graticule() {\n\t    return {type: \"MultiLineString\", coordinates: lines()};\n\t  }\n\t\n\t  function lines() {\n\t    return d3Array.range(ceil(X0 / DX) * DX, X1, DX).map(X)\n\t        .concat(d3Array.range(ceil(Y0 / DY) * DY, Y1, DY).map(Y))\n\t        .concat(d3Array.range(ceil(x0 / dx) * dx, x1, dx).filter(function(x) { return abs(x % DX) > epsilon; }).map(x))\n\t        .concat(d3Array.range(ceil(y0 / dy) * dy, y1, dy).filter(function(y) { return abs(y % DY) > epsilon; }).map(y));\n\t  }\n\t\n\t  graticule.lines = function() {\n\t    return lines().map(function(coordinates) { return {type: \"LineString\", coordinates: coordinates}; });\n\t  };\n\t\n\t  graticule.outline = function() {\n\t    return {\n\t      type: \"Polygon\",\n\t      coordinates: [\n\t        X(X0).concat(\n\t        Y(Y1).slice(1),\n\t        X(X1).reverse().slice(1),\n\t        Y(Y0).reverse().slice(1))\n\t      ]\n\t    };\n\t  };\n\t\n\t  graticule.extent = function(_) {\n\t    if (!arguments.length) return graticule.extentMinor();\n\t    return graticule.extentMajor(_).extentMinor(_);\n\t  };\n\t\n\t  graticule.extentMajor = function(_) {\n\t    if (!arguments.length) return [[X0, Y0], [X1, Y1]];\n\t    X0 = +_[0][0], X1 = +_[1][0];\n\t    Y0 = +_[0][1], Y1 = +_[1][1];\n\t    if (X0 > X1) _ = X0, X0 = X1, X1 = _;\n\t    if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;\n\t    return graticule.precision(precision);\n\t  };\n\t\n\t  graticule.extentMinor = function(_) {\n\t    if (!arguments.length) return [[x0, y0], [x1, y1]];\n\t    x0 = +_[0][0], x1 = +_[1][0];\n\t    y0 = +_[0][1], y1 = +_[1][1];\n\t    if (x0 > x1) _ = x0, x0 = x1, x1 = _;\n\t    if (y0 > y1) _ = y0, y0 = y1, y1 = _;\n\t    return graticule.precision(precision);\n\t  };\n\t\n\t  graticule.step = function(_) {\n\t    if (!arguments.length) return graticule.stepMinor();\n\t    return graticule.stepMajor(_).stepMinor(_);\n\t  };\n\t\n\t  graticule.stepMajor = function(_) {\n\t    if (!arguments.length) return [DX, DY];\n\t    DX = +_[0], DY = +_[1];\n\t    return graticule;\n\t  };\n\t\n\t  graticule.stepMinor = function(_) {\n\t    if (!arguments.length) return [dx, dy];\n\t    dx = +_[0], dy = +_[1];\n\t    return graticule;\n\t  };\n\t\n\t  graticule.precision = function(_) {\n\t    if (!arguments.length) return precision;\n\t    precision = +_;\n\t    x = graticuleX(y0, y1, 90);\n\t    y = graticuleY(x0, x1, precision);\n\t    X = graticuleX(Y0, Y1, 90);\n\t    Y = graticuleY(X0, X1, precision);\n\t    return graticule;\n\t  };\n\t\n\t  return graticule\n\t      .extentMajor([[-180, -90 + epsilon], [180, 90 - epsilon]])\n\t      .extentMinor([[-180, -80 - epsilon], [180, 80 + epsilon]]);\n\t}\n\t\n\tfunction graticule10() {\n\t  return graticule()();\n\t}\n\t\n\tfunction interpolate(a, b) {\n\t  var x0 = a[0] * radians,\n\t      y0 = a[1] * radians,\n\t      x1 = b[0] * radians,\n\t      y1 = b[1] * radians,\n\t      cy0 = cos(y0),\n\t      sy0 = sin(y0),\n\t      cy1 = cos(y1),\n\t      sy1 = sin(y1),\n\t      kx0 = cy0 * cos(x0),\n\t      ky0 = cy0 * sin(x0),\n\t      kx1 = cy1 * cos(x1),\n\t      ky1 = cy1 * sin(x1),\n\t      d = 2 * asin(sqrt(haversin(y1 - y0) + cy0 * cy1 * haversin(x1 - x0))),\n\t      k = sin(d);\n\t\n\t  var interpolate = d ? function(t) {\n\t    var B = sin(t *= d) / k,\n\t        A = sin(d - t) / k,\n\t        x = A * kx0 + B * kx1,\n\t        y = A * ky0 + B * ky1,\n\t        z = A * sy0 + B * sy1;\n\t    return [\n\t      atan2(y, x) * degrees,\n\t      atan2(z, sqrt(x * x + y * y)) * degrees\n\t    ];\n\t  } : function() {\n\t    return [x0 * degrees, y0 * degrees];\n\t  };\n\t\n\t  interpolate.distance = d;\n\t\n\t  return interpolate;\n\t}\n\t\n\tfunction identity(x) {\n\t  return x;\n\t}\n\t\n\tvar areaSum$1 = adder();\n\tvar areaRingSum$1 = adder();\n\tvar x00;\n\tvar y00;\n\tvar x0$1;\n\tvar y0$1;\n\t\n\tvar areaStream$1 = {\n\t  point: noop,\n\t  lineStart: noop,\n\t  lineEnd: noop,\n\t  polygonStart: function() {\n\t    areaStream$1.lineStart = areaRingStart$1;\n\t    areaStream$1.lineEnd = areaRingEnd$1;\n\t  },\n\t  polygonEnd: function() {\n\t    areaStream$1.lineStart = areaStream$1.lineEnd = areaStream$1.point = noop;\n\t    areaSum$1.add(abs(areaRingSum$1));\n\t    areaRingSum$1.reset();\n\t  },\n\t  result: function() {\n\t    var area = areaSum$1 / 2;\n\t    areaSum$1.reset();\n\t    return area;\n\t  }\n\t};\n\t\n\tfunction areaRingStart$1() {\n\t  areaStream$1.point = areaPointFirst$1;\n\t}\n\t\n\tfunction areaPointFirst$1(x, y) {\n\t  areaStream$1.point = areaPoint$1;\n\t  x00 = x0$1 = x, y00 = y0$1 = y;\n\t}\n\t\n\tfunction areaPoint$1(x, y) {\n\t  areaRingSum$1.add(y0$1 * x - x0$1 * y);\n\t  x0$1 = x, y0$1 = y;\n\t}\n\t\n\tfunction areaRingEnd$1() {\n\t  areaPoint$1(x00, y00);\n\t}\n\t\n\tvar x0$2 = Infinity;\n\tvar y0$2 = x0$2;\n\tvar x1 = -x0$2;\n\tvar y1 = x1;\n\t\n\tvar boundsStream$1 = {\n\t  point: boundsPoint$1,\n\t  lineStart: noop,\n\t  lineEnd: noop,\n\t  polygonStart: noop,\n\t  polygonEnd: noop,\n\t  result: function() {\n\t    var bounds = [[x0$2, y0$2], [x1, y1]];\n\t    x1 = y1 = -(y0$2 = x0$2 = Infinity);\n\t    return bounds;\n\t  }\n\t};\n\t\n\tfunction boundsPoint$1(x, y) {\n\t  if (x < x0$2) x0$2 = x;\n\t  if (x > x1) x1 = x;\n\t  if (y < y0$2) y0$2 = y;\n\t  if (y > y1) y1 = y;\n\t}\n\t\n\t// TODO Enforce positive area for exterior, negative area for interior?\n\t\n\tvar X0$1 = 0;\n\tvar Y0$1 = 0;\n\tvar Z0$1 = 0;\n\tvar X1$1 = 0;\n\tvar Y1$1 = 0;\n\tvar Z1$1 = 0;\n\tvar X2$1 = 0;\n\tvar Y2$1 = 0;\n\tvar Z2$1 = 0;\n\tvar x00$1;\n\tvar y00$1;\n\tvar x0$3;\n\tvar y0$3;\n\t\n\tvar centroidStream$1 = {\n\t  point: centroidPoint$1,\n\t  lineStart: centroidLineStart$1,\n\t  lineEnd: centroidLineEnd$1,\n\t  polygonStart: function() {\n\t    centroidStream$1.lineStart = centroidRingStart$1;\n\t    centroidStream$1.lineEnd = centroidRingEnd$1;\n\t  },\n\t  polygonEnd: function() {\n\t    centroidStream$1.point = centroidPoint$1;\n\t    centroidStream$1.lineStart = centroidLineStart$1;\n\t    centroidStream$1.lineEnd = centroidLineEnd$1;\n\t  },\n\t  result: function() {\n\t    var centroid = Z2$1 ? [X2$1 / Z2$1, Y2$1 / Z2$1]\n\t        : Z1$1 ? [X1$1 / Z1$1, Y1$1 / Z1$1]\n\t        : Z0$1 ? [X0$1 / Z0$1, Y0$1 / Z0$1]\n\t        : [NaN, NaN];\n\t    X0$1 = Y0$1 = Z0$1 =\n\t    X1$1 = Y1$1 = Z1$1 =\n\t    X2$1 = Y2$1 = Z2$1 = 0;\n\t    return centroid;\n\t  }\n\t};\n\t\n\tfunction centroidPoint$1(x, y) {\n\t  X0$1 += x;\n\t  Y0$1 += y;\n\t  ++Z0$1;\n\t}\n\t\n\tfunction centroidLineStart$1() {\n\t  centroidStream$1.point = centroidPointFirstLine;\n\t}\n\t\n\tfunction centroidPointFirstLine(x, y) {\n\t  centroidStream$1.point = centroidPointLine;\n\t  centroidPoint$1(x0$3 = x, y0$3 = y);\n\t}\n\t\n\tfunction centroidPointLine(x, y) {\n\t  var dx = x - x0$3, dy = y - y0$3, z = sqrt(dx * dx + dy * dy);\n\t  X1$1 += z * (x0$3 + x) / 2;\n\t  Y1$1 += z * (y0$3 + y) / 2;\n\t  Z1$1 += z;\n\t  centroidPoint$1(x0$3 = x, y0$3 = y);\n\t}\n\t\n\tfunction centroidLineEnd$1() {\n\t  centroidStream$1.point = centroidPoint$1;\n\t}\n\t\n\tfunction centroidRingStart$1() {\n\t  centroidStream$1.point = centroidPointFirstRing;\n\t}\n\t\n\tfunction centroidRingEnd$1() {\n\t  centroidPointRing(x00$1, y00$1);\n\t}\n\t\n\tfunction centroidPointFirstRing(x, y) {\n\t  centroidStream$1.point = centroidPointRing;\n\t  centroidPoint$1(x00$1 = x0$3 = x, y00$1 = y0$3 = y);\n\t}\n\t\n\tfunction centroidPointRing(x, y) {\n\t  var dx = x - x0$3,\n\t      dy = y - y0$3,\n\t      z = sqrt(dx * dx + dy * dy);\n\t\n\t  X1$1 += z * (x0$3 + x) / 2;\n\t  Y1$1 += z * (y0$3 + y) / 2;\n\t  Z1$1 += z;\n\t\n\t  z = y0$3 * x - x0$3 * y;\n\t  X2$1 += z * (x0$3 + x);\n\t  Y2$1 += z * (y0$3 + y);\n\t  Z2$1 += z * 3;\n\t  centroidPoint$1(x0$3 = x, y0$3 = y);\n\t}\n\t\n\tfunction PathContext(context) {\n\t  this._context = context;\n\t}\n\t\n\tPathContext.prototype = {\n\t  _radius: 4.5,\n\t  pointRadius: function(_) {\n\t    return this._radius = _, this;\n\t  },\n\t  polygonStart: function() {\n\t    this._line = 0;\n\t  },\n\t  polygonEnd: function() {\n\t    this._line = NaN;\n\t  },\n\t  lineStart: function() {\n\t    this._point = 0;\n\t  },\n\t  lineEnd: function() {\n\t    if (this._line === 0) this._context.closePath();\n\t    this._point = NaN;\n\t  },\n\t  point: function(x, y) {\n\t    switch (this._point) {\n\t      case 0: {\n\t        this._context.moveTo(x, y);\n\t        this._point = 1;\n\t        break;\n\t      }\n\t      case 1: {\n\t        this._context.lineTo(x, y);\n\t        break;\n\t      }\n\t      default: {\n\t        this._context.moveTo(x + this._radius, y);\n\t        this._context.arc(x, y, this._radius, 0, tau);\n\t        break;\n\t      }\n\t    }\n\t  },\n\t  result: noop\n\t};\n\t\n\tvar lengthSum$1 = adder();\n\tvar lengthRing;\n\tvar x00$2;\n\tvar y00$2;\n\tvar x0$4;\n\tvar y0$4;\n\t\n\tvar lengthStream$1 = {\n\t  point: noop,\n\t  lineStart: function() {\n\t    lengthStream$1.point = lengthPointFirst$1;\n\t  },\n\t  lineEnd: function() {\n\t    if (lengthRing) lengthPoint$1(x00$2, y00$2);\n\t    lengthStream$1.point = noop;\n\t  },\n\t  polygonStart: function() {\n\t    lengthRing = true;\n\t  },\n\t  polygonEnd: function() {\n\t    lengthRing = null;\n\t  },\n\t  result: function() {\n\t    var length = +lengthSum$1;\n\t    lengthSum$1.reset();\n\t    return length;\n\t  }\n\t};\n\t\n\tfunction lengthPointFirst$1(x, y) {\n\t  lengthStream$1.point = lengthPoint$1;\n\t  x00$2 = x0$4 = x, y00$2 = y0$4 = y;\n\t}\n\t\n\tfunction lengthPoint$1(x, y) {\n\t  x0$4 -= x, y0$4 -= y;\n\t  lengthSum$1.add(sqrt(x0$4 * x0$4 + y0$4 * y0$4));\n\t  x0$4 = x, y0$4 = y;\n\t}\n\t\n\tfunction PathString() {\n\t  this._string = [];\n\t}\n\t\n\tPathString.prototype = {\n\t  _radius: 4.5,\n\t  _circle: circle$1(4.5),\n\t  pointRadius: function(_) {\n\t    if ((_ = +_) !== this._radius) this._radius = _, this._circle = null;\n\t    return this;\n\t  },\n\t  polygonStart: function() {\n\t    this._line = 0;\n\t  },\n\t  polygonEnd: function() {\n\t    this._line = NaN;\n\t  },\n\t  lineStart: function() {\n\t    this._point = 0;\n\t  },\n\t  lineEnd: function() {\n\t    if (this._line === 0) this._string.push(\"Z\");\n\t    this._point = NaN;\n\t  },\n\t  point: function(x, y) {\n\t    switch (this._point) {\n\t      case 0: {\n\t        this._string.push(\"M\", x, \",\", y);\n\t        this._point = 1;\n\t        break;\n\t      }\n\t      case 1: {\n\t        this._string.push(\"L\", x, \",\", y);\n\t        break;\n\t      }\n\t      default: {\n\t        if (this._circle == null) this._circle = circle$1(this._radius);\n\t        this._string.push(\"M\", x, \",\", y, this._circle);\n\t        break;\n\t      }\n\t    }\n\t  },\n\t  result: function() {\n\t    if (this._string.length) {\n\t      var result = this._string.join(\"\");\n\t      this._string = [];\n\t      return result;\n\t    } else {\n\t      return null;\n\t    }\n\t  }\n\t};\n\t\n\tfunction circle$1(radius) {\n\t  return \"m0,\" + radius\n\t      + \"a\" + radius + \",\" + radius + \" 0 1,1 0,\" + -2 * radius\n\t      + \"a\" + radius + \",\" + radius + \" 0 1,1 0,\" + 2 * radius\n\t      + \"z\";\n\t}\n\t\n\tfunction index(projection, context) {\n\t  var pointRadius = 4.5,\n\t      projectionStream,\n\t      contextStream;\n\t\n\t  function path(object) {\n\t    if (object) {\n\t      if (typeof pointRadius === \"function\") contextStream.pointRadius(+pointRadius.apply(this, arguments));\n\t      geoStream(object, projectionStream(contextStream));\n\t    }\n\t    return contextStream.result();\n\t  }\n\t\n\t  path.area = function(object) {\n\t    geoStream(object, projectionStream(areaStream$1));\n\t    return areaStream$1.result();\n\t  };\n\t\n\t  path.measure = function(object) {\n\t    geoStream(object, projectionStream(lengthStream$1));\n\t    return lengthStream$1.result();\n\t  };\n\t\n\t  path.bounds = function(object) {\n\t    geoStream(object, projectionStream(boundsStream$1));\n\t    return boundsStream$1.result();\n\t  };\n\t\n\t  path.centroid = function(object) {\n\t    geoStream(object, projectionStream(centroidStream$1));\n\t    return centroidStream$1.result();\n\t  };\n\t\n\t  path.projection = function(_) {\n\t    return arguments.length ? (projectionStream = _ == null ? (projection = null, identity) : (projection = _).stream, path) : projection;\n\t  };\n\t\n\t  path.context = function(_) {\n\t    if (!arguments.length) return context;\n\t    contextStream = _ == null ? (context = null, new PathString) : new PathContext(context = _);\n\t    if (typeof pointRadius !== \"function\") contextStream.pointRadius(pointRadius);\n\t    return path;\n\t  };\n\t\n\t  path.pointRadius = function(_) {\n\t    if (!arguments.length) return pointRadius;\n\t    pointRadius = typeof _ === \"function\" ? _ : (contextStream.pointRadius(+_), +_);\n\t    return path;\n\t  };\n\t\n\t  return path.projection(projection).context(context);\n\t}\n\t\n\tfunction transform(methods) {\n\t  return {\n\t    stream: transformer(methods)\n\t  };\n\t}\n\t\n\tfunction transformer(methods) {\n\t  return function(stream) {\n\t    var s = new TransformStream;\n\t    for (var key in methods) s[key] = methods[key];\n\t    s.stream = stream;\n\t    return s;\n\t  };\n\t}\n\t\n\tfunction TransformStream() {}\n\t\n\tTransformStream.prototype = {\n\t  constructor: TransformStream,\n\t  point: function(x, y) { this.stream.point(x, y); },\n\t  sphere: function() { this.stream.sphere(); },\n\t  lineStart: function() { this.stream.lineStart(); },\n\t  lineEnd: function() { this.stream.lineEnd(); },\n\t  polygonStart: function() { this.stream.polygonStart(); },\n\t  polygonEnd: function() { this.stream.polygonEnd(); }\n\t};\n\t\n\tfunction fit(projection, fitBounds, object) {\n\t  var clip = projection.clipExtent && projection.clipExtent();\n\t  projection.scale(150).translate([0, 0]);\n\t  if (clip != null) projection.clipExtent(null);\n\t  geoStream(object, projection.stream(boundsStream$1));\n\t  fitBounds(boundsStream$1.result());\n\t  if (clip != null) projection.clipExtent(clip);\n\t  return projection;\n\t}\n\t\n\tfunction fitExtent(projection, extent, object) {\n\t  return fit(projection, function(b) {\n\t    var w = extent[1][0] - extent[0][0],\n\t        h = extent[1][1] - extent[0][1],\n\t        k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),\n\t        x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,\n\t        y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;\n\t    projection.scale(150 * k).translate([x, y]);\n\t  }, object);\n\t}\n\t\n\tfunction fitSize(projection, size, object) {\n\t  return fitExtent(projection, [[0, 0], size], object);\n\t}\n\t\n\tfunction fitWidth(projection, width, object) {\n\t  return fit(projection, function(b) {\n\t    var w = +width,\n\t        k = w / (b[1][0] - b[0][0]),\n\t        x = (w - k * (b[1][0] + b[0][0])) / 2,\n\t        y = -k * b[0][1];\n\t    projection.scale(150 * k).translate([x, y]);\n\t  }, object);\n\t}\n\t\n\tfunction fitHeight(projection, height, object) {\n\t  return fit(projection, function(b) {\n\t    var h = +height,\n\t        k = h / (b[1][1] - b[0][1]),\n\t        x = -k * b[0][0],\n\t        y = (h - k * (b[1][1] + b[0][1])) / 2;\n\t    projection.scale(150 * k).translate([x, y]);\n\t  }, object);\n\t}\n\t\n\tvar maxDepth = 16;\n\tvar cosMinDistance = cos(30 * radians); // cos(minimum angular distance)\n\t\n\tfunction resample(project, delta2) {\n\t  return +delta2 ? resample$1(project, delta2) : resampleNone(project);\n\t}\n\t\n\tfunction resampleNone(project) {\n\t  return transformer({\n\t    point: function(x, y) {\n\t      x = project(x, y);\n\t      this.stream.point(x[0], x[1]);\n\t    }\n\t  });\n\t}\n\t\n\tfunction resample$1(project, delta2) {\n\t\n\t  function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {\n\t    var dx = x1 - x0,\n\t        dy = y1 - y0,\n\t        d2 = dx * dx + dy * dy;\n\t    if (d2 > 4 * delta2 && depth--) {\n\t      var a = a0 + a1,\n\t          b = b0 + b1,\n\t          c = c0 + c1,\n\t          m = sqrt(a * a + b * b + c * c),\n\t          phi2 = asin(c /= m),\n\t          lambda2 = abs(abs(c) - 1) < epsilon || abs(lambda0 - lambda1) < epsilon ? (lambda0 + lambda1) / 2 : atan2(b, a),\n\t          p = project(lambda2, phi2),\n\t          x2 = p[0],\n\t          y2 = p[1],\n\t          dx2 = x2 - x0,\n\t          dy2 = y2 - y0,\n\t          dz = dy * dx2 - dx * dy2;\n\t      if (dz * dz / d2 > delta2 // perpendicular projected distance\n\t          || abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end\n\t          || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) { // angular distance\n\t        resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);\n\t        stream.point(x2, y2);\n\t        resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);\n\t      }\n\t    }\n\t  }\n\t  return function(stream) {\n\t    var lambda00, x00, y00, a00, b00, c00, // first point\n\t        lambda0, x0, y0, a0, b0, c0; // previous point\n\t\n\t    var resampleStream = {\n\t      point: point,\n\t      lineStart: lineStart,\n\t      lineEnd: lineEnd,\n\t      polygonStart: function() { stream.polygonStart(); resampleStream.lineStart = ringStart; },\n\t      polygonEnd: function() { stream.polygonEnd(); resampleStream.lineStart = lineStart; }\n\t    };\n\t\n\t    function point(x, y) {\n\t      x = project(x, y);\n\t      stream.point(x[0], x[1]);\n\t    }\n\t\n\t    function lineStart() {\n\t      x0 = NaN;\n\t      resampleStream.point = linePoint;\n\t      stream.lineStart();\n\t    }\n\t\n\t    function linePoint(lambda, phi) {\n\t      var c = cartesian([lambda, phi]), p = project(lambda, phi);\n\t      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);\n\t      stream.point(x0, y0);\n\t    }\n\t\n\t    function lineEnd() {\n\t      resampleStream.point = point;\n\t      stream.lineEnd();\n\t    }\n\t\n\t    function ringStart() {\n\t      lineStart();\n\t      resampleStream.point = ringPoint;\n\t      resampleStream.lineEnd = ringEnd;\n\t    }\n\t\n\t    function ringPoint(lambda, phi) {\n\t      linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;\n\t      resampleStream.point = linePoint;\n\t    }\n\t\n\t    function ringEnd() {\n\t      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);\n\t      resampleStream.lineEnd = lineEnd;\n\t      lineEnd();\n\t    }\n\t\n\t    return resampleStream;\n\t  };\n\t}\n\t\n\tvar transformRadians = transformer({\n\t  point: function(x, y) {\n\t    this.stream.point(x * radians, y * radians);\n\t  }\n\t});\n\t\n\tfunction transformRotate(rotate) {\n\t  return transformer({\n\t    point: function(x, y) {\n\t      var r = rotate(x, y);\n\t      return this.stream.point(r[0], r[1]);\n\t    }\n\t  });\n\t}\n\t\n\tfunction scaleTranslate(k, dx, dy) {\n\t  function transform$$1(x, y) {\n\t    return [dx + k * x, dy - k * y];\n\t  }\n\t  transform$$1.invert = function(x, y) {\n\t    return [(x - dx) / k, (dy - y) / k];\n\t  };\n\t  return transform$$1;\n\t}\n\t\n\tfunction scaleTranslateRotate(k, dx, dy, alpha) {\n\t  var cosAlpha = cos(alpha),\n\t      sinAlpha = sin(alpha),\n\t      a = cosAlpha * k,\n\t      b = sinAlpha * k,\n\t      ai = cosAlpha / k,\n\t      bi = sinAlpha / k,\n\t      ci = (sinAlpha * dy - cosAlpha * dx) / k,\n\t      fi = (sinAlpha * dx + cosAlpha * dy) / k;\n\t  function transform$$1(x, y) {\n\t    return [a * x - b * y + dx, dy - b * x - a * y];\n\t  }\n\t  transform$$1.invert = function(x, y) {\n\t    return [ai * x - bi * y + ci, fi - bi * x - ai * y];\n\t  };\n\t  return transform$$1;\n\t}\n\t\n\tfunction projection(project) {\n\t  return projectionMutator(function() { return project; })();\n\t}\n\t\n\tfunction projectionMutator(projectAt) {\n\t  var project,\n\t      k = 150, // scale\n\t      x = 480, y = 250, // translate\n\t      lambda = 0, phi = 0, // center\n\t      deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, // pre-rotate\n\t      alpha = 0, // post-rotate\n\t      theta = null, preclip = clipAntimeridian, // pre-clip angle\n\t      x0 = null, y0, x1, y1, postclip = identity, // post-clip extent\n\t      delta2 = 0.5, // precision\n\t      projectResample,\n\t      projectTransform,\n\t      projectRotateTransform,\n\t      cache,\n\t      cacheStream;\n\t\n\t  function projection(point) {\n\t    return projectRotateTransform(point[0] * radians, point[1] * radians);\n\t  }\n\t\n\t  function invert(point) {\n\t    point = projectRotateTransform.invert(point[0], point[1]);\n\t    return point && [point[0] * degrees, point[1] * degrees];\n\t  }\n\t\n\t  projection.stream = function(stream) {\n\t    return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));\n\t  };\n\t\n\t  projection.preclip = function(_) {\n\t    return arguments.length ? (preclip = _, theta = undefined, reset()) : preclip;\n\t  };\n\t\n\t  projection.postclip = function(_) {\n\t    return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;\n\t  };\n\t\n\t  projection.clipAngle = function(_) {\n\t    return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees;\n\t  };\n\t\n\t  projection.clipExtent = function(_) {\n\t    return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];\n\t  };\n\t\n\t  projection.scale = function(_) {\n\t    return arguments.length ? (k = +_, recenter()) : k;\n\t  };\n\t\n\t  projection.translate = function(_) {\n\t    return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];\n\t  };\n\t\n\t  projection.center = function(_) {\n\t    return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees, phi * degrees];\n\t  };\n\t\n\t  projection.rotate = function(_) {\n\t    return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];\n\t  };\n\t\n\t  projection.angle = function(_) {\n\t    return arguments.length ? (alpha = _ % 360 * radians, recenter()) : alpha * degrees;\n\t  };\n\t\n\t  projection.precision = function(_) {\n\t    return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt(delta2);\n\t  };\n\t\n\t  projection.fitExtent = function(extent, object) {\n\t    return fitExtent(projection, extent, object);\n\t  };\n\t\n\t  projection.fitSize = function(size, object) {\n\t    return fitSize(projection, size, object);\n\t  };\n\t\n\t  projection.fitWidth = function(width, object) {\n\t    return fitWidth(projection, width, object);\n\t  };\n\t\n\t  projection.fitHeight = function(height, object) {\n\t    return fitHeight(projection, height, object);\n\t  };\n\t\n\t  function recenter() {\n\t    var center = scaleTranslateRotate(k, 0, 0, alpha).apply(null, project(lambda, phi)),\n\t        transform$$1 = (alpha ? scaleTranslateRotate : scaleTranslate)(k, x - center[0], y - center[1], alpha);\n\t    rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma);\n\t    projectTransform = compose(project, transform$$1);\n\t    projectRotateTransform = compose(rotate, projectTransform);\n\t    projectResample = resample(projectTransform, delta2);\n\t    return reset();\n\t  }\n\t\n\t  function reset() {\n\t    cache = cacheStream = null;\n\t    return projection;\n\t  }\n\t\n\t  return function() {\n\t    project = projectAt.apply(this, arguments);\n\t    projection.invert = project.invert && invert;\n\t    return recenter();\n\t  };\n\t}\n\t\n\tfunction conicProjection(projectAt) {\n\t  var phi0 = 0,\n\t      phi1 = pi / 3,\n\t      m = projectionMutator(projectAt),\n\t      p = m(phi0, phi1);\n\t\n\t  p.parallels = function(_) {\n\t    return arguments.length ? m(phi0 = _[0] * radians, phi1 = _[1] * radians) : [phi0 * degrees, phi1 * degrees];\n\t  };\n\t\n\t  return p;\n\t}\n\t\n\tfunction cylindricalEqualAreaRaw(phi0) {\n\t  var cosPhi0 = cos(phi0);\n\t\n\t  function forward(lambda, phi) {\n\t    return [lambda * cosPhi0, sin(phi) / cosPhi0];\n\t  }\n\t\n\t  forward.invert = function(x, y) {\n\t    return [x / cosPhi0, asin(y * cosPhi0)];\n\t  };\n\t\n\t  return forward;\n\t}\n\t\n\tfunction conicEqualAreaRaw(y0, y1) {\n\t  var sy0 = sin(y0), n = (sy0 + sin(y1)) / 2;\n\t\n\t  // Are the parallels symmetrical around the Equator?\n\t  if (abs(n) < epsilon) return cylindricalEqualAreaRaw(y0);\n\t\n\t  var c = 1 + sy0 * (2 * n - sy0), r0 = sqrt(c) / n;\n\t\n\t  function project(x, y) {\n\t    var r = sqrt(c - 2 * n * sin(y)) / n;\n\t    return [r * sin(x *= n), r0 - r * cos(x)];\n\t  }\n\t\n\t  project.invert = function(x, y) {\n\t    var r0y = r0 - y;\n\t    return [atan2(x, abs(r0y)) / n * sign(r0y), asin((c - (x * x + r0y * r0y) * n * n) / (2 * n))];\n\t  };\n\t\n\t  return project;\n\t}\n\t\n\tfunction conicEqualArea() {\n\t  return conicProjection(conicEqualAreaRaw)\n\t      .scale(155.424)\n\t      .center([0, 33.6442]);\n\t}\n\t\n\tfunction albers() {\n\t  return conicEqualArea()\n\t      .parallels([29.5, 45.5])\n\t      .scale(1070)\n\t      .translate([480, 250])\n\t      .rotate([96, 0])\n\t      .center([-0.6, 38.7]);\n\t}\n\t\n\t// The projections must have mutually exclusive clip regions on the sphere,\n\t// as this will avoid emitting interleaving lines and polygons.\n\tfunction multiplex(streams) {\n\t  var n = streams.length;\n\t  return {\n\t    point: function(x, y) { var i = -1; while (++i < n) streams[i].point(x, y); },\n\t    sphere: function() { var i = -1; while (++i < n) streams[i].sphere(); },\n\t    lineStart: function() { var i = -1; while (++i < n) streams[i].lineStart(); },\n\t    lineEnd: function() { var i = -1; while (++i < n) streams[i].lineEnd(); },\n\t    polygonStart: function() { var i = -1; while (++i < n) streams[i].polygonStart(); },\n\t    polygonEnd: function() { var i = -1; while (++i < n) streams[i].polygonEnd(); }\n\t  };\n\t}\n\t\n\t// A composite projection for the United States, configured by default for\n\t// 960×500. The projection also works quite well at 960×600 if you change the\n\t// scale to 1285 and adjust the translate accordingly. The set of standard\n\t// parallels for each region comes from USGS, which is published here:\n\t// http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers\n\tfunction albersUsa() {\n\t  var cache,\n\t      cacheStream,\n\t      lower48 = albers(), lower48Point,\n\t      alaska = conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, // EPSG:3338\n\t      hawaii = conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, // ESRI:102007\n\t      point, pointStream = {point: function(x, y) { point = [x, y]; }};\n\t\n\t  function albersUsa(coordinates) {\n\t    var x = coordinates[0], y = coordinates[1];\n\t    return point = null, (lower48Point.point(x, y), point)\n\t        || (alaskaPoint.point(x, y), point)\n\t        || (hawaiiPoint.point(x, y), point);\n\t  }\n\t\n\t  albersUsa.invert = function(coordinates) {\n\t    var k = lower48.scale(),\n\t        t = lower48.translate(),\n\t        x = (coordinates[0] - t[0]) / k,\n\t        y = (coordinates[1] - t[1]) / k;\n\t    return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska\n\t        : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii\n\t        : lower48).invert(coordinates);\n\t  };\n\t\n\t  albersUsa.stream = function(stream) {\n\t    return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);\n\t  };\n\t\n\t  albersUsa.precision = function(_) {\n\t    if (!arguments.length) return lower48.precision();\n\t    lower48.precision(_), alaska.precision(_), hawaii.precision(_);\n\t    return reset();\n\t  };\n\t\n\t  albersUsa.scale = function(_) {\n\t    if (!arguments.length) return lower48.scale();\n\t    lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);\n\t    return albersUsa.translate(lower48.translate());\n\t  };\n\t\n\t  albersUsa.translate = function(_) {\n\t    if (!arguments.length) return lower48.translate();\n\t    var k = lower48.scale(), x = +_[0], y = +_[1];\n\t\n\t    lower48Point = lower48\n\t        .translate(_)\n\t        .clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]])\n\t        .stream(pointStream);\n\t\n\t    alaskaPoint = alaska\n\t        .translate([x - 0.307 * k, y + 0.201 * k])\n\t        .clipExtent([[x - 0.425 * k + epsilon, y + 0.120 * k + epsilon], [x - 0.214 * k - epsilon, y + 0.234 * k - epsilon]])\n\t        .stream(pointStream);\n\t\n\t    hawaiiPoint = hawaii\n\t        .translate([x - 0.205 * k, y + 0.212 * k])\n\t        .clipExtent([[x - 0.214 * k + epsilon, y + 0.166 * k + epsilon], [x - 0.115 * k - epsilon, y + 0.234 * k - epsilon]])\n\t        .stream(pointStream);\n\t\n\t    return reset();\n\t  };\n\t\n\t  albersUsa.fitExtent = function(extent, object) {\n\t    return fitExtent(albersUsa, extent, object);\n\t  };\n\t\n\t  albersUsa.fitSize = function(size, object) {\n\t    return fitSize(albersUsa, size, object);\n\t  };\n\t\n\t  albersUsa.fitWidth = function(width, object) {\n\t    return fitWidth(albersUsa, width, object);\n\t  };\n\t\n\t  albersUsa.fitHeight = function(height, object) {\n\t    return fitHeight(albersUsa, height, object);\n\t  };\n\t\n\t  function reset() {\n\t    cache = cacheStream = null;\n\t    return albersUsa;\n\t  }\n\t\n\t  return albersUsa.scale(1070);\n\t}\n\t\n\tfunction azimuthalRaw(scale) {\n\t  return function(x, y) {\n\t    var cx = cos(x),\n\t        cy = cos(y),\n\t        k = scale(cx * cy);\n\t    return [\n\t      k * cy * sin(x),\n\t      k * sin(y)\n\t    ];\n\t  }\n\t}\n\t\n\tfunction azimuthalInvert(angle) {\n\t  return function(x, y) {\n\t    var z = sqrt(x * x + y * y),\n\t        c = angle(z),\n\t        sc = sin(c),\n\t        cc = cos(c);\n\t    return [\n\t      atan2(x * sc, z * cc),\n\t      asin(z && y * sc / z)\n\t    ];\n\t  }\n\t}\n\t\n\tvar azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {\n\t  return sqrt(2 / (1 + cxcy));\n\t});\n\t\n\tazimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {\n\t  return 2 * asin(z / 2);\n\t});\n\t\n\tfunction azimuthalEqualArea() {\n\t  return projection(azimuthalEqualAreaRaw)\n\t      .scale(124.75)\n\t      .clipAngle(180 - 1e-3);\n\t}\n\t\n\tvar azimuthalEquidistantRaw = azimuthalRaw(function(c) {\n\t  return (c = acos(c)) && c / sin(c);\n\t});\n\t\n\tazimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {\n\t  return z;\n\t});\n\t\n\tfunction azimuthalEquidistant() {\n\t  return projection(azimuthalEquidistantRaw)\n\t      .scale(79.4188)\n\t      .clipAngle(180 - 1e-3);\n\t}\n\t\n\tfunction mercatorRaw(lambda, phi) {\n\t  return [lambda, log(tan((halfPi + phi) / 2))];\n\t}\n\t\n\tmercatorRaw.invert = function(x, y) {\n\t  return [x, 2 * atan(exp(y)) - halfPi];\n\t};\n\t\n\tfunction mercator() {\n\t  return mercatorProjection(mercatorRaw)\n\t      .scale(961 / tau);\n\t}\n\t\n\tfunction mercatorProjection(project) {\n\t  var m = projection(project),\n\t      center = m.center,\n\t      scale = m.scale,\n\t      translate = m.translate,\n\t      clipExtent = m.clipExtent,\n\t      x0 = null, y0, x1, y1; // clip extent\n\t\n\t  m.scale = function(_) {\n\t    return arguments.length ? (scale(_), reclip()) : scale();\n\t  };\n\t\n\t  m.translate = function(_) {\n\t    return arguments.length ? (translate(_), reclip()) : translate();\n\t  };\n\t\n\t  m.center = function(_) {\n\t    return arguments.length ? (center(_), reclip()) : center();\n\t  };\n\t\n\t  m.clipExtent = function(_) {\n\t    return arguments.length ? (_ == null ? x0 = y0 = x1 = y1 = null : (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reclip()) : x0 == null ? null : [[x0, y0], [x1, y1]];\n\t  };\n\t\n\t  function reclip() {\n\t    var k = pi * scale(),\n\t        t = m(rotation(m.rotate()).invert([0, 0]));\n\t    return clipExtent(x0 == null\n\t        ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw\n\t        ? [[Math.max(t[0] - k, x0), y0], [Math.min(t[0] + k, x1), y1]]\n\t        : [[x0, Math.max(t[1] - k, y0)], [x1, Math.min(t[1] + k, y1)]]);\n\t  }\n\t\n\t  return reclip();\n\t}\n\t\n\tfunction tany(y) {\n\t  return tan((halfPi + y) / 2);\n\t}\n\t\n\tfunction conicConformalRaw(y0, y1) {\n\t  var cy0 = cos(y0),\n\t      n = y0 === y1 ? sin(y0) : log(cy0 / cos(y1)) / log(tany(y1) / tany(y0)),\n\t      f = cy0 * pow(tany(y0), n) / n;\n\t\n\t  if (!n) return mercatorRaw;\n\t\n\t  function project(x, y) {\n\t    if (f > 0) { if (y < -halfPi + epsilon) y = -halfPi + epsilon; }\n\t    else { if (y > halfPi - epsilon) y = halfPi - epsilon; }\n\t    var r = f / pow(tany(y), n);\n\t    return [r * sin(n * x), f - r * cos(n * x)];\n\t  }\n\t\n\t  project.invert = function(x, y) {\n\t    var fy = f - y, r = sign(n) * sqrt(x * x + fy * fy);\n\t    return [atan2(x, abs(fy)) / n * sign(fy), 2 * atan(pow(f / r, 1 / n)) - halfPi];\n\t  };\n\t\n\t  return project;\n\t}\n\t\n\tfunction conicConformal() {\n\t  return conicProjection(conicConformalRaw)\n\t      .scale(109.5)\n\t      .parallels([30, 30]);\n\t}\n\t\n\tfunction equirectangularRaw(lambda, phi) {\n\t  return [lambda, phi];\n\t}\n\t\n\tequirectangularRaw.invert = equirectangularRaw;\n\t\n\tfunction equirectangular() {\n\t  return projection(equirectangularRaw)\n\t      .scale(152.63);\n\t}\n\t\n\tfunction conicEquidistantRaw(y0, y1) {\n\t  var cy0 = cos(y0),\n\t      n = y0 === y1 ? sin(y0) : (cy0 - cos(y1)) / (y1 - y0),\n\t      g = cy0 / n + y0;\n\t\n\t  if (abs(n) < epsilon) return equirectangularRaw;\n\t\n\t  function project(x, y) {\n\t    var gy = g - y, nx = n * x;\n\t    return [gy * sin(nx), g - gy * cos(nx)];\n\t  }\n\t\n\t  project.invert = function(x, y) {\n\t    var gy = g - y;\n\t    return [atan2(x, abs(gy)) / n * sign(gy), g - sign(n) * sqrt(x * x + gy * gy)];\n\t  };\n\t\n\t  return project;\n\t}\n\t\n\tfunction conicEquidistant() {\n\t  return conicProjection(conicEquidistantRaw)\n\t      .scale(131.154)\n\t      .center([0, 13.9389]);\n\t}\n\t\n\tfunction gnomonicRaw(x, y) {\n\t  var cy = cos(y), k = cos(x) * cy;\n\t  return [cy * sin(x) / k, sin(y) / k];\n\t}\n\t\n\tgnomonicRaw.invert = azimuthalInvert(atan);\n\t\n\tfunction gnomonic() {\n\t  return projection(gnomonicRaw)\n\t      .scale(144.049)\n\t      .clipAngle(60);\n\t}\n\t\n\tfunction scaleTranslate$1(kx, ky, tx, ty) {\n\t  return kx === 1 && ky === 1 && tx === 0 && ty === 0 ? identity : transformer({\n\t    point: function(x, y) {\n\t      this.stream.point(x * kx + tx, y * ky + ty);\n\t    }\n\t  });\n\t}\n\t\n\tfunction identity$1() {\n\t  var k = 1, tx = 0, ty = 0, sx = 1, sy = 1, transform$$1 = identity, // scale, translate and reflect\n\t      x0 = null, y0, x1, y1, // clip extent\n\t      postclip = identity,\n\t      cache,\n\t      cacheStream,\n\t      projection;\n\t\n\t  function reset() {\n\t    cache = cacheStream = null;\n\t    return projection;\n\t  }\n\t\n\t  return projection = {\n\t    stream: function(stream) {\n\t      return cache && cacheStream === stream ? cache : cache = transform$$1(postclip(cacheStream = stream));\n\t    },\n\t    postclip: function(_) {\n\t      return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;\n\t    },\n\t    clipExtent: function(_) {\n\t      return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];\n\t    },\n\t    scale: function(_) {\n\t      return arguments.length ? (transform$$1 = scaleTranslate$1((k = +_) * sx, k * sy, tx, ty), reset()) : k;\n\t    },\n\t    translate: function(_) {\n\t      return arguments.length ? (transform$$1 = scaleTranslate$1(k * sx, k * sy, tx = +_[0], ty = +_[1]), reset()) : [tx, ty];\n\t    },\n\t    reflectX: function(_) {\n\t      return arguments.length ? (transform$$1 = scaleTranslate$1(k * (sx = _ ? -1 : 1), k * sy, tx, ty), reset()) : sx < 0;\n\t    },\n\t    reflectY: function(_) {\n\t      return arguments.length ? (transform$$1 = scaleTranslate$1(k * sx, k * (sy = _ ? -1 : 1), tx, ty), reset()) : sy < 0;\n\t    },\n\t    fitExtent: function(extent, object) {\n\t      return fitExtent(projection, extent, object);\n\t    },\n\t    fitSize: function(size, object) {\n\t      return fitSize(projection, size, object);\n\t    },\n\t    fitWidth: function(width, object) {\n\t      return fitWidth(projection, width, object);\n\t    },\n\t    fitHeight: function(height, object) {\n\t      return fitHeight(projection, height, object);\n\t    }\n\t  };\n\t}\n\t\n\tfunction naturalEarth1Raw(lambda, phi) {\n\t  var phi2 = phi * phi, phi4 = phi2 * phi2;\n\t  return [\n\t    lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (0.003971 * phi2 - 0.001529 * phi4))),\n\t    phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4)))\n\t  ];\n\t}\n\t\n\tnaturalEarth1Raw.invert = function(x, y) {\n\t  var phi = y, i = 25, delta;\n\t  do {\n\t    var phi2 = phi * phi, phi4 = phi2 * phi2;\n\t    phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4))) - y) /\n\t        (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 0.005916 * 11 * phi4)));\n\t  } while (abs(delta) > epsilon && --i > 0);\n\t  return [\n\t    x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (0.003971 - 0.001529 * phi2)))),\n\t    phi\n\t  ];\n\t};\n\t\n\tfunction naturalEarth1() {\n\t  return projection(naturalEarth1Raw)\n\t      .scale(175.295);\n\t}\n\t\n\tfunction orthographicRaw(x, y) {\n\t  return [cos(y) * sin(x), sin(y)];\n\t}\n\t\n\torthographicRaw.invert = azimuthalInvert(asin);\n\t\n\tfunction orthographic() {\n\t  return projection(orthographicRaw)\n\t      .scale(249.5)\n\t      .clipAngle(90 + epsilon);\n\t}\n\t\n\tfunction stereographicRaw(x, y) {\n\t  var cy = cos(y), k = 1 + cos(x) * cy;\n\t  return [cy * sin(x) / k, sin(y) / k];\n\t}\n\t\n\tstereographicRaw.invert = azimuthalInvert(function(z) {\n\t  return 2 * atan(z);\n\t});\n\t\n\tfunction stereographic() {\n\t  return projection(stereographicRaw)\n\t      .scale(250)\n\t      .clipAngle(142);\n\t}\n\t\n\tfunction transverseMercatorRaw(lambda, phi) {\n\t  return [log(tan((halfPi + phi) / 2)), -lambda];\n\t}\n\t\n\ttransverseMercatorRaw.invert = function(x, y) {\n\t  return [-y, 2 * atan(exp(x)) - halfPi];\n\t};\n\t\n\tfunction transverseMercator() {\n\t  var m = mercatorProjection(transverseMercatorRaw),\n\t      center = m.center,\n\t      rotate = m.rotate;\n\t\n\t  m.center = function(_) {\n\t    return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);\n\t  };\n\t\n\t  m.rotate = function(_) {\n\t    return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);\n\t  };\n\t\n\t  return rotate([0, 0, 90])\n\t      .scale(159.155);\n\t}\n\t\n\texports.geoArea = area;\n\texports.geoBounds = bounds;\n\texports.geoCentroid = centroid;\n\texports.geoCircle = circle;\n\texports.geoClipAntimeridian = clipAntimeridian;\n\texports.geoClipCircle = clipCircle;\n\texports.geoClipExtent = extent;\n\texports.geoClipRectangle = clipRectangle;\n\texports.geoContains = contains;\n\texports.geoDistance = distance;\n\texports.geoGraticule = graticule;\n\texports.geoGraticule10 = graticule10;\n\texports.geoInterpolate = interpolate;\n\texports.geoLength = length;\n\texports.geoPath = index;\n\texports.geoAlbers = albers;\n\texports.geoAlbersUsa = albersUsa;\n\texports.geoAzimuthalEqualArea = azimuthalEqualArea;\n\texports.geoAzimuthalEqualAreaRaw = azimuthalEqualAreaRaw;\n\texports.geoAzimuthalEquidistant = azimuthalEquidistant;\n\texports.geoAzimuthalEquidistantRaw = azimuthalEquidistantRaw;\n\texports.geoConicConformal = conicConformal;\n\texports.geoConicConformalRaw = conicConformalRaw;\n\texports.geoConicEqualArea = conicEqualArea;\n\texports.geoConicEqualAreaRaw = conicEqualAreaRaw;\n\texports.geoConicEquidistant = conicEquidistant;\n\texports.geoConicEquidistantRaw = conicEquidistantRaw;\n\texports.geoEquirectangular = equirectangular;\n\texports.geoEquirectangularRaw = equirectangularRaw;\n\texports.geoGnomonic = gnomonic;\n\texports.geoGnomonicRaw = gnomonicRaw;\n\texports.geoIdentity = identity$1;\n\texports.geoProjection = projection;\n\texports.geoProjectionMutator = projectionMutator;\n\texports.geoMercator = mercator;\n\texports.geoMercatorRaw = mercatorRaw;\n\texports.geoNaturalEarth1 = naturalEarth1;\n\texports.geoNaturalEarth1Raw = naturalEarth1Raw;\n\texports.geoOrthographic = orthographic;\n\texports.geoOrthographicRaw = orthographicRaw;\n\texports.geoStereographic = stereographic;\n\texports.geoStereographicRaw = stereographicRaw;\n\texports.geoTransverseMercator = transverseMercator;\n\texports.geoTransverseMercatorRaw = transverseMercatorRaw;\n\texports.geoRotation = rotation;\n\texports.geoStream = geoStream;\n\texports.geoTransform = transform;\n\t\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\t\n\t})));\n\n\n/***/ }),\n\n/***/ 192:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t// https://d3js.org/d3-timer/ Version 1.0.7. Copyright 2017 Mike Bostock.\n\t(function (global, factory) {\n\t\t true ? factory(exports) :\n\t\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t\t(factory((global.d3 = global.d3 || {})));\n\t}(this, (function (exports) { 'use strict';\n\t\n\tvar frame = 0;\n\tvar timeout = 0;\n\tvar interval = 0;\n\tvar pokeDelay = 1000;\n\tvar taskHead;\n\tvar taskTail;\n\tvar clockLast = 0;\n\tvar clockNow = 0;\n\tvar clockSkew = 0;\n\tvar clock = typeof performance === \"object\" && performance.now ? performance : Date;\n\tvar setFrame = typeof window === \"object\" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };\n\t\n\tfunction now() {\n\t  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);\n\t}\n\t\n\tfunction clearNow() {\n\t  clockNow = 0;\n\t}\n\t\n\tfunction Timer() {\n\t  this._call =\n\t  this._time =\n\t  this._next = null;\n\t}\n\t\n\tTimer.prototype = timer.prototype = {\n\t  constructor: Timer,\n\t  restart: function(callback, delay, time) {\n\t    if (typeof callback !== \"function\") throw new TypeError(\"callback is not a function\");\n\t    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);\n\t    if (!this._next && taskTail !== this) {\n\t      if (taskTail) taskTail._next = this;\n\t      else taskHead = this;\n\t      taskTail = this;\n\t    }\n\t    this._call = callback;\n\t    this._time = time;\n\t    sleep();\n\t  },\n\t  stop: function() {\n\t    if (this._call) {\n\t      this._call = null;\n\t      this._time = Infinity;\n\t      sleep();\n\t    }\n\t  }\n\t};\n\t\n\tfunction timer(callback, delay, time) {\n\t  var t = new Timer;\n\t  t.restart(callback, delay, time);\n\t  return t;\n\t}\n\t\n\tfunction timerFlush() {\n\t  now(); // Get the current time, if not already set.\n\t  ++frame; // Pretend we’ve set an alarm, if we haven’t already.\n\t  var t = taskHead, e;\n\t  while (t) {\n\t    if ((e = clockNow - t._time) >= 0) t._call.call(null, e);\n\t    t = t._next;\n\t  }\n\t  --frame;\n\t}\n\t\n\tfunction wake() {\n\t  clockNow = (clockLast = clock.now()) + clockSkew;\n\t  frame = timeout = 0;\n\t  try {\n\t    timerFlush();\n\t  } finally {\n\t    frame = 0;\n\t    nap();\n\t    clockNow = 0;\n\t  }\n\t}\n\t\n\tfunction poke() {\n\t  var now = clock.now(), delay = now - clockLast;\n\t  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;\n\t}\n\t\n\tfunction nap() {\n\t  var t0, t1 = taskHead, t2, time = Infinity;\n\t  while (t1) {\n\t    if (t1._call) {\n\t      if (time > t1._time) time = t1._time;\n\t      t0 = t1, t1 = t1._next;\n\t    } else {\n\t      t2 = t1._next, t1._next = null;\n\t      t1 = t0 ? t0._next = t2 : taskHead = t2;\n\t    }\n\t  }\n\t  taskTail = t0;\n\t  sleep(time);\n\t}\n\t\n\tfunction sleep(time) {\n\t  if (frame) return; // Soonest alarm already set, or will be.\n\t  if (timeout) timeout = clearTimeout(timeout);\n\t  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.\n\t  if (delay > 24) {\n\t    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);\n\t    if (interval) interval = clearInterval(interval);\n\t  } else {\n\t    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);\n\t    frame = 1, setFrame(wake);\n\t  }\n\t}\n\t\n\tvar timeout$1 = function(callback, delay, time) {\n\t  var t = new Timer;\n\t  delay = delay == null ? 0 : +delay;\n\t  t.restart(function(elapsed) {\n\t    t.stop();\n\t    callback(elapsed + delay);\n\t  }, delay, time);\n\t  return t;\n\t};\n\t\n\tvar interval$1 = function(callback, delay, time) {\n\t  var t = new Timer, total = delay;\n\t  if (delay == null) return t.restart(callback, delay, time), t;\n\t  delay = +delay, time = time == null ? now() : +time;\n\t  t.restart(function tick(elapsed) {\n\t    elapsed += total;\n\t    t.restart(tick, total += delay, time);\n\t    callback(elapsed);\n\t  }, delay, time);\n\t  return t;\n\t};\n\t\n\texports.now = now;\n\texports.timer = timer;\n\texports.timerFlush = timerFlush;\n\texports.timeout = timeout$1;\n\texports.interval = interval$1;\n\t\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\t\n\t})));\n\n\n/***/ }),\n\n/***/ 368:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t// https://d3js.org/d3-transition/ Version 1.1.1. Copyright 2017 Mike Bostock.\n\t(function (global, factory) {\n\t\t true ? factory(exports, __webpack_require__(21), __webpack_require__(68), __webpack_require__(192), __webpack_require__(100), __webpack_require__(189), __webpack_require__(362)) :\n\t\ttypeof define === 'function' && define.amd ? define(['exports', 'd3-selection', 'd3-dispatch', 'd3-timer', 'd3-interpolate', 'd3-color', 'd3-ease'], factory) :\n\t\t(factory((global.d3 = global.d3 || {}),global.d3,global.d3,global.d3,global.d3,global.d3,global.d3));\n\t}(this, (function (exports,d3Selection,d3Dispatch,d3Timer,d3Interpolate,d3Color,d3Ease) { 'use strict';\n\t\n\tvar emptyOn = d3Dispatch.dispatch(\"start\", \"end\", \"interrupt\");\n\tvar emptyTween = [];\n\t\n\tvar CREATED = 0;\n\tvar SCHEDULED = 1;\n\tvar STARTING = 2;\n\tvar STARTED = 3;\n\tvar RUNNING = 4;\n\tvar ENDING = 5;\n\tvar ENDED = 6;\n\t\n\tvar schedule = function(node, name, id, index, group, timing) {\n\t  var schedules = node.__transition;\n\t  if (!schedules) node.__transition = {};\n\t  else if (id in schedules) return;\n\t  create(node, id, {\n\t    name: name,\n\t    index: index, // For context during callback.\n\t    group: group, // For context during callback.\n\t    on: emptyOn,\n\t    tween: emptyTween,\n\t    time: timing.time,\n\t    delay: timing.delay,\n\t    duration: timing.duration,\n\t    ease: timing.ease,\n\t    timer: null,\n\t    state: CREATED\n\t  });\n\t};\n\t\n\tfunction init(node, id) {\n\t  var schedule = get(node, id);\n\t  if (schedule.state > CREATED) throw new Error(\"too late; already scheduled\");\n\t  return schedule;\n\t}\n\t\n\tfunction set(node, id) {\n\t  var schedule = get(node, id);\n\t  if (schedule.state > STARTING) throw new Error(\"too late; already started\");\n\t  return schedule;\n\t}\n\t\n\tfunction get(node, id) {\n\t  var schedule = node.__transition;\n\t  if (!schedule || !(schedule = schedule[id])) throw new Error(\"transition not found\");\n\t  return schedule;\n\t}\n\t\n\tfunction create(node, id, self) {\n\t  var schedules = node.__transition,\n\t      tween;\n\t\n\t  // Initialize the self timer when the transition is created.\n\t  // Note the actual delay is not known until the first callback!\n\t  schedules[id] = self;\n\t  self.timer = d3Timer.timer(schedule, 0, self.time);\n\t\n\t  function schedule(elapsed) {\n\t    self.state = SCHEDULED;\n\t    self.timer.restart(start, self.delay, self.time);\n\t\n\t    // If the elapsed delay is less than our first sleep, start immediately.\n\t    if (self.delay <= elapsed) start(elapsed - self.delay);\n\t  }\n\t\n\t  function start(elapsed) {\n\t    var i, j, n, o;\n\t\n\t    // If the state is not SCHEDULED, then we previously errored on start.\n\t    if (self.state !== SCHEDULED) return stop();\n\t\n\t    for (i in schedules) {\n\t      o = schedules[i];\n\t      if (o.name !== self.name) continue;\n\t\n\t      // While this element already has a starting transition during this frame,\n\t      // defer starting an interrupting transition until that transition has a\n\t      // chance to tick (and possibly end); see d3/d3-transition#54!\n\t      if (o.state === STARTED) return d3Timer.timeout(start);\n\t\n\t      // Interrupt the active transition, if any.\n\t      // Dispatch the interrupt event.\n\t      if (o.state === RUNNING) {\n\t        o.state = ENDED;\n\t        o.timer.stop();\n\t        o.on.call(\"interrupt\", node, node.__data__, o.index, o.group);\n\t        delete schedules[i];\n\t      }\n\t\n\t      // Cancel any pre-empted transitions. No interrupt event is dispatched\n\t      // because the cancelled transitions never started. Note that this also\n\t      // removes this transition from the pending list!\n\t      else if (+i < id) {\n\t        o.state = ENDED;\n\t        o.timer.stop();\n\t        delete schedules[i];\n\t      }\n\t    }\n\t\n\t    // Defer the first tick to end of the current frame; see d3/d3#1576.\n\t    // Note the transition may be canceled after start and before the first tick!\n\t    // Note this must be scheduled before the start event; see d3/d3-transition#16!\n\t    // Assuming this is successful, subsequent callbacks go straight to tick.\n\t    d3Timer.timeout(function() {\n\t      if (self.state === STARTED) {\n\t        self.state = RUNNING;\n\t        self.timer.restart(tick, self.delay, self.time);\n\t        tick(elapsed);\n\t      }\n\t    });\n\t\n\t    // Dispatch the start event.\n\t    // Note this must be done before the tween are initialized.\n\t    self.state = STARTING;\n\t    self.on.call(\"start\", node, node.__data__, self.index, self.group);\n\t    if (self.state !== STARTING) return; // interrupted\n\t    self.state = STARTED;\n\t\n\t    // Initialize the tween, deleting null tween.\n\t    tween = new Array(n = self.tween.length);\n\t    for (i = 0, j = -1; i < n; ++i) {\n\t      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {\n\t        tween[++j] = o;\n\t      }\n\t    }\n\t    tween.length = j + 1;\n\t  }\n\t\n\t  function tick(elapsed) {\n\t    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),\n\t        i = -1,\n\t        n = tween.length;\n\t\n\t    while (++i < n) {\n\t      tween[i].call(null, t);\n\t    }\n\t\n\t    // Dispatch the end event.\n\t    if (self.state === ENDING) {\n\t      self.on.call(\"end\", node, node.__data__, self.index, self.group);\n\t      stop();\n\t    }\n\t  }\n\t\n\t  function stop() {\n\t    self.state = ENDED;\n\t    self.timer.stop();\n\t    delete schedules[id];\n\t    for (var i in schedules) return; // eslint-disable-line no-unused-vars\n\t    delete node.__transition;\n\t  }\n\t}\n\t\n\tvar interrupt = function(node, name) {\n\t  var schedules = node.__transition,\n\t      schedule,\n\t      active,\n\t      empty = true,\n\t      i;\n\t\n\t  if (!schedules) return;\n\t\n\t  name = name == null ? null : name + \"\";\n\t\n\t  for (i in schedules) {\n\t    if ((schedule = schedules[i]).name !== name) { empty = false; continue; }\n\t    active = schedule.state > STARTING && schedule.state < ENDING;\n\t    schedule.state = ENDED;\n\t    schedule.timer.stop();\n\t    if (active) schedule.on.call(\"interrupt\", node, node.__data__, schedule.index, schedule.group);\n\t    delete schedules[i];\n\t  }\n\t\n\t  if (empty) delete node.__transition;\n\t};\n\t\n\tvar selection_interrupt = function(name) {\n\t  return this.each(function() {\n\t    interrupt(this, name);\n\t  });\n\t};\n\t\n\tfunction tweenRemove(id, name) {\n\t  var tween0, tween1;\n\t  return function() {\n\t    var schedule = set(this, id),\n\t        tween = schedule.tween;\n\t\n\t    // If this node shared tween with the previous node,\n\t    // just assign the updated shared tween and we’re done!\n\t    // Otherwise, copy-on-write.\n\t    if (tween !== tween0) {\n\t      tween1 = tween0 = tween;\n\t      for (var i = 0, n = tween1.length; i < n; ++i) {\n\t        if (tween1[i].name === name) {\n\t          tween1 = tween1.slice();\n\t          tween1.splice(i, 1);\n\t          break;\n\t        }\n\t      }\n\t    }\n\t\n\t    schedule.tween = tween1;\n\t  };\n\t}\n\t\n\tfunction tweenFunction(id, name, value) {\n\t  var tween0, tween1;\n\t  if (typeof value !== \"function\") throw new Error;\n\t  return function() {\n\t    var schedule = set(this, id),\n\t        tween = schedule.tween;\n\t\n\t    // If this node shared tween with the previous node,\n\t    // just assign the updated shared tween and we’re done!\n\t    // Otherwise, copy-on-write.\n\t    if (tween !== tween0) {\n\t      tween1 = (tween0 = tween).slice();\n\t      for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {\n\t        if (tween1[i].name === name) {\n\t          tween1[i] = t;\n\t          break;\n\t        }\n\t      }\n\t      if (i === n) tween1.push(t);\n\t    }\n\t\n\t    schedule.tween = tween1;\n\t  };\n\t}\n\t\n\tvar transition_tween = function(name, value) {\n\t  var id = this._id;\n\t\n\t  name += \"\";\n\t\n\t  if (arguments.length < 2) {\n\t    var tween = get(this.node(), id).tween;\n\t    for (var i = 0, n = tween.length, t; i < n; ++i) {\n\t      if ((t = tween[i]).name === name) {\n\t        return t.value;\n\t      }\n\t    }\n\t    return null;\n\t  }\n\t\n\t  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));\n\t};\n\t\n\tfunction tweenValue(transition, name, value) {\n\t  var id = transition._id;\n\t\n\t  transition.each(function() {\n\t    var schedule = set(this, id);\n\t    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);\n\t  });\n\t\n\t  return function(node) {\n\t    return get(node, id).value[name];\n\t  };\n\t}\n\t\n\tvar interpolate = function(a, b) {\n\t  var c;\n\t  return (typeof b === \"number\" ? d3Interpolate.interpolateNumber\n\t      : b instanceof d3Color.color ? d3Interpolate.interpolateRgb\n\t      : (c = d3Color.color(b)) ? (b = c, d3Interpolate.interpolateRgb)\n\t      : d3Interpolate.interpolateString)(a, b);\n\t};\n\t\n\tfunction attrRemove(name) {\n\t  return function() {\n\t    this.removeAttribute(name);\n\t  };\n\t}\n\t\n\tfunction attrRemoveNS(fullname) {\n\t  return function() {\n\t    this.removeAttributeNS(fullname.space, fullname.local);\n\t  };\n\t}\n\t\n\tfunction attrConstant(name, interpolate$$1, value1) {\n\t  var value00,\n\t      interpolate0;\n\t  return function() {\n\t    var value0 = this.getAttribute(name);\n\t    return value0 === value1 ? null\n\t        : value0 === value00 ? interpolate0\n\t        : interpolate0 = interpolate$$1(value00 = value0, value1);\n\t  };\n\t}\n\t\n\tfunction attrConstantNS(fullname, interpolate$$1, value1) {\n\t  var value00,\n\t      interpolate0;\n\t  return function() {\n\t    var value0 = this.getAttributeNS(fullname.space, fullname.local);\n\t    return value0 === value1 ? null\n\t        : value0 === value00 ? interpolate0\n\t        : interpolate0 = interpolate$$1(value00 = value0, value1);\n\t  };\n\t}\n\t\n\tfunction attrFunction(name, interpolate$$1, value) {\n\t  var value00,\n\t      value10,\n\t      interpolate0;\n\t  return function() {\n\t    var value0, value1 = value(this);\n\t    if (value1 == null) return void this.removeAttribute(name);\n\t    value0 = this.getAttribute(name);\n\t    return value0 === value1 ? null\n\t        : value0 === value00 && value1 === value10 ? interpolate0\n\t        : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);\n\t  };\n\t}\n\t\n\tfunction attrFunctionNS(fullname, interpolate$$1, value) {\n\t  var value00,\n\t      value10,\n\t      interpolate0;\n\t  return function() {\n\t    var value0, value1 = value(this);\n\t    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);\n\t    value0 = this.getAttributeNS(fullname.space, fullname.local);\n\t    return value0 === value1 ? null\n\t        : value0 === value00 && value1 === value10 ? interpolate0\n\t        : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);\n\t  };\n\t}\n\t\n\tvar transition_attr = function(name, value) {\n\t  var fullname = d3Selection.namespace(name), i = fullname === \"transform\" ? d3Interpolate.interpolateTransformSvg : interpolate;\n\t  return this.attrTween(name, typeof value === \"function\"\n\t      ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, tweenValue(this, \"attr.\" + name, value))\n\t      : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname)\n\t      : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value + \"\"));\n\t};\n\t\n\tfunction attrTweenNS(fullname, value) {\n\t  function tween() {\n\t    var node = this, i = value.apply(node, arguments);\n\t    return i && function(t) {\n\t      node.setAttributeNS(fullname.space, fullname.local, i(t));\n\t    };\n\t  }\n\t  tween._value = value;\n\t  return tween;\n\t}\n\t\n\tfunction attrTween(name, value) {\n\t  function tween() {\n\t    var node = this, i = value.apply(node, arguments);\n\t    return i && function(t) {\n\t      node.setAttribute(name, i(t));\n\t    };\n\t  }\n\t  tween._value = value;\n\t  return tween;\n\t}\n\t\n\tvar transition_attrTween = function(name, value) {\n\t  var key = \"attr.\" + name;\n\t  if (arguments.length < 2) return (key = this.tween(key)) && key._value;\n\t  if (value == null) return this.tween(key, null);\n\t  if (typeof value !== \"function\") throw new Error;\n\t  var fullname = d3Selection.namespace(name);\n\t  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));\n\t};\n\t\n\tfunction delayFunction(id, value) {\n\t  return function() {\n\t    init(this, id).delay = +value.apply(this, arguments);\n\t  };\n\t}\n\t\n\tfunction delayConstant(id, value) {\n\t  return value = +value, function() {\n\t    init(this, id).delay = value;\n\t  };\n\t}\n\t\n\tvar transition_delay = function(value) {\n\t  var id = this._id;\n\t\n\t  return arguments.length\n\t      ? this.each((typeof value === \"function\"\n\t          ? delayFunction\n\t          : delayConstant)(id, value))\n\t      : get(this.node(), id).delay;\n\t};\n\t\n\tfunction durationFunction(id, value) {\n\t  return function() {\n\t    set(this, id).duration = +value.apply(this, arguments);\n\t  };\n\t}\n\t\n\tfunction durationConstant(id, value) {\n\t  return value = +value, function() {\n\t    set(this, id).duration = value;\n\t  };\n\t}\n\t\n\tvar transition_duration = function(value) {\n\t  var id = this._id;\n\t\n\t  return arguments.length\n\t      ? this.each((typeof value === \"function\"\n\t          ? durationFunction\n\t          : durationConstant)(id, value))\n\t      : get(this.node(), id).duration;\n\t};\n\t\n\tfunction easeConstant(id, value) {\n\t  if (typeof value !== \"function\") throw new Error;\n\t  return function() {\n\t    set(this, id).ease = value;\n\t  };\n\t}\n\t\n\tvar transition_ease = function(value) {\n\t  var id = this._id;\n\t\n\t  return arguments.length\n\t      ? this.each(easeConstant(id, value))\n\t      : get(this.node(), id).ease;\n\t};\n\t\n\tvar transition_filter = function(match) {\n\t  if (typeof match !== \"function\") match = d3Selection.matcher(match);\n\t\n\t  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {\n\t    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {\n\t      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {\n\t        subgroup.push(node);\n\t      }\n\t    }\n\t  }\n\t\n\t  return new Transition(subgroups, this._parents, this._name, this._id);\n\t};\n\t\n\tvar transition_merge = function(transition) {\n\t  if (transition._id !== this._id) throw new Error;\n\t\n\t  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {\n\t    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {\n\t      if (node = group0[i] || group1[i]) {\n\t        merge[i] = node;\n\t      }\n\t    }\n\t  }\n\t\n\t  for (; j < m0; ++j) {\n\t    merges[j] = groups0[j];\n\t  }\n\t\n\t  return new Transition(merges, this._parents, this._name, this._id);\n\t};\n\t\n\tfunction start(name) {\n\t  return (name + \"\").trim().split(/^|\\s+/).every(function(t) {\n\t    var i = t.indexOf(\".\");\n\t    if (i >= 0) t = t.slice(0, i);\n\t    return !t || t === \"start\";\n\t  });\n\t}\n\t\n\tfunction onFunction(id, name, listener) {\n\t  var on0, on1, sit = start(name) ? init : set;\n\t  return function() {\n\t    var schedule = sit(this, id),\n\t        on = schedule.on;\n\t\n\t    // If this node shared a dispatch with the previous node,\n\t    // just assign the updated shared dispatch and we’re done!\n\t    // Otherwise, copy-on-write.\n\t    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);\n\t\n\t    schedule.on = on1;\n\t  };\n\t}\n\t\n\tvar transition_on = function(name, listener) {\n\t  var id = this._id;\n\t\n\t  return arguments.length < 2\n\t      ? get(this.node(), id).on.on(name)\n\t      : this.each(onFunction(id, name, listener));\n\t};\n\t\n\tfunction removeFunction(id) {\n\t  return function() {\n\t    var parent = this.parentNode;\n\t    for (var i in this.__transition) if (+i !== id) return;\n\t    if (parent) parent.removeChild(this);\n\t  };\n\t}\n\t\n\tvar transition_remove = function() {\n\t  return this.on(\"end.remove\", removeFunction(this._id));\n\t};\n\t\n\tvar transition_select = function(select) {\n\t  var name = this._name,\n\t      id = this._id;\n\t\n\t  if (typeof select !== \"function\") select = d3Selection.selector(select);\n\t\n\t  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {\n\t    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {\n\t      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {\n\t        if (\"__data__\" in node) subnode.__data__ = node.__data__;\n\t        subgroup[i] = subnode;\n\t        schedule(subgroup[i], name, id, i, subgroup, get(node, id));\n\t      }\n\t    }\n\t  }\n\t\n\t  return new Transition(subgroups, this._parents, name, id);\n\t};\n\t\n\tvar transition_selectAll = function(select) {\n\t  var name = this._name,\n\t      id = this._id;\n\t\n\t  if (typeof select !== \"function\") select = d3Selection.selectorAll(select);\n\t\n\t  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {\n\t    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {\n\t      if (node = group[i]) {\n\t        for (var children = select.call(node, node.__data__, i, group), child, inherit = get(node, id), k = 0, l = children.length; k < l; ++k) {\n\t          if (child = children[k]) {\n\t            schedule(child, name, id, k, children, inherit);\n\t          }\n\t        }\n\t        subgroups.push(children);\n\t        parents.push(node);\n\t      }\n\t    }\n\t  }\n\t\n\t  return new Transition(subgroups, parents, name, id);\n\t};\n\t\n\tvar Selection = d3Selection.selection.prototype.constructor;\n\t\n\tvar transition_selection = function() {\n\t  return new Selection(this._groups, this._parents);\n\t};\n\t\n\tfunction styleRemove(name, interpolate$$1) {\n\t  var value00,\n\t      value10,\n\t      interpolate0;\n\t  return function() {\n\t    var value0 = d3Selection.style(this, name),\n\t        value1 = (this.style.removeProperty(name), d3Selection.style(this, name));\n\t    return value0 === value1 ? null\n\t        : value0 === value00 && value1 === value10 ? interpolate0\n\t        : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);\n\t  };\n\t}\n\t\n\tfunction styleRemoveEnd(name) {\n\t  return function() {\n\t    this.style.removeProperty(name);\n\t  };\n\t}\n\t\n\tfunction styleConstant(name, interpolate$$1, value1) {\n\t  var value00,\n\t      interpolate0;\n\t  return function() {\n\t    var value0 = d3Selection.style(this, name);\n\t    return value0 === value1 ? null\n\t        : value0 === value00 ? interpolate0\n\t        : interpolate0 = interpolate$$1(value00 = value0, value1);\n\t  };\n\t}\n\t\n\tfunction styleFunction(name, interpolate$$1, value) {\n\t  var value00,\n\t      value10,\n\t      interpolate0;\n\t  return function() {\n\t    var value0 = d3Selection.style(this, name),\n\t        value1 = value(this);\n\t    if (value1 == null) value1 = (this.style.removeProperty(name), d3Selection.style(this, name));\n\t    return value0 === value1 ? null\n\t        : value0 === value00 && value1 === value10 ? interpolate0\n\t        : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);\n\t  };\n\t}\n\t\n\tvar transition_style = function(name, value, priority) {\n\t  var i = (name += \"\") === \"transform\" ? d3Interpolate.interpolateTransformCss : interpolate;\n\t  return value == null ? this\n\t          .styleTween(name, styleRemove(name, i))\n\t          .on(\"end.style.\" + name, styleRemoveEnd(name))\n\t      : this.styleTween(name, typeof value === \"function\"\n\t          ? styleFunction(name, i, tweenValue(this, \"style.\" + name, value))\n\t          : styleConstant(name, i, value + \"\"), priority);\n\t};\n\t\n\tfunction styleTween(name, value, priority) {\n\t  function tween() {\n\t    var node = this, i = value.apply(node, arguments);\n\t    return i && function(t) {\n\t      node.style.setProperty(name, i(t), priority);\n\t    };\n\t  }\n\t  tween._value = value;\n\t  return tween;\n\t}\n\t\n\tvar transition_styleTween = function(name, value, priority) {\n\t  var key = \"style.\" + (name += \"\");\n\t  if (arguments.length < 2) return (key = this.tween(key)) && key._value;\n\t  if (value == null) return this.tween(key, null);\n\t  if (typeof value !== \"function\") throw new Error;\n\t  return this.tween(key, styleTween(name, value, priority == null ? \"\" : priority));\n\t};\n\t\n\tfunction textConstant(value) {\n\t  return function() {\n\t    this.textContent = value;\n\t  };\n\t}\n\t\n\tfunction textFunction(value) {\n\t  return function() {\n\t    var value1 = value(this);\n\t    this.textContent = value1 == null ? \"\" : value1;\n\t  };\n\t}\n\t\n\tvar transition_text = function(value) {\n\t  return this.tween(\"text\", typeof value === \"function\"\n\t      ? textFunction(tweenValue(this, \"text\", value))\n\t      : textConstant(value == null ? \"\" : value + \"\"));\n\t};\n\t\n\tvar transition_transition = function() {\n\t  var name = this._name,\n\t      id0 = this._id,\n\t      id1 = newId();\n\t\n\t  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {\n\t    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {\n\t      if (node = group[i]) {\n\t        var inherit = get(node, id0);\n\t        schedule(node, name, id1, i, group, {\n\t          time: inherit.time + inherit.delay + inherit.duration,\n\t          delay: 0,\n\t          duration: inherit.duration,\n\t          ease: inherit.ease\n\t        });\n\t      }\n\t    }\n\t  }\n\t\n\t  return new Transition(groups, this._parents, name, id1);\n\t};\n\t\n\tvar id = 0;\n\t\n\tfunction Transition(groups, parents, name, id) {\n\t  this._groups = groups;\n\t  this._parents = parents;\n\t  this._name = name;\n\t  this._id = id;\n\t}\n\t\n\tfunction transition(name) {\n\t  return d3Selection.selection().transition(name);\n\t}\n\t\n\tfunction newId() {\n\t  return ++id;\n\t}\n\t\n\tvar selection_prototype = d3Selection.selection.prototype;\n\t\n\tTransition.prototype = transition.prototype = {\n\t  constructor: Transition,\n\t  select: transition_select,\n\t  selectAll: transition_selectAll,\n\t  filter: transition_filter,\n\t  merge: transition_merge,\n\t  selection: transition_selection,\n\t  transition: transition_transition,\n\t  call: selection_prototype.call,\n\t  nodes: selection_prototype.nodes,\n\t  node: selection_prototype.node,\n\t  size: selection_prototype.size,\n\t  empty: selection_prototype.empty,\n\t  each: selection_prototype.each,\n\t  on: transition_on,\n\t  attr: transition_attr,\n\t  attrTween: transition_attrTween,\n\t  style: transition_style,\n\t  styleTween: transition_styleTween,\n\t  text: transition_text,\n\t  remove: transition_remove,\n\t  tween: transition_tween,\n\t  delay: transition_delay,\n\t  duration: transition_duration,\n\t  ease: transition_ease\n\t};\n\t\n\tvar defaultTiming = {\n\t  time: null, // Set on use.\n\t  delay: 0,\n\t  duration: 250,\n\t  ease: d3Ease.easeCubicInOut\n\t};\n\t\n\tfunction inherit(node, id) {\n\t  var timing;\n\t  while (!(timing = node.__transition) || !(timing = timing[id])) {\n\t    if (!(node = node.parentNode)) {\n\t      return defaultTiming.time = d3Timer.now(), defaultTiming;\n\t    }\n\t  }\n\t  return timing;\n\t}\n\t\n\tvar selection_transition = function(name) {\n\t  var id,\n\t      timing;\n\t\n\t  if (name instanceof Transition) {\n\t    id = name._id, name = name._name;\n\t  } else {\n\t    id = newId(), (timing = defaultTiming).time = d3Timer.now(), name = name == null ? null : name + \"\";\n\t  }\n\t\n\t  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {\n\t    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {\n\t      if (node = group[i]) {\n\t        schedule(node, name, id, i, group, timing || inherit(node, id));\n\t      }\n\t    }\n\t  }\n\t\n\t  return new Transition(groups, this._parents, name, id);\n\t};\n\t\n\td3Selection.selection.prototype.interrupt = selection_interrupt;\n\td3Selection.selection.prototype.transition = selection_transition;\n\t\n\tvar root = [null];\n\t\n\tvar active = function(node, name) {\n\t  var schedules = node.__transition,\n\t      schedule,\n\t      i;\n\t\n\t  if (schedules) {\n\t    name = name == null ? null : name + \"\";\n\t    for (i in schedules) {\n\t      if ((schedule = schedules[i]).state > SCHEDULED && schedule.name === name) {\n\t        return new Transition([[node]], root, name, +i);\n\t      }\n\t    }\n\t  }\n\t\n\t  return null;\n\t};\n\t\n\texports.transition = transition;\n\texports.active = active;\n\texports.interrupt = interrupt;\n\t\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\t\n\t})));\n\n\n/***/ }),\n\n/***/ 369:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t// https://d3js.org/d3-zoom/ Version 1.7.1. Copyright 2017 Mike Bostock.\n\t(function (global, factory) {\n\t\t true ? factory(exports, __webpack_require__(68), __webpack_require__(190), __webpack_require__(100), __webpack_require__(21), __webpack_require__(368)) :\n\t\ttypeof define === 'function' && define.amd ? define(['exports', 'd3-dispatch', 'd3-drag', 'd3-interpolate', 'd3-selection', 'd3-transition'], factory) :\n\t\t(factory((global.d3 = global.d3 || {}),global.d3,global.d3,global.d3,global.d3,global.d3));\n\t}(this, (function (exports,d3Dispatch,d3Drag,d3Interpolate,d3Selection,d3Transition) { 'use strict';\n\t\n\tvar constant = function(x) {\n\t  return function() {\n\t    return x;\n\t  };\n\t};\n\t\n\tfunction ZoomEvent(target, type, transform) {\n\t  this.target = target;\n\t  this.type = type;\n\t  this.transform = transform;\n\t}\n\t\n\tfunction Transform(k, x, y) {\n\t  this.k = k;\n\t  this.x = x;\n\t  this.y = y;\n\t}\n\t\n\tTransform.prototype = {\n\t  constructor: Transform,\n\t  scale: function(k) {\n\t    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);\n\t  },\n\t  translate: function(x, y) {\n\t    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);\n\t  },\n\t  apply: function(point) {\n\t    return [point[0] * this.k + this.x, point[1] * this.k + this.y];\n\t  },\n\t  applyX: function(x) {\n\t    return x * this.k + this.x;\n\t  },\n\t  applyY: function(y) {\n\t    return y * this.k + this.y;\n\t  },\n\t  invert: function(location) {\n\t    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];\n\t  },\n\t  invertX: function(x) {\n\t    return (x - this.x) / this.k;\n\t  },\n\t  invertY: function(y) {\n\t    return (y - this.y) / this.k;\n\t  },\n\t  rescaleX: function(x) {\n\t    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));\n\t  },\n\t  rescaleY: function(y) {\n\t    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));\n\t  },\n\t  toString: function() {\n\t    return \"translate(\" + this.x + \",\" + this.y + \") scale(\" + this.k + \")\";\n\t  }\n\t};\n\t\n\tvar identity = new Transform(1, 0, 0);\n\t\n\ttransform.prototype = Transform.prototype;\n\t\n\tfunction transform(node) {\n\t  return node.__zoom || identity;\n\t}\n\t\n\tfunction nopropagation() {\n\t  d3Selection.event.stopImmediatePropagation();\n\t}\n\t\n\tvar noevent = function() {\n\t  d3Selection.event.preventDefault();\n\t  d3Selection.event.stopImmediatePropagation();\n\t};\n\t\n\t// Ignore right-click, since that should open the context menu.\n\tfunction defaultFilter() {\n\t  return !d3Selection.event.button;\n\t}\n\t\n\tfunction defaultExtent() {\n\t  var e = this, w, h;\n\t  if (e instanceof SVGElement) {\n\t    e = e.ownerSVGElement || e;\n\t    w = e.width.baseVal.value;\n\t    h = e.height.baseVal.value;\n\t  } else {\n\t    w = e.clientWidth;\n\t    h = e.clientHeight;\n\t  }\n\t  return [[0, 0], [w, h]];\n\t}\n\t\n\tfunction defaultTransform() {\n\t  return this.__zoom || identity;\n\t}\n\t\n\tfunction defaultWheelDelta() {\n\t  return -d3Selection.event.deltaY * (d3Selection.event.deltaMode ? 120 : 1) / 500;\n\t}\n\t\n\tfunction defaultTouchable() {\n\t  return \"ontouchstart\" in this;\n\t}\n\t\n\tfunction defaultConstrain(transform$$1, extent, translateExtent) {\n\t  var dx0 = transform$$1.invertX(extent[0][0]) - translateExtent[0][0],\n\t      dx1 = transform$$1.invertX(extent[1][0]) - translateExtent[1][0],\n\t      dy0 = transform$$1.invertY(extent[0][1]) - translateExtent[0][1],\n\t      dy1 = transform$$1.invertY(extent[1][1]) - translateExtent[1][1];\n\t  return transform$$1.translate(\n\t    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),\n\t    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)\n\t  );\n\t}\n\t\n\tvar zoom = function() {\n\t  var filter = defaultFilter,\n\t      extent = defaultExtent,\n\t      constrain = defaultConstrain,\n\t      wheelDelta = defaultWheelDelta,\n\t      touchable = defaultTouchable,\n\t      scaleExtent = [0, Infinity],\n\t      translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]],\n\t      duration = 250,\n\t      interpolate = d3Interpolate.interpolateZoom,\n\t      gestures = [],\n\t      listeners = d3Dispatch.dispatch(\"start\", \"zoom\", \"end\"),\n\t      touchstarting,\n\t      touchending,\n\t      touchDelay = 500,\n\t      wheelDelay = 150,\n\t      clickDistance2 = 0;\n\t\n\t  function zoom(selection) {\n\t    selection\n\t        .property(\"__zoom\", defaultTransform)\n\t        .on(\"wheel.zoom\", wheeled)\n\t        .on(\"mousedown.zoom\", mousedowned)\n\t        .on(\"dblclick.zoom\", dblclicked)\n\t      .filter(touchable)\n\t        .on(\"touchstart.zoom\", touchstarted)\n\t        .on(\"touchmove.zoom\", touchmoved)\n\t        .on(\"touchend.zoom touchcancel.zoom\", touchended)\n\t        .style(\"touch-action\", \"none\")\n\t        .style(\"-webkit-tap-highlight-color\", \"rgba(0,0,0,0)\");\n\t  }\n\t\n\t  zoom.transform = function(collection, transform$$1) {\n\t    var selection = collection.selection ? collection.selection() : collection;\n\t    selection.property(\"__zoom\", defaultTransform);\n\t    if (collection !== selection) {\n\t      schedule(collection, transform$$1);\n\t    } else {\n\t      selection.interrupt().each(function() {\n\t        gesture(this, arguments)\n\t            .start()\n\t            .zoom(null, typeof transform$$1 === \"function\" ? transform$$1.apply(this, arguments) : transform$$1)\n\t            .end();\n\t      });\n\t    }\n\t  };\n\t\n\t  zoom.scaleBy = function(selection, k) {\n\t    zoom.scaleTo(selection, function() {\n\t      var k0 = this.__zoom.k,\n\t          k1 = typeof k === \"function\" ? k.apply(this, arguments) : k;\n\t      return k0 * k1;\n\t    });\n\t  };\n\t\n\t  zoom.scaleTo = function(selection, k) {\n\t    zoom.transform(selection, function() {\n\t      var e = extent.apply(this, arguments),\n\t          t0 = this.__zoom,\n\t          p0 = centroid(e),\n\t          p1 = t0.invert(p0),\n\t          k1 = typeof k === \"function\" ? k.apply(this, arguments) : k;\n\t      return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);\n\t    });\n\t  };\n\t\n\t  zoom.translateBy = function(selection, x, y) {\n\t    zoom.transform(selection, function() {\n\t      return constrain(this.__zoom.translate(\n\t        typeof x === \"function\" ? x.apply(this, arguments) : x,\n\t        typeof y === \"function\" ? y.apply(this, arguments) : y\n\t      ), extent.apply(this, arguments), translateExtent);\n\t    });\n\t  };\n\t\n\t  zoom.translateTo = function(selection, x, y) {\n\t    zoom.transform(selection, function() {\n\t      var e = extent.apply(this, arguments),\n\t          t = this.__zoom,\n\t          p = centroid(e);\n\t      return constrain(identity.translate(p[0], p[1]).scale(t.k).translate(\n\t        typeof x === \"function\" ? -x.apply(this, arguments) : -x,\n\t        typeof y === \"function\" ? -y.apply(this, arguments) : -y\n\t      ), e, translateExtent);\n\t    });\n\t  };\n\t\n\t  function scale(transform$$1, k) {\n\t    k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));\n\t    return k === transform$$1.k ? transform$$1 : new Transform(k, transform$$1.x, transform$$1.y);\n\t  }\n\t\n\t  function translate(transform$$1, p0, p1) {\n\t    var x = p0[0] - p1[0] * transform$$1.k, y = p0[1] - p1[1] * transform$$1.k;\n\t    return x === transform$$1.x && y === transform$$1.y ? transform$$1 : new Transform(transform$$1.k, x, y);\n\t  }\n\t\n\t  function centroid(extent) {\n\t    return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];\n\t  }\n\t\n\t  function schedule(transition, transform$$1, center) {\n\t    transition\n\t        .on(\"start.zoom\", function() { gesture(this, arguments).start(); })\n\t        .on(\"interrupt.zoom end.zoom\", function() { gesture(this, arguments).end(); })\n\t        .tween(\"zoom\", function() {\n\t          var that = this,\n\t              args = arguments,\n\t              g = gesture(that, args),\n\t              e = extent.apply(that, args),\n\t              p = center || centroid(e),\n\t              w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),\n\t              a = that.__zoom,\n\t              b = typeof transform$$1 === \"function\" ? transform$$1.apply(that, args) : transform$$1,\n\t              i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));\n\t          return function(t) {\n\t            if (t === 1) t = b; // Avoid rounding error on end.\n\t            else { var l = i(t), k = w / l[2]; t = new Transform(k, p[0] - l[0] * k, p[1] - l[1] * k); }\n\t            g.zoom(null, t);\n\t          };\n\t        });\n\t  }\n\t\n\t  function gesture(that, args) {\n\t    for (var i = 0, n = gestures.length, g; i < n; ++i) {\n\t      if ((g = gestures[i]).that === that) {\n\t        return g;\n\t      }\n\t    }\n\t    return new Gesture(that, args);\n\t  }\n\t\n\t  function Gesture(that, args) {\n\t    this.that = that;\n\t    this.args = args;\n\t    this.index = -1;\n\t    this.active = 0;\n\t    this.extent = extent.apply(that, args);\n\t  }\n\t\n\t  Gesture.prototype = {\n\t    start: function() {\n\t      if (++this.active === 1) {\n\t        this.index = gestures.push(this) - 1;\n\t        this.emit(\"start\");\n\t      }\n\t      return this;\n\t    },\n\t    zoom: function(key, transform$$1) {\n\t      if (this.mouse && key !== \"mouse\") this.mouse[1] = transform$$1.invert(this.mouse[0]);\n\t      if (this.touch0 && key !== \"touch\") this.touch0[1] = transform$$1.invert(this.touch0[0]);\n\t      if (this.touch1 && key !== \"touch\") this.touch1[1] = transform$$1.invert(this.touch1[0]);\n\t      this.that.__zoom = transform$$1;\n\t      this.emit(\"zoom\");\n\t      return this;\n\t    },\n\t    end: function() {\n\t      if (--this.active === 0) {\n\t        gestures.splice(this.index, 1);\n\t        this.index = -1;\n\t        this.emit(\"end\");\n\t      }\n\t      return this;\n\t    },\n\t    emit: function(type) {\n\t      d3Selection.customEvent(new ZoomEvent(zoom, type, this.that.__zoom), listeners.apply, listeners, [type, this.that, this.args]);\n\t    }\n\t  };\n\t\n\t  function wheeled() {\n\t    if (!filter.apply(this, arguments)) return;\n\t    var g = gesture(this, arguments),\n\t        t = this.__zoom,\n\t        k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),\n\t        p = d3Selection.mouse(this);\n\t\n\t    // If the mouse is in the same location as before, reuse it.\n\t    // If there were recent wheel events, reset the wheel idle timeout.\n\t    if (g.wheel) {\n\t      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {\n\t        g.mouse[1] = t.invert(g.mouse[0] = p);\n\t      }\n\t      clearTimeout(g.wheel);\n\t    }\n\t\n\t    // If this wheel event won’t trigger a transform change, ignore it.\n\t    else if (t.k === k) return;\n\t\n\t    // Otherwise, capture the mouse point and location at the start.\n\t    else {\n\t      g.mouse = [p, t.invert(p)];\n\t      d3Transition.interrupt(this);\n\t      g.start();\n\t    }\n\t\n\t    noevent();\n\t    g.wheel = setTimeout(wheelidled, wheelDelay);\n\t    g.zoom(\"mouse\", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));\n\t\n\t    function wheelidled() {\n\t      g.wheel = null;\n\t      g.end();\n\t    }\n\t  }\n\t\n\t  function mousedowned() {\n\t    if (touchending || !filter.apply(this, arguments)) return;\n\t    var g = gesture(this, arguments),\n\t        v = d3Selection.select(d3Selection.event.view).on(\"mousemove.zoom\", mousemoved, true).on(\"mouseup.zoom\", mouseupped, true),\n\t        p = d3Selection.mouse(this),\n\t        x0 = d3Selection.event.clientX,\n\t        y0 = d3Selection.event.clientY;\n\t\n\t    d3Drag.dragDisable(d3Selection.event.view);\n\t    nopropagation();\n\t    g.mouse = [p, this.__zoom.invert(p)];\n\t    d3Transition.interrupt(this);\n\t    g.start();\n\t\n\t    function mousemoved() {\n\t      noevent();\n\t      if (!g.moved) {\n\t        var dx = d3Selection.event.clientX - x0, dy = d3Selection.event.clientY - y0;\n\t        g.moved = dx * dx + dy * dy > clickDistance2;\n\t      }\n\t      g.zoom(\"mouse\", constrain(translate(g.that.__zoom, g.mouse[0] = d3Selection.mouse(g.that), g.mouse[1]), g.extent, translateExtent));\n\t    }\n\t\n\t    function mouseupped() {\n\t      v.on(\"mousemove.zoom mouseup.zoom\", null);\n\t      d3Drag.dragEnable(d3Selection.event.view, g.moved);\n\t      noevent();\n\t      g.end();\n\t    }\n\t  }\n\t\n\t  function dblclicked() {\n\t    if (!filter.apply(this, arguments)) return;\n\t    var t0 = this.__zoom,\n\t        p0 = d3Selection.mouse(this),\n\t        p1 = t0.invert(p0),\n\t        k1 = t0.k * (d3Selection.event.shiftKey ? 0.5 : 2),\n\t        t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, arguments), translateExtent);\n\t\n\t    noevent();\n\t    if (duration > 0) d3Selection.select(this).transition().duration(duration).call(schedule, t1, p0);\n\t    else d3Selection.select(this).call(zoom.transform, t1);\n\t  }\n\t\n\t  function touchstarted() {\n\t    if (!filter.apply(this, arguments)) return;\n\t    var g = gesture(this, arguments),\n\t        touches = d3Selection.event.changedTouches,\n\t        started,\n\t        n = touches.length, i, t, p;\n\t\n\t    nopropagation();\n\t    for (i = 0; i < n; ++i) {\n\t      t = touches[i], p = d3Selection.touch(this, touches, t.identifier);\n\t      p = [p, this.__zoom.invert(p), t.identifier];\n\t      if (!g.touch0) g.touch0 = p, started = true;\n\t      else if (!g.touch1) g.touch1 = p;\n\t    }\n\t\n\t    // If this is a dbltap, reroute to the (optional) dblclick.zoom handler.\n\t    if (touchstarting) {\n\t      touchstarting = clearTimeout(touchstarting);\n\t      if (!g.touch1) {\n\t        g.end();\n\t        p = d3Selection.select(this).on(\"dblclick.zoom\");\n\t        if (p) p.apply(this, arguments);\n\t        return;\n\t      }\n\t    }\n\t\n\t    if (started) {\n\t      touchstarting = setTimeout(function() { touchstarting = null; }, touchDelay);\n\t      d3Transition.interrupt(this);\n\t      g.start();\n\t    }\n\t  }\n\t\n\t  function touchmoved() {\n\t    var g = gesture(this, arguments),\n\t        touches = d3Selection.event.changedTouches,\n\t        n = touches.length, i, t, p, l;\n\t\n\t    noevent();\n\t    if (touchstarting) touchstarting = clearTimeout(touchstarting);\n\t    for (i = 0; i < n; ++i) {\n\t      t = touches[i], p = d3Selection.touch(this, touches, t.identifier);\n\t      if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;\n\t      else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;\n\t    }\n\t    t = g.that.__zoom;\n\t    if (g.touch1) {\n\t      var p0 = g.touch0[0], l0 = g.touch0[1],\n\t          p1 = g.touch1[0], l1 = g.touch1[1],\n\t          dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,\n\t          dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;\n\t      t = scale(t, Math.sqrt(dp / dl));\n\t      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];\n\t      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];\n\t    }\n\t    else if (g.touch0) p = g.touch0[0], l = g.touch0[1];\n\t    else return;\n\t    g.zoom(\"touch\", constrain(translate(t, p, l), g.extent, translateExtent));\n\t  }\n\t\n\t  function touchended() {\n\t    var g = gesture(this, arguments),\n\t        touches = d3Selection.event.changedTouches,\n\t        n = touches.length, i, t;\n\t\n\t    nopropagation();\n\t    if (touchending) clearTimeout(touchending);\n\t    touchending = setTimeout(function() { touchending = null; }, touchDelay);\n\t    for (i = 0; i < n; ++i) {\n\t      t = touches[i];\n\t      if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;\n\t      else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;\n\t    }\n\t    if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;\n\t    if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);\n\t    else g.end();\n\t  }\n\t\n\t  zoom.wheelDelta = function(_) {\n\t    return arguments.length ? (wheelDelta = typeof _ === \"function\" ? _ : constant(+_), zoom) : wheelDelta;\n\t  };\n\t\n\t  zoom.filter = function(_) {\n\t    return arguments.length ? (filter = typeof _ === \"function\" ? _ : constant(!!_), zoom) : filter;\n\t  };\n\t\n\t  zoom.touchable = function(_) {\n\t    return arguments.length ? (touchable = typeof _ === \"function\" ? _ : constant(!!_), zoom) : touchable;\n\t  };\n\t\n\t  zoom.extent = function(_) {\n\t    return arguments.length ? (extent = typeof _ === \"function\" ? _ : constant([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;\n\t  };\n\t\n\t  zoom.scaleExtent = function(_) {\n\t    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];\n\t  };\n\t\n\t  zoom.translateExtent = function(_) {\n\t    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];\n\t  };\n\t\n\t  zoom.constrain = function(_) {\n\t    return arguments.length ? (constrain = _, zoom) : constrain;\n\t  };\n\t\n\t  zoom.duration = function(_) {\n\t    return arguments.length ? (duration = +_, zoom) : duration;\n\t  };\n\t\n\t  zoom.interpolate = function(_) {\n\t    return arguments.length ? (interpolate = _, zoom) : interpolate;\n\t  };\n\t\n\t  zoom.on = function() {\n\t    var value = listeners.on.apply(listeners, arguments);\n\t    return value === listeners ? zoom : value;\n\t  };\n\t\n\t  zoom.clickDistance = function(_) {\n\t    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);\n\t  };\n\t\n\t  return zoom;\n\t};\n\t\n\texports.zoom = zoom;\n\texports.zoomTransform = transform;\n\texports.zoomIdentity = identity;\n\t\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\t\n\t})));\n\n\n/***/ }),\n\n/***/ 226:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t// https://github.com/topojson/topojson-client Version 3.0.0. Copyright 2017 Mike Bostock.\n\t(function (global, factory) {\n\t\t true ? factory(exports) :\n\t\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t\t(factory((global.topojson = global.topojson || {})));\n\t}(this, (function (exports) { 'use strict';\n\t\n\tvar identity = function(x) {\n\t  return x;\n\t};\n\t\n\tvar transform = function(transform) {\n\t  if (transform == null) return identity;\n\t  var x0,\n\t      y0,\n\t      kx = transform.scale[0],\n\t      ky = transform.scale[1],\n\t      dx = transform.translate[0],\n\t      dy = transform.translate[1];\n\t  return function(input, i) {\n\t    if (!i) x0 = y0 = 0;\n\t    var j = 2, n = input.length, output = new Array(n);\n\t    output[0] = (x0 += input[0]) * kx + dx;\n\t    output[1] = (y0 += input[1]) * ky + dy;\n\t    while (j < n) output[j] = input[j], ++j;\n\t    return output;\n\t  };\n\t};\n\t\n\tvar bbox = function(topology) {\n\t  var t = transform(topology.transform), key,\n\t      x0 = Infinity, y0 = x0, x1 = -x0, y1 = -x0;\n\t\n\t  function bboxPoint(p) {\n\t    p = t(p);\n\t    if (p[0] < x0) x0 = p[0];\n\t    if (p[0] > x1) x1 = p[0];\n\t    if (p[1] < y0) y0 = p[1];\n\t    if (p[1] > y1) y1 = p[1];\n\t  }\n\t\n\t  function bboxGeometry(o) {\n\t    switch (o.type) {\n\t      case \"GeometryCollection\": o.geometries.forEach(bboxGeometry); break;\n\t      case \"Point\": bboxPoint(o.coordinates); break;\n\t      case \"MultiPoint\": o.coordinates.forEach(bboxPoint); break;\n\t    }\n\t  }\n\t\n\t  topology.arcs.forEach(function(arc) {\n\t    var i = -1, n = arc.length, p;\n\t    while (++i < n) {\n\t      p = t(arc[i], i);\n\t      if (p[0] < x0) x0 = p[0];\n\t      if (p[0] > x1) x1 = p[0];\n\t      if (p[1] < y0) y0 = p[1];\n\t      if (p[1] > y1) y1 = p[1];\n\t    }\n\t  });\n\t\n\t  for (key in topology.objects) {\n\t    bboxGeometry(topology.objects[key]);\n\t  }\n\t\n\t  return [x0, y0, x1, y1];\n\t};\n\t\n\tvar reverse = function(array, n) {\n\t  var t, j = array.length, i = j - n;\n\t  while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;\n\t};\n\t\n\tvar feature = function(topology, o) {\n\t  return o.type === \"GeometryCollection\"\n\t      ? {type: \"FeatureCollection\", features: o.geometries.map(function(o) { return feature$1(topology, o); })}\n\t      : feature$1(topology, o);\n\t};\n\t\n\tfunction feature$1(topology, o) {\n\t  var id = o.id,\n\t      bbox = o.bbox,\n\t      properties = o.properties == null ? {} : o.properties,\n\t      geometry = object(topology, o);\n\t  return id == null && bbox == null ? {type: \"Feature\", properties: properties, geometry: geometry}\n\t      : bbox == null ? {type: \"Feature\", id: id, properties: properties, geometry: geometry}\n\t      : {type: \"Feature\", id: id, bbox: bbox, properties: properties, geometry: geometry};\n\t}\n\t\n\tfunction object(topology, o) {\n\t  var transformPoint = transform(topology.transform),\n\t      arcs = topology.arcs;\n\t\n\t  function arc(i, points) {\n\t    if (points.length) points.pop();\n\t    for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {\n\t      points.push(transformPoint(a[k], k));\n\t    }\n\t    if (i < 0) reverse(points, n);\n\t  }\n\t\n\t  function point(p) {\n\t    return transformPoint(p);\n\t  }\n\t\n\t  function line(arcs) {\n\t    var points = [];\n\t    for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);\n\t    if (points.length < 2) points.push(points[0]); // This should never happen per the specification.\n\t    return points;\n\t  }\n\t\n\t  function ring(arcs) {\n\t    var points = line(arcs);\n\t    while (points.length < 4) points.push(points[0]); // This may happen if an arc has only two points.\n\t    return points;\n\t  }\n\t\n\t  function polygon(arcs) {\n\t    return arcs.map(ring);\n\t  }\n\t\n\t  function geometry(o) {\n\t    var type = o.type, coordinates;\n\t    switch (type) {\n\t      case \"GeometryCollection\": return {type: type, geometries: o.geometries.map(geometry)};\n\t      case \"Point\": coordinates = point(o.coordinates); break;\n\t      case \"MultiPoint\": coordinates = o.coordinates.map(point); break;\n\t      case \"LineString\": coordinates = line(o.arcs); break;\n\t      case \"MultiLineString\": coordinates = o.arcs.map(line); break;\n\t      case \"Polygon\": coordinates = polygon(o.arcs); break;\n\t      case \"MultiPolygon\": coordinates = o.arcs.map(polygon); break;\n\t      default: return null;\n\t    }\n\t    return {type: type, coordinates: coordinates};\n\t  }\n\t\n\t  return geometry(o);\n\t}\n\t\n\tvar stitch = function(topology, arcs) {\n\t  var stitchedArcs = {},\n\t      fragmentByStart = {},\n\t      fragmentByEnd = {},\n\t      fragments = [],\n\t      emptyIndex = -1;\n\t\n\t  // Stitch empty arcs first, since they may be subsumed by other arcs.\n\t  arcs.forEach(function(i, j) {\n\t    var arc = topology.arcs[i < 0 ? ~i : i], t;\n\t    if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {\n\t      t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;\n\t    }\n\t  });\n\t\n\t  arcs.forEach(function(i) {\n\t    var e = ends(i),\n\t        start = e[0],\n\t        end = e[1],\n\t        f, g;\n\t\n\t    if (f = fragmentByEnd[start]) {\n\t      delete fragmentByEnd[f.end];\n\t      f.push(i);\n\t      f.end = end;\n\t      if (g = fragmentByStart[end]) {\n\t        delete fragmentByStart[g.start];\n\t        var fg = g === f ? f : f.concat(g);\n\t        fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;\n\t      } else {\n\t        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n\t      }\n\t    } else if (f = fragmentByStart[end]) {\n\t      delete fragmentByStart[f.start];\n\t      f.unshift(i);\n\t      f.start = start;\n\t      if (g = fragmentByEnd[start]) {\n\t        delete fragmentByEnd[g.end];\n\t        var gf = g === f ? f : g.concat(f);\n\t        fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;\n\t      } else {\n\t        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n\t      }\n\t    } else {\n\t      f = [i];\n\t      fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;\n\t    }\n\t  });\n\t\n\t  function ends(i) {\n\t    var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;\n\t    if (topology.transform) p1 = [0, 0], arc.forEach(function(dp) { p1[0] += dp[0], p1[1] += dp[1]; });\n\t    else p1 = arc[arc.length - 1];\n\t    return i < 0 ? [p1, p0] : [p0, p1];\n\t  }\n\t\n\t  function flush(fragmentByEnd, fragmentByStart) {\n\t    for (var k in fragmentByEnd) {\n\t      var f = fragmentByEnd[k];\n\t      delete fragmentByStart[f.start];\n\t      delete f.start;\n\t      delete f.end;\n\t      f.forEach(function(i) { stitchedArcs[i < 0 ? ~i : i] = 1; });\n\t      fragments.push(f);\n\t    }\n\t  }\n\t\n\t  flush(fragmentByEnd, fragmentByStart);\n\t  flush(fragmentByStart, fragmentByEnd);\n\t  arcs.forEach(function(i) { if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]); });\n\t\n\t  return fragments;\n\t};\n\t\n\tvar mesh = function(topology) {\n\t  return object(topology, meshArcs.apply(this, arguments));\n\t};\n\t\n\tfunction meshArcs(topology, object$$1, filter) {\n\t  var arcs, i, n;\n\t  if (arguments.length > 1) arcs = extractArcs(topology, object$$1, filter);\n\t  else for (i = 0, arcs = new Array(n = topology.arcs.length); i < n; ++i) arcs[i] = i;\n\t  return {type: \"MultiLineString\", arcs: stitch(topology, arcs)};\n\t}\n\t\n\tfunction extractArcs(topology, object$$1, filter) {\n\t  var arcs = [],\n\t      geomsByArc = [],\n\t      geom;\n\t\n\t  function extract0(i) {\n\t    var j = i < 0 ? ~i : i;\n\t    (geomsByArc[j] || (geomsByArc[j] = [])).push({i: i, g: geom});\n\t  }\n\t\n\t  function extract1(arcs) {\n\t    arcs.forEach(extract0);\n\t  }\n\t\n\t  function extract2(arcs) {\n\t    arcs.forEach(extract1);\n\t  }\n\t\n\t  function extract3(arcs) {\n\t    arcs.forEach(extract2);\n\t  }\n\t\n\t  function geometry(o) {\n\t    switch (geom = o, o.type) {\n\t      case \"GeometryCollection\": o.geometries.forEach(geometry); break;\n\t      case \"LineString\": extract1(o.arcs); break;\n\t      case \"MultiLineString\": case \"Polygon\": extract2(o.arcs); break;\n\t      case \"MultiPolygon\": extract3(o.arcs); break;\n\t    }\n\t  }\n\t\n\t  geometry(object$$1);\n\t\n\t  geomsByArc.forEach(filter == null\n\t      ? function(geoms) { arcs.push(geoms[0].i); }\n\t      : function(geoms) { if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i); });\n\t\n\t  return arcs;\n\t}\n\t\n\tfunction planarRingArea(ring) {\n\t  var i = -1, n = ring.length, a, b = ring[n - 1], area = 0;\n\t  while (++i < n) a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0];\n\t  return Math.abs(area); // Note: doubled area!\n\t}\n\t\n\tvar merge = function(topology) {\n\t  return object(topology, mergeArcs.apply(this, arguments));\n\t};\n\t\n\tfunction mergeArcs(topology, objects) {\n\t  var polygonsByArc = {},\n\t      polygons = [],\n\t      groups = [];\n\t\n\t  objects.forEach(geometry);\n\t\n\t  function geometry(o) {\n\t    switch (o.type) {\n\t      case \"GeometryCollection\": o.geometries.forEach(geometry); break;\n\t      case \"Polygon\": extract(o.arcs); break;\n\t      case \"MultiPolygon\": o.arcs.forEach(extract); break;\n\t    }\n\t  }\n\t\n\t  function extract(polygon) {\n\t    polygon.forEach(function(ring) {\n\t      ring.forEach(function(arc) {\n\t        (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);\n\t      });\n\t    });\n\t    polygons.push(polygon);\n\t  }\n\t\n\t  function area(ring) {\n\t    return planarRingArea(object(topology, {type: \"Polygon\", arcs: [ring]}).coordinates[0]);\n\t  }\n\t\n\t  polygons.forEach(function(polygon) {\n\t    if (!polygon._) {\n\t      var group = [],\n\t          neighbors = [polygon];\n\t      polygon._ = 1;\n\t      groups.push(group);\n\t      while (polygon = neighbors.pop()) {\n\t        group.push(polygon);\n\t        polygon.forEach(function(ring) {\n\t          ring.forEach(function(arc) {\n\t            polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon) {\n\t              if (!polygon._) {\n\t                polygon._ = 1;\n\t                neighbors.push(polygon);\n\t              }\n\t            });\n\t          });\n\t        });\n\t      }\n\t    }\n\t  });\n\t\n\t  polygons.forEach(function(polygon) {\n\t    delete polygon._;\n\t  });\n\t\n\t  return {\n\t    type: \"MultiPolygon\",\n\t    arcs: groups.map(function(polygons) {\n\t      var arcs = [], n;\n\t\n\t      // Extract the exterior (unique) arcs.\n\t      polygons.forEach(function(polygon) {\n\t        polygon.forEach(function(ring) {\n\t          ring.forEach(function(arc) {\n\t            if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {\n\t              arcs.push(arc);\n\t            }\n\t          });\n\t        });\n\t      });\n\t\n\t      // Stitch the arcs into one or more rings.\n\t      arcs = stitch(topology, arcs);\n\t\n\t      // If more than one ring is returned,\n\t      // at most one of these rings can be the exterior;\n\t      // choose the one with the greatest absolute area.\n\t      if ((n = arcs.length) > 1) {\n\t        for (var i = 1, k = area(arcs[0]), ki, t; i < n; ++i) {\n\t          if ((ki = area(arcs[i])) > k) {\n\t            t = arcs[0], arcs[0] = arcs[i], arcs[i] = t, k = ki;\n\t          }\n\t        }\n\t      }\n\t\n\t      return arcs;\n\t    })\n\t  };\n\t}\n\t\n\tvar bisect = function(a, x) {\n\t  var lo = 0, hi = a.length;\n\t  while (lo < hi) {\n\t    var mid = lo + hi >>> 1;\n\t    if (a[mid] < x) lo = mid + 1;\n\t    else hi = mid;\n\t  }\n\t  return lo;\n\t};\n\t\n\tvar neighbors = function(objects) {\n\t  var indexesByArc = {}, // arc index -> array of object indexes\n\t      neighbors = objects.map(function() { return []; });\n\t\n\t  function line(arcs, i) {\n\t    arcs.forEach(function(a) {\n\t      if (a < 0) a = ~a;\n\t      var o = indexesByArc[a];\n\t      if (o) o.push(i);\n\t      else indexesByArc[a] = [i];\n\t    });\n\t  }\n\t\n\t  function polygon(arcs, i) {\n\t    arcs.forEach(function(arc) { line(arc, i); });\n\t  }\n\t\n\t  function geometry(o, i) {\n\t    if (o.type === \"GeometryCollection\") o.geometries.forEach(function(o) { geometry(o, i); });\n\t    else if (o.type in geometryType) geometryType[o.type](o.arcs, i);\n\t  }\n\t\n\t  var geometryType = {\n\t    LineString: line,\n\t    MultiLineString: polygon,\n\t    Polygon: polygon,\n\t    MultiPolygon: function(arcs, i) { arcs.forEach(function(arc) { polygon(arc, i); }); }\n\t  };\n\t\n\t  objects.forEach(geometry);\n\t\n\t  for (var i in indexesByArc) {\n\t    for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {\n\t      for (var k = j + 1; k < m; ++k) {\n\t        var ij = indexes[j], ik = indexes[k], n;\n\t        if ((n = neighbors[ij])[i = bisect(n, ik)] !== ik) n.splice(i, 0, ik);\n\t        if ((n = neighbors[ik])[i = bisect(n, ij)] !== ij) n.splice(i, 0, ij);\n\t      }\n\t    }\n\t  }\n\t\n\t  return neighbors;\n\t};\n\t\n\tvar untransform = function(transform) {\n\t  if (transform == null) return identity;\n\t  var x0,\n\t      y0,\n\t      kx = transform.scale[0],\n\t      ky = transform.scale[1],\n\t      dx = transform.translate[0],\n\t      dy = transform.translate[1];\n\t  return function(input, i) {\n\t    if (!i) x0 = y0 = 0;\n\t    var j = 2,\n\t        n = input.length,\n\t        output = new Array(n),\n\t        x1 = Math.round((input[0] - dx) / kx),\n\t        y1 = Math.round((input[1] - dy) / ky);\n\t    output[0] = x1 - x0, x0 = x1;\n\t    output[1] = y1 - y0, y0 = y1;\n\t    while (j < n) output[j] = input[j], ++j;\n\t    return output;\n\t  };\n\t};\n\t\n\tvar quantize = function(topology, transform) {\n\t  if (topology.transform) throw new Error(\"already quantized\");\n\t\n\t  if (!transform || !transform.scale) {\n\t    if (!((n = Math.floor(transform)) >= 2)) throw new Error(\"n must be ≥2\");\n\t    box = topology.bbox || bbox(topology);\n\t    var x0 = box[0], y0 = box[1], x1 = box[2], y1 = box[3], n;\n\t    transform = {scale: [x1 - x0 ? (x1 - x0) / (n - 1) : 1, y1 - y0 ? (y1 - y0) / (n - 1) : 1], translate: [x0, y0]};\n\t  } else {\n\t    box = topology.bbox;\n\t  }\n\t\n\t  var t = untransform(transform), box, key, inputs = topology.objects, outputs = {};\n\t\n\t  function quantizePoint(point) {\n\t    return t(point);\n\t  }\n\t\n\t  function quantizeGeometry(input) {\n\t    var output;\n\t    switch (input.type) {\n\t      case \"GeometryCollection\": output = {type: \"GeometryCollection\", geometries: input.geometries.map(quantizeGeometry)}; break;\n\t      case \"Point\": output = {type: \"Point\", coordinates: quantizePoint(input.coordinates)}; break;\n\t      case \"MultiPoint\": output = {type: \"MultiPoint\", coordinates: input.coordinates.map(quantizePoint)}; break;\n\t      default: return input;\n\t    }\n\t    if (input.id != null) output.id = input.id;\n\t    if (input.bbox != null) output.bbox = input.bbox;\n\t    if (input.properties != null) output.properties = input.properties;\n\t    return output;\n\t  }\n\t\n\t  function quantizeArc(input) {\n\t    var i = 0, j = 1, n = input.length, p, output = new Array(n); // pessimistic\n\t    output[0] = t(input[0], 0);\n\t    while (++i < n) if ((p = t(input[i], i))[0] || p[1]) output[j++] = p; // non-coincident points\n\t    if (j === 1) output[j++] = [0, 0]; // an arc must have at least two points\n\t    output.length = j;\n\t    return output;\n\t  }\n\t\n\t  for (key in inputs) outputs[key] = quantizeGeometry(inputs[key]);\n\t\n\t  return {\n\t    type: \"Topology\",\n\t    bbox: box,\n\t    transform: transform,\n\t    objects: outputs,\n\t    arcs: topology.arcs.map(quantizeArc)\n\t  };\n\t};\n\t\n\texports.bbox = bbox;\n\texports.feature = feature;\n\texports.mesh = mesh;\n\texports.meshArcs = meshArcs;\n\texports.merge = merge;\n\texports.mergeArcs = mergeArcs;\n\texports.neighbors = neighbors;\n\texports.quantize = quantize;\n\texports.transform = transform;\n\texports.untransform = untransform;\n\t\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\t\n\t})));\n\n\n/***/ }),\n\n/***/ 71:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar v1 = __webpack_require__(109);\n\tvar v4 = __webpack_require__(110);\n\t\n\tvar uuid = v4;\n\tuuid.v1 = v1;\n\tuuid.v4 = v4;\n\t\n\tmodule.exports = uuid;\n\n\n/***/ }),\n\n/***/ 34:\n/***/ (function(module, exports) {\n\n\t/**\n\t * Convert array of 16 byte values to UUID string format of the form:\n\t * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n\t */\n\tvar byteToHex = [];\n\tfor (var i = 0; i < 256; ++i) {\n\t  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n\t}\n\t\n\tfunction bytesToUuid(buf, offset) {\n\t  var i = offset || 0;\n\t  var bth = byteToHex;\n\t  return bth[buf[i++]] + bth[buf[i++]] +\n\t          bth[buf[i++]] + bth[buf[i++]] + '-' +\n\t          bth[buf[i++]] + bth[buf[i++]] + '-' +\n\t          bth[buf[i++]] + bth[buf[i++]] + '-' +\n\t          bth[buf[i++]] + bth[buf[i++]] + '-' +\n\t          bth[buf[i++]] + bth[buf[i++]] +\n\t          bth[buf[i++]] + bth[buf[i++]] +\n\t          bth[buf[i++]] + bth[buf[i++]];\n\t}\n\t\n\tmodule.exports = bytesToUuid;\n\n\n/***/ }),\n\n/***/ 35:\n/***/ (function(module, exports) {\n\n\t// Unique ID creation requires a high quality random # generator.  In the\n\t// browser this is a little complicated due to unknown quality of Math.random()\n\t// and inconsistent support for the `crypto` API.  We do the best we can via\n\t// feature-detection\n\t\n\t// getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n\tvar getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues.bind(crypto)) ||\n\t                      (typeof(msCrypto) != 'undefined' && msCrypto.getRandomValues.bind(msCrypto));\n\tif (getRandomValues) {\n\t  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n\t  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\t\n\t  module.exports = function whatwgRNG() {\n\t    getRandomValues(rnds8);\n\t    return rnds8;\n\t  };\n\t} else {\n\t  // Math.random()-based (RNG)\n\t  //\n\t  // If all else fails, use Math.random().  It's fast, but is of unspecified\n\t  // quality.\n\t  var rnds = new Array(16);\n\t\n\t  module.exports = function mathRNG() {\n\t    for (var i = 0, r; i < 16; i++) {\n\t      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n\t      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n\t    }\n\t\n\t    return rnds;\n\t  };\n\t}\n\n\n/***/ }),\n\n/***/ 109:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar rng = __webpack_require__(35);\n\tvar bytesToUuid = __webpack_require__(34);\n\t\n\t// **`v1()` - Generate time-based UUID**\n\t//\n\t// Inspired by https://github.com/LiosK/UUID.js\n\t// and http://docs.python.org/library/uuid.html\n\t\n\tvar _nodeId;\n\tvar _clockseq;\n\t\n\t// Previous uuid creation time\n\tvar _lastMSecs = 0;\n\tvar _lastNSecs = 0;\n\t\n\t// See https://github.com/broofa/node-uuid for API details\n\tfunction v1(options, buf, offset) {\n\t  var i = buf && offset || 0;\n\t  var b = buf || [];\n\t\n\t  options = options || {};\n\t  var node = options.node || _nodeId;\n\t  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\t\n\t  // node and clockseq need to be initialized to random values if they're not\n\t  // specified.  We do this lazily to minimize issues related to insufficient\n\t  // system entropy.  See #189\n\t  if (node == null || clockseq == null) {\n\t    var seedBytes = rng();\n\t    if (node == null) {\n\t      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n\t      node = _nodeId = [\n\t        seedBytes[0] | 0x01,\n\t        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]\n\t      ];\n\t    }\n\t    if (clockseq == null) {\n\t      // Per 4.2.2, randomize (14 bit) clockseq\n\t      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n\t    }\n\t  }\n\t\n\t  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n\t  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n\t  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n\t  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n\t  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\t\n\t  // Per 4.2.1.2, use count of uuid's generated during the current clock\n\t  // cycle to simulate higher resolution clock\n\t  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\t\n\t  // Time since last uuid creation (in msecs)\n\t  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\t\n\t  // Per 4.2.1.2, Bump clockseq on clock regression\n\t  if (dt < 0 && options.clockseq === undefined) {\n\t    clockseq = clockseq + 1 & 0x3fff;\n\t  }\n\t\n\t  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n\t  // time interval\n\t  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n\t    nsecs = 0;\n\t  }\n\t\n\t  // Per 4.2.1.2 Throw error if too many uuids are requested\n\t  if (nsecs >= 10000) {\n\t    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n\t  }\n\t\n\t  _lastMSecs = msecs;\n\t  _lastNSecs = nsecs;\n\t  _clockseq = clockseq;\n\t\n\t  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n\t  msecs += 12219292800000;\n\t\n\t  // `time_low`\n\t  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n\t  b[i++] = tl >>> 24 & 0xff;\n\t  b[i++] = tl >>> 16 & 0xff;\n\t  b[i++] = tl >>> 8 & 0xff;\n\t  b[i++] = tl & 0xff;\n\t\n\t  // `time_mid`\n\t  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n\t  b[i++] = tmh >>> 8 & 0xff;\n\t  b[i++] = tmh & 0xff;\n\t\n\t  // `time_high_and_version`\n\t  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n\t  b[i++] = tmh >>> 16 & 0xff;\n\t\n\t  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n\t  b[i++] = clockseq >>> 8 | 0x80;\n\t\n\t  // `clock_seq_low`\n\t  b[i++] = clockseq & 0xff;\n\t\n\t  // `node`\n\t  for (var n = 0; n < 6; ++n) {\n\t    b[i + n] = node[n];\n\t  }\n\t\n\t  return buf ? buf : bytesToUuid(b);\n\t}\n\t\n\tmodule.exports = v1;\n\n\n/***/ }),\n\n/***/ 110:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar rng = __webpack_require__(35);\n\tvar bytesToUuid = __webpack_require__(34);\n\t\n\tfunction v4(options, buf, offset) {\n\t  var i = buf && offset || 0;\n\t\n\t  if (typeof(options) == 'string') {\n\t    buf = options === 'binary' ? new Array(16) : null;\n\t    options = null;\n\t  }\n\t  options = options || {};\n\t\n\t  var rnds = options.random || (options.rng || rng)();\n\t\n\t  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\t  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n\t  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\t\n\t  // Copy bytes to buffer, if provided\n\t  if (buf) {\n\t    for (var ii = 0; ii < 16; ++ii) {\n\t      buf[i + ii] = rnds[ii];\n\t    }\n\t  }\n\t\n\t  return buf || bytesToUuid(rnds);\n\t}\n\t\n\tmodule.exports = v4;\n\n\n/***/ }),\n\n/***/ 289:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _react = __webpack_require__(1);\n\t\n\tvar _react2 = _interopRequireDefault(_react);\n\t\n\tvar _d3Zoom = __webpack_require__(369);\n\t\n\tvar _d3Selection = __webpack_require__(21);\n\t\n\tvar _propTypes = __webpack_require__(2);\n\t\n\tvar _propTypes2 = _interopRequireDefault(_propTypes);\n\t\n\tvar _WorldMap = __webpack_require__(293);\n\t\n\tvar _WorldMap2 = _interopRequireDefault(_WorldMap);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar GlobeViewChart = function (_Component) {\n\t  _inherits(GlobeViewChart, _Component);\n\t\n\t  function GlobeViewChart() {\n\t    var _temp, _this, _ret;\n\t\n\t    _classCallCheck(this, GlobeViewChart);\n\t\n\t    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t      args[_key] = arguments[_key];\n\t    }\n\t\n\t    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.state = {\n\t      transform: null\n\t    }, _this.onZoomHandler = function () {\n\t      if (_d3Selection.event.type === 'zoom') {\n\t        _this.setState({ transform: _d3Selection.event.transform });\n\t      }\n\t    }, _this.showToolTipInfo = function (value) {\n\t      var showToolTip = _this.props.showToolTip;\n\t\n\t      showToolTip(value);\n\t    }, _this.hideToolTipInfo = function () {\n\t      var hideToolTip = _this.props.hideToolTip;\n\t\n\t      hideToolTip();\n\t    }, _temp), _possibleConstructorReturn(_this, _ret);\n\t  }\n\t\n\t  GlobeViewChart.prototype.componentDidMount = function componentDidMount() {\n\t    (0, _d3Selection.select)(this.worldmap).call((0, _d3Zoom.zoom)().scaleExtent([0.5, 10]).on('zoom', this.onZoomHandler));\n\t  };\n\t\n\t  GlobeViewChart.prototype.render = function render() {\n\t    var _this2 = this;\n\t\n\t    var _props = this.props,\n\t        globeData = _props.globeData,\n\t        meteorsInfo = _props.meteorsInfo,\n\t        svgWidth = _props.svgWidth,\n\t        svgHeight = _props.svgHeight;\n\t    var transform = this.state.transform;\n\t\n\t    return _react2.default.createElement(\n\t      'svg',\n\t      {\n\t        width: svgWidth,\n\t        height: svgHeight,\n\t        ref: function ref(el) {\n\t          _this2.worldmap = el;\n\t        },\n\t        viewBox: '0 0 ' + svgWidth + ' ' + svgHeight,\n\t        preserveAspectRatio: 'xMidYMid meet' },\n\t      _react2.default.createElement(\n\t        'g',\n\t        {\n\t          transform: transform !== null ? 'translate(' + transform.x + ', ' + transform.y + ') scale(' + transform.k + ')' : null },\n\t        _react2.default.createElement(_WorldMap2.default, {\n\t          width: svgWidth,\n\t          height: 500,\n\t          world: globeData,\n\t          meteorfall: meteorsInfo,\n\t          pointEnter: this.showToolTipInfo,\n\t          pointExit: this.hideToolTipInfo\n\t        })\n\t      )\n\t    );\n\t  };\n\t\n\t  return GlobeViewChart;\n\t}(_react.Component);\n\t\n\tGlobeViewChart.propTypes = {\n\t  svgWidth: _propTypes2.default.number,\n\t  svgHeight: _propTypes2.default.number,\n\t  showToolTip: _propTypes2.default.func,\n\t  hideToolTip: _propTypes2.default.func,\n\t  globeData: _propTypes2.default.arrayOf(_propTypes2.default.shape({\n\t    dpath: _propTypes2.default.string,\n\t    fillInfo: _propTypes2.default.string\n\t  })),\n\t  meteorsInfo: _propTypes2.default.arrayOf(_propTypes2.default.shape({\n\t    date: _propTypes2.default.string,\n\t    fillOp: _propTypes2.default.number,\n\t    latitude: _propTypes2.default.number,\n\t    longitude: _propTypes2.default.number,\n\t    mass: _propTypes2.default.number,\n\t    name: _propTypes2.default.string,\n\t    radius: _propTypes2.default.number,\n\t    meteorClass: _propTypes2.default.string\n\t  }))\n\t};\n\texports.default = GlobeViewChart;\n\tmodule.exports = exports['default'];\n\n/***/ }),\n\n/***/ 290:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _d3Geo = __webpack_require__(191);\n\t\n\tvar _react = __webpack_require__(1);\n\t\n\tvar _react2 = _interopRequireDefault(_react);\n\t\n\tvar _topojsonClient = __webpack_require__(226);\n\t\n\tvar _Utilities = __webpack_require__(77);\n\t\n\tvar _Utilities2 = _interopRequireDefault(_Utilities);\n\t\n\tvar _index = __webpack_require__(37);\n\t\n\tvar _index2 = _interopRequireDefault(_index);\n\t\n\tvar _GlobeViewChart = __webpack_require__(289);\n\t\n\tvar _GlobeViewChart2 = _interopRequireDefault(_GlobeViewChart);\n\t\n\tvar _MeteorToolTip = __webpack_require__(292);\n\t\n\tvar _MeteorToolTip2 = _interopRequireDefault(_MeteorToolTip);\n\t\n\tvar _globeStyleModule = __webpack_require__(254);\n\t\n\tvar _globeStyleModule2 = _interopRequireDefault(_globeStyleModule);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar GlobeViewContainer = function (_Component) {\n\t  _inherits(GlobeViewContainer, _Component);\n\t\n\t  function GlobeViewContainer() {\n\t    var _temp, _this, _ret;\n\t\n\t    _classCallCheck(this, GlobeViewContainer);\n\t\n\t    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t      args[_key] = arguments[_key];\n\t    }\n\t\n\t    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.state = {\n\t      isLoading: true,\n\t      isError: false,\n\t      isToolTipActive: false,\n\t      meteorInfo: {},\n\t      chartWidth: 0,\n\t      chartHeight: 0,\n\t      meteors: [],\n\t      globeMap: [],\n\t      mapData: [],\n\t      meteorData: []\n\t    }, _this.setChartWidth = function (value) {\n\t      return value * 0.8;\n\t    }, _this.setChartDimensions = function () {\n\t      var chartWidth = _this.state.chartWidth;\n\t\n\t      var currentWidth = 0;\n\t      var currentHeight = 0;\n\t      if (_this.chartContainer) {\n\t        currentWidth = _this.chartContainer.getBoundingClientRect().width;\n\t        currentHeight = _this.chartContainer.getBoundingClientRect().height;\n\t\n\t        currentWidth = _this.chartContainer.getBoundingClientRect().width <= 768 ? _this.setChartWidth(_this.chartContainer.getBoundingClientRect().width) : _this.chartContainer.getBoundingClientRect().width;\n\t        currentHeight = _this.chartContainer.getBoundingClientRect().width <= 768 ? _this.setChartWidth(_this.chartContainer.getBoundingClientRect().height) : _this.chartContainer.getBoundingClientRect().height;\n\t\n\t        if (currentWidth !== chartWidth) {\n\t          _this.setState({\n\t            chartWidth: currentWidth,\n\t            chartHeight: currentHeight\n\t          });\n\t        }\n\t      } else {\n\t        currentWidth = window.innerWidth >= 960 ? 900 : window.innerWidth;\n\t        currentHeight = _this.setChartWidth(window.innerHeight);\n\t        if (currentWidth !== chartWidth) {\n\t          _this.setState({\n\t            chartWidth: currentWidth,\n\t            chartHeight: currentHeight\n\t          });\n\t        }\n\t      }\n\t      _this.updateMap();\n\t    }, _this.updateMap = function () {\n\t      var _this$state = _this.state,\n\t          mapData = _this$state.mapData,\n\t          meteorData = _this$state.meteorData;\n\t\n\t      var updatedMap = mapData.map(function (d, i) {\n\t        return {\n\t          dpath: (0, _d3Geo.geoPath)().projection(_this.project())(d),\n\t          fillInfo: 'rgba(38,50,56,' + 1 / mapData.length * i + ')'\n\t        };\n\t      });\n\t      var meteorPoints = meteorData.map(function (d) {\n\t        return {\n\t          name: d.properties.name,\n\t          mass: parseInt(d.properties.mass, 10),\n\t          date: d.properties.year,\n\t          meteorClass: d.properties.recclass,\n\t          radius: _this.calculateRadius(parseInt(d.properties.mass, 10)),\n\t          latitude: _this.project()([Number(d.properties.reclong), Number(d.properties.reclat)])[0],\n\t          longitude: _this.project()([Number(d.properties.reclong), Number(d.properties.reclat)])[1],\n\t          fillOp: parseInt(d.properties.mass, 10) <= 179687.5 ? 1 : 0.5\n\t        };\n\t      });\n\t      _this.setState({ meteors: meteorPoints, globeMap: updatedMap });\n\t    }, _this.calculateRadius = function (value) {\n\t      var range = 179687.5;\n\t\n\t      switch (true) {\n\t        case value <= range:\n\t          return 2;\n\t        case value <= range * 2:\n\t          return 4;\n\t        case value <= range * 3:\n\t          return 6;\n\t        case value <= range * 20:\n\t          return 8;\n\t        case value <= range * 100:\n\t          return 8;\n\t        default:\n\t          return 12;\n\t      }\n\t    }, _this.activateToolTip = function (value) {\n\t      _this.setState({ isToolTipActive: true, meteorInfo: value });\n\t    }, _this.disableToolTip = function () {\n\t      _this.setState({ isToolTipActive: false, meteorInfo: {} });\n\t    }, _this.handlePreloadShutdown = function () {\n\t      _this.setState({\n\t        isLoading: false\n\t      });\n\t    }, _temp), _possibleConstructorReturn(_this, _ret);\n\t  }\n\t  // #region component methods\n\t\n\t\n\t  GlobeViewContainer.prototype.componentDidMount = function componentDidMount() {\n\t    var _this2 = this;\n\t\n\t    if (typeof window !== 'undefined') {\n\t      this.setChartDimensions();\n\t      window.addEventListener('resize', this.setChartDimensions);\n\t    }\n\t    setTimeout(function () {\n\t      var storedMap = JSON.parse(_Utilities2.default.getStorageData('globeMap'));\n\t      var meteorsData = JSON.parse(_Utilities2.default.getStorageData('meteors'));\n\t      if (!storedMap) {\n\t        _this2.fetchData();\n\t        _this2.fetchDataMeteor();\n\t      } else {\n\t        var updatedMap = storedMap.map(function (d, i) {\n\t          return {\n\t            dpath: (0, _d3Geo.geoPath)().projection(_this2.project())(d),\n\t            fillInfo: 'rgba(38,50,56,' + 1 / storedMap.length * i + ')'\n\t          };\n\t        });\n\t        var meteorPoints = meteorsData.map(function (d) {\n\t          return {\n\t            name: d.properties.name,\n\t            mass: parseInt(d.properties.mass, 10),\n\t            date: d.properties.year,\n\t            meteorClass: d.properties.recclass,\n\t            radius: _this2.calculateRadius(parseInt(d.properties.mass, 10)),\n\t            latitude: _this2.project()([Number(d.properties.reclong), Number(d.properties.reclat)])[0],\n\t            longitude: _this2.project()([Number(d.properties.reclong), Number(d.properties.reclat)])[1],\n\t            fillOp: parseInt(d.properties.mass, 10) <= 179687.5 ? 1 : 0.5\n\t          };\n\t        });\n\t        _this2.setState({\n\t          meteors: meteorPoints,\n\t          meteorData: meteorsData,\n\t          globeMap: updatedMap,\n\t          mapData: storedMap\n\t        });\n\t        /* this.setState(prevState=>({\r\n\t                    globeMap:storedMap,\r\n\t                    meteors:meteorsData,\r\n\t                    meteors:meteorPoints,\r\n\t                    globeMap:updatedMap,\r\n\t                })); */\n\t      }\n\t    }, 2500);\n\t  };\n\t\n\t  GlobeViewContainer.prototype.componentWillUnmount = function componentWillUnmount() {\n\t    if (typeof window !== 'undefined') {\n\t      window.removeEventListener('resize', this.setChartDimensions);\n\t    }\n\t  };\n\t  // #endregion\n\t\n\t  // #region chart dimensioning\n\t\n\t\n\t  GlobeViewContainer.prototype.project = function project() {\n\t    var _state = this.state,\n\t        chartWidth = _state.chartWidth,\n\t        chartHeight = _state.chartHeight;\n\t\n\t    if (chartWidth < 768) {\n\t      return (0, _d3Geo.geoMercator)().scale(chartWidth).translate([chartWidth / 2, chartHeight / 2]);\n\t    }\n\t    return (0, _d3Geo.geoMercator)().scale(100).translate([chartWidth / 2, chartHeight / 2]);\n\t  };\n\t\n\t  // #endregion\n\t\n\t  // #region fetch data\n\t  GlobeViewContainer.prototype.fetchDataMeteor = function fetchDataMeteor() {\n\t    var _this3 = this;\n\t\n\t    fetch('https://data.nasa.gov/resource/y77d-th95.geojson').then(function (response) {\n\t      return response.json();\n\t    }).then(function (result) {\n\t      var meteorPoints = result.features.map(function (d) {\n\t        return {\n\t          name: d.properties.name,\n\t          mass: parseInt(d.properties.mass, 10),\n\t          date: d.properties.year,\n\t          meteorClass: d.properties.recclass,\n\t          radius: _this3.calculateRadius(parseInt(d.properties.mass, 10)),\n\t          latitude: _this3.project()([Number(d.properties.reclong), Number(d.properties.reclat)])[0],\n\t          longitude: _this3.project()([Number(d.properties.reclong), Number(d.properties.reclat)])[1],\n\t          fillOp: parseInt(d.properties.mass, 10) <= 179687.5 ? 1 : 0.5\n\t        };\n\t      });\n\t      _Utilities2.default.setStorageData('meteors', result.features);\n\t      _this3.setState({\n\t        meteors: meteorPoints,\n\t        meteorData: result.features\n\t      });\n\t    }).catch(function (err) {\n\t      console.log('====================================');\n\t      console.log('error getting the meteors data:' + JSON.stringify(err, null, 2));\n\t      console.log('====================================');\n\t      _this3.setState({ isError: true });\n\t    });\n\t  };\n\t\n\t  GlobeViewContainer.prototype.fetchData = function fetchData() {\n\t    var _this4 = this;\n\t\n\t    fetch('https://d3js.org/world-50m.v1.json').then(function (response) {\n\t      return response.json();\n\t    }).then(function (result) {\n\t      var pathsGlobe = (0, _topojsonClient.feature)(result, result.objects.countries).features;\n\t\n\t      console.log('====================================');\n\t      console.log('pathsglobe features=>' + JSON.stringify(pathsGlobe, null, 2));\n\t      console.log('====================================');\n\t\n\t      var formattedMap = pathsGlobe.map(function (d, i) {\n\t        return {\n\t          dpath: (0, _d3Geo.geoPath)().projection(_this4.project())(d),\n\t          fillInfo: 'rgba(38,50,56,' + 1 / pathsGlobe.length * i + ')'\n\t        };\n\t      });\n\t      _Utilities2.default.setStorageData('globeMap', pathsGlobe);\n\t      _this4.setState({\n\t        globeMap: formattedMap,\n\t        mapData: pathsGlobe\n\t      });\n\t    }).catch(function (err) {\n\t      console.log('====================================');\n\t      console.log('error getting the chart data:' + JSON.stringify(err, null, 2));\n\t      console.log('====================================');\n\t      _this4.setState({ isError: true });\n\t    });\n\t  };\n\t  // #endregion\n\t\n\t  // #region visibility\n\t\n\t\n\t  // #endregion\n\t\n\t  // #region render\n\t  GlobeViewContainer.prototype.render = function render() {\n\t    var _this5 = this;\n\t\n\t    var _state2 = this.state,\n\t        isError = _state2.isError,\n\t        isLoading = _state2.isLoading,\n\t        globeMap = _state2.globeMap,\n\t        meteors = _state2.meteors,\n\t        isToolTipActive = _state2.isToolTipActive,\n\t        meteorInfo = _state2.meteorInfo,\n\t        chartWidth = _state2.chartWidth,\n\t        chartHeight = _state2.chartHeight;\n\t\n\t    if (isError) {\n\t      return _react2.default.createElement(\n\t        'div',\n\t        { className: _globeStyleModule2.default.globeTitle },\n\t        'Lights up the sirens.....Something went wrong'\n\t      );\n\t    }\n\t    if (isLoading) {\n\t      return _react2.default.createElement(_index2.default, {\n\t        chartName: 'world',\n\t        turnDownPreload: this.handlePreloadShutdown\n\t      });\n\t    }\n\t\n\t    if (globeMap.length) {\n\t      return _react2.default.createElement(\n\t        'div',\n\t        {\n\t          ref: function ref(el) {\n\t            _this5.chartContainer = el;\n\t          } },\n\t        _react2.default.createElement(\n\t          'div',\n\t          { className: _globeStyleModule2.default.globeTitle },\n\t          'Meteor hits across the globe'\n\t        ),\n\t        _react2.default.createElement(\n\t          'div',\n\t          { className: _globeStyleModule2.default.containerGlobe },\n\t          _react2.default.createElement(\n\t            'div',\n\t            null,\n\t            _react2.default.createElement(_GlobeViewChart2.default, {\n\t              svgWidth: chartWidth,\n\t              svgHeight: chartHeight,\n\t              globeData: globeMap,\n\t              meteorsInfo: meteors,\n\t              showToolTip: this.activateToolTip,\n\t              hideToolTip: this.disableToolTip\n\t            })\n\t          ),\n\t          _react2.default.createElement(\n\t            'div',\n\t            null,\n\t            _react2.default.createElement(_MeteorToolTip2.default, { data: isToolTipActive ? meteorInfo : null })\n\t          )\n\t        )\n\t      );\n\t    }\n\t  };\n\t  // #endregion\n\t\n\t\n\t  return GlobeViewContainer;\n\t}(_react.Component);\n\t\n\texports.default = GlobeViewContainer;\n\tmodule.exports = exports['default'];\n\n/***/ }),\n\n/***/ 291:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _react = __webpack_require__(1);\n\t\n\tvar _react2 = _interopRequireDefault(_react);\n\t\n\tvar _propTypes = __webpack_require__(2);\n\t\n\tvar _propTypes2 = _interopRequireDefault(_propTypes);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar MeteorPoint = function (_PureComponent) {\n\t  _inherits(MeteorPoint, _PureComponent);\n\t\n\t  function MeteorPoint() {\n\t    var _temp, _this, _ret;\n\t\n\t    _classCallCheck(this, MeteorPoint);\n\t\n\t    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t      args[_key] = arguments[_key];\n\t    }\n\t\n\t    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this.onEnter = function () {\n\t      var _this$props = _this.props,\n\t          data = _this$props.data,\n\t          meteorPointEnter = _this$props.meteorPointEnter;\n\t\n\t      meteorPointEnter({\n\t        name: data.meteorname,\n\t        meteorclass: data.meteorclass,\n\t        dateofhit: data.datefell.substring(0, 4),\n\t        meteormass: data.mass,\n\t        latitude: Number(data.rectangleLat).toFixed(4),\n\t        longitude: Number(data.rectangleLong).toFixed(4)\n\t      });\n\t    }, _this.onExit = function () {\n\t      var meteorPointExit = _this.props.meteorPointExit;\n\t\n\t      meteorPointExit();\n\t    }, _temp), _possibleConstructorReturn(_this, _ret);\n\t  }\n\t\n\t  MeteorPoint.prototype.render = function render() {\n\t    var data = this.props.data;\n\t\n\t    return _react2.default.createElement('circle', {\n\t      key: 'marker_' + data.circleId + ' ',\n\t      fill: '#E91E63',\n\t      fillOpacity: data.circleFill,\n\t      stroke: '#FFFFFF',\n\t      className: 'marker',\n\t      cx: data.rectangleLat,\n\t      cy: data.rectangleLong,\n\t      r: data.circleArea,\n\t      onMouseOver: this.onEnter,\n\t      onFocus: this.onEnter,\n\t      onMouseOut: this.onExit,\n\t      onBlur: this.onExit\n\t    });\n\t  };\n\t\n\t  return MeteorPoint;\n\t}(_react.PureComponent);\n\t\n\tMeteorPoint.propTypes = {\n\t  data: _propTypes2.default.shape({\n\t    meteorname: _propTypes2.default.string,\n\t    meteorclass: _propTypes2.default.string,\n\t    datefell: _propTypes2.default.string,\n\t    mass: _propTypes2.default.number,\n\t    rectangleLat: _propTypes2.default.number,\n\t    rectangleLong: _propTypes2.default.number,\n\t    circleId: _propTypes2.default.number,\n\t    circleArea: _propTypes2.default.number,\n\t    circleFill: _propTypes2.default.number\n\t  }),\n\t  meteorPointEnter: _propTypes2.default.func,\n\t  meteorPointExit: _propTypes2.default.func\n\t};\n\texports.default = MeteorPoint;\n\tmodule.exports = exports['default'];\n\n/***/ }),\n\n/***/ 292:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _propTypes = __webpack_require__(2);\n\t\n\tvar _propTypes2 = _interopRequireDefault(_propTypes);\n\t\n\tvar _react = __webpack_require__(1);\n\t\n\tvar _react2 = _interopRequireDefault(_react);\n\t\n\tvar _globeStyleModule = __webpack_require__(254);\n\t\n\tvar _globeStyleModule2 = _interopRequireDefault(_globeStyleModule);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar showMeteorInfo = function showMeteorInfo() {\n\t  return _react2.default.createElement(\n\t    'p',\n\t    null,\n\t    _react2.default.createElement(\n\t      'span',\n\t      { className: _globeStyleModule2.default.tooltipText },\n\t      'Mouse over map to show information'\n\t    )\n\t  );\n\t};\n\tvar showMeteorData = function showMeteorData(value) {\n\t  return _react2.default.createElement(\n\t    'p',\n\t    null,\n\t    _react2.default.createElement(\n\t      'span',\n\t      { className: _globeStyleModule2.default.tooltipText },\n\t      'In ',\n\t      value.dateofhit,\n\t      ' a meteor with mass of ',\n\t      value.meteormass,\n\t      ' and class',\n\t      ' ',\n\t      value.meteorclass,\n\t      ' fell on latitude ',\n\t      value.latitude,\n\t      ' longitude',\n\t      ' ',\n\t      value.longitude\n\t    )\n\t  );\n\t};\n\t\n\tvar MeteorToolTip = function MeteorToolTip(_ref) {\n\t  var data = _ref.data;\n\t\n\t  return _react2.default.createElement(\n\t    'div',\n\t    { className: _globeStyleModule2.default.containerToolTip },\n\t    data ? showMeteorData(data) : showMeteorInfo()\n\t  );\n\t};\n\tMeteorToolTip.propTypes = {\n\t  data: _propTypes2.default.shape({\n\t    name: _propTypes2.default.string,\n\t    meteorclass: _propTypes2.default.string,\n\t    dateofhit: _propTypes2.default.string,\n\t    meteormass: _propTypes2.default.number,\n\t    latitude: _propTypes2.default.string,\n\t    longitude: _propTypes2.default.string\n\t  })\n\t};\n\texports.default = MeteorToolTip;\n\tmodule.exports = exports['default'];\n\n/***/ }),\n\n/***/ 293:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _propTypes = __webpack_require__(2);\n\t\n\tvar _propTypes2 = _interopRequireDefault(_propTypes);\n\t\n\tvar _uuid = __webpack_require__(71);\n\t\n\tvar _uuid2 = _interopRequireDefault(_uuid);\n\t\n\tvar _react = __webpack_require__(1);\n\t\n\tvar _react2 = _interopRequireDefault(_react);\n\t\n\tvar _MeteorPoint = __webpack_require__(291);\n\t\n\tvar _MeteorPoint2 = _interopRequireDefault(_MeteorPoint);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar WorldMap = function (_PureComponent) {\n\t  _inherits(WorldMap, _PureComponent);\n\t\n\t  function WorldMap() {\n\t    var _temp, _this, _ret;\n\t\n\t    _classCallCheck(this, WorldMap);\n\t\n\t    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t      args[_key] = arguments[_key];\n\t    }\n\t\n\t    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this.onPointHover = function (value) {\n\t      var pointEnter = _this.props.pointEnter;\n\t\n\t      pointEnter(value);\n\t    }, _this.onPointLeave = function () {\n\t      var pointExit = _this.props.pointExit;\n\t\n\t      pointExit();\n\t    }, _temp), _possibleConstructorReturn(_this, _ret);\n\t  }\n\t\n\t  WorldMap.prototype.render = function render() {\n\t    var _this2 = this;\n\t\n\t    var _props = this.props,\n\t        world = _props.world,\n\t        meteorfall = _props.meteorfall;\n\t\n\t\n\t    var parsedWorld = world.map(function (d) {\n\t      return _react2.default.createElement('path', {\n\t        key: 'path:' + _uuid2.default.v4(),\n\t        d: d.dpath,\n\t        fill: d.fillInfo,\n\t        stroke: '#FFFFFF',\n\t        strokeWidth: 0.5\n\t      });\n\t    });\n\t\n\t    var meteorsData = meteorfall.map(function (m, x) {\n\t      return _react2.default.createElement(_MeteorPoint2.default, {\n\t        key: 'mpoint_' + m.name + '_class_' + m.meteorclass,\n\t        data: {\n\t          meteorname: m.name,\n\t          meteorclass: m.meteorClass,\n\t          datefell: m.date,\n\t          mass: m.mass,\n\t          rectangleLat: m.latitude,\n\t          rectangleLong: m.longitude,\n\t          circleId: x,\n\t          circleArea: m.radius,\n\t          circleFill: m.fillOp\n\t        },\n\t        meteorPointEnter: _this2.onPointHover,\n\t        meteorPointExit: _this2.onPointLeave\n\t      });\n\t    });\n\t    return _react2.default.createElement(\n\t      'g',\n\t      null,\n\t      parsedWorld,\n\t      meteorsData\n\t    );\n\t  };\n\t\n\t  return WorldMap;\n\t}(_react.PureComponent);\n\t\n\tWorldMap.propTypes = {\n\t  world: _propTypes2.default.arrayOf(_propTypes2.default.shape({\n\t    dpath: _propTypes2.default.string,\n\t    fillInfo: _propTypes2.default.string\n\t  })),\n\t  pointEnter: _propTypes2.default.func,\n\t  pointExit: _propTypes2.default.func,\n\t  meteorfall: _propTypes2.default.arrayOf(_propTypes2.default.shape({\n\t    date: _propTypes2.default.string,\n\t    fillOp: _propTypes2.default.number,\n\t    latitude: _propTypes2.default.number,\n\t    longitude: _propTypes2.default.number,\n\t    mass: _propTypes2.default.number,\n\t    name: _propTypes2.default.string,\n\t    radius: _propTypes2.default.number,\n\t    meteorClass: _propTypes2.default.string\n\t  }))\n\t};\n\texports.default = WorldMap;\n\tmodule.exports = exports['default'];\n\n/***/ }),\n\n/***/ 254:\n/***/ (function(module, exports) {\n\n\t// removed by extract-text-webpack-plugin\n\tmodule.exports = {\"containerGlobe\":\"src-components-Challenges-GlobeChartView----globe-style-module---containerGlobe---3awqv\",\"globeTitle\":\"src-components-Challenges-GlobeChartView----globe-style-module---globeTitle---clqfa\",\"tooltipText\":\"src-components-Challenges-GlobeChartView----globe-style-module---tooltipText---1ZgBU\",\"containerToolTip\":\"src-components-Challenges-GlobeChartView----globe-style-module---containerToolTip---2qW53\"};\n\n/***/ }),\n\n/***/ 325:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _react = __webpack_require__(1);\n\t\n\tvar _react2 = _interopRequireDefault(_react);\n\t\n\tvar _reactHelmet = __webpack_require__(30);\n\t\n\tvar _reactHelmet2 = _interopRequireDefault(_reactHelmet);\n\t\n\tvar _GlobeViewContainer = __webpack_require__(290);\n\t\n\tvar _GlobeViewContainer2 = _interopRequireDefault(_GlobeViewContainer);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar GlobeGraphPage = function GlobeGraphPage() {\n\t  return _react2.default.createElement(\n\t    'div',\n\t    null,\n\t    _react2.default.createElement(_reactHelmet2.default, {\n\t      title: 'Super Duper Globe Map',\n\t      meta: [{\n\t        name: 'description',\n\t        content: 'freeCodeCamp DataVis Challenges,Globe Map,meteors'\n\t      }, {\n\t        name: 'keywords',\n\t        content: 'react, gatsby,challenges,d3,globe map'\n\t      }, { name: 'author', content: 'jonniebigodes' }]\n\t    }),\n\t    _react2.default.createElement(_GlobeViewContainer2.default, null)\n\t  );\n\t};\n\texports.default = GlobeGraphPage;\n\tmodule.exports = exports['default'];\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// component---src-pages-globeview-js-ed6be67a524f91b26450.js","// https://d3js.org/d3-dispatch/ Version 1.0.3. Copyright 2017 Mike Bostock.\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(factory((global.d3 = global.d3 || {})));\n}(this, (function (exports) { 'use strict';\n\nvar noop = {value: function() {}};\n\nfunction dispatch() {\n  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {\n    if (!(t = arguments[i] + \"\") || (t in _)) throw new Error(\"illegal type: \" + t);\n    _[t] = [];\n  }\n  return new Dispatch(_);\n}\n\nfunction Dispatch(_) {\n  this._ = _;\n}\n\nfunction parseTypenames(typenames, types) {\n  return typenames.trim().split(/^|\\s+/).map(function(t) {\n    var name = \"\", i = t.indexOf(\".\");\n    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);\n    if (t && !types.hasOwnProperty(t)) throw new Error(\"unknown type: \" + t);\n    return {type: t, name: name};\n  });\n}\n\nDispatch.prototype = dispatch.prototype = {\n  constructor: Dispatch,\n  on: function(typename, callback) {\n    var _ = this._,\n        T = parseTypenames(typename + \"\", _),\n        t,\n        i = -1,\n        n = T.length;\n\n    // If no callback was specified, return the callback of the given type and name.\n    if (arguments.length < 2) {\n      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;\n      return;\n    }\n\n    // If a type was specified, set the callback for the given type and name.\n    // Otherwise, if a null callback was specified, remove callbacks of the given name.\n    if (callback != null && typeof callback !== \"function\") throw new Error(\"invalid callback: \" + callback);\n    while (++i < n) {\n      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);\n      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);\n    }\n\n    return this;\n  },\n  copy: function() {\n    var copy = {}, _ = this._;\n    for (var t in _) copy[t] = _[t].slice();\n    return new Dispatch(copy);\n  },\n  call: function(type, that) {\n    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];\n    if (!this._.hasOwnProperty(type)) throw new Error(\"unknown type: \" + type);\n    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);\n  },\n  apply: function(type, that, args) {\n    if (!this._.hasOwnProperty(type)) throw new Error(\"unknown type: \" + type);\n    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);\n  }\n};\n\nfunction get(type, name) {\n  for (var i = 0, n = type.length, c; i < n; ++i) {\n    if ((c = type[i]).name === name) {\n      return c.value;\n    }\n  }\n}\n\nfunction set(type, name, callback) {\n  for (var i = 0, n = type.length; i < n; ++i) {\n    if (type[i].name === name) {\n      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));\n      break;\n    }\n  }\n  if (callback != null) type.push({name: name, value: callback});\n  return type;\n}\n\nexports.dispatch = dispatch;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/d3-dispatch/build/d3-dispatch.js\n// module id = 68\n// module chunks = 75343954514761 234182462816062","// https://d3js.org/d3-drag/ Version 1.2.1. Copyright 2017 Mike Bostock.\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-dispatch'), require('d3-selection')) :\n\ttypeof define === 'function' && define.amd ? define(['exports', 'd3-dispatch', 'd3-selection'], factory) :\n\t(factory((global.d3 = global.d3 || {}),global.d3,global.d3));\n}(this, (function (exports,d3Dispatch,d3Selection) { 'use strict';\n\nfunction nopropagation() {\n  d3Selection.event.stopImmediatePropagation();\n}\n\nvar noevent = function() {\n  d3Selection.event.preventDefault();\n  d3Selection.event.stopImmediatePropagation();\n};\n\nvar nodrag = function(view) {\n  var root = view.document.documentElement,\n      selection = d3Selection.select(view).on(\"dragstart.drag\", noevent, true);\n  if (\"onselectstart\" in root) {\n    selection.on(\"selectstart.drag\", noevent, true);\n  } else {\n    root.__noselect = root.style.MozUserSelect;\n    root.style.MozUserSelect = \"none\";\n  }\n};\n\nfunction yesdrag(view, noclick) {\n  var root = view.document.documentElement,\n      selection = d3Selection.select(view).on(\"dragstart.drag\", null);\n  if (noclick) {\n    selection.on(\"click.drag\", noevent, true);\n    setTimeout(function() { selection.on(\"click.drag\", null); }, 0);\n  }\n  if (\"onselectstart\" in root) {\n    selection.on(\"selectstart.drag\", null);\n  } else {\n    root.style.MozUserSelect = root.__noselect;\n    delete root.__noselect;\n  }\n}\n\nvar constant = function(x) {\n  return function() {\n    return x;\n  };\n};\n\nfunction DragEvent(target, type, subject, id, active, x, y, dx, dy, dispatch$$1) {\n  this.target = target;\n  this.type = type;\n  this.subject = subject;\n  this.identifier = id;\n  this.active = active;\n  this.x = x;\n  this.y = y;\n  this.dx = dx;\n  this.dy = dy;\n  this._ = dispatch$$1;\n}\n\nDragEvent.prototype.on = function() {\n  var value = this._.on.apply(this._, arguments);\n  return value === this._ ? this : value;\n};\n\n// Ignore right-click, since that should open the context menu.\nfunction defaultFilter() {\n  return !d3Selection.event.button;\n}\n\nfunction defaultContainer() {\n  return this.parentNode;\n}\n\nfunction defaultSubject(d) {\n  return d == null ? {x: d3Selection.event.x, y: d3Selection.event.y} : d;\n}\n\nfunction defaultTouchable() {\n  return \"ontouchstart\" in this;\n}\n\nvar drag = function() {\n  var filter = defaultFilter,\n      container = defaultContainer,\n      subject = defaultSubject,\n      touchable = defaultTouchable,\n      gestures = {},\n      listeners = d3Dispatch.dispatch(\"start\", \"drag\", \"end\"),\n      active = 0,\n      mousedownx,\n      mousedowny,\n      mousemoving,\n      touchending,\n      clickDistance2 = 0;\n\n  function drag(selection) {\n    selection\n        .on(\"mousedown.drag\", mousedowned)\n      .filter(touchable)\n        .on(\"touchstart.drag\", touchstarted)\n        .on(\"touchmove.drag\", touchmoved)\n        .on(\"touchend.drag touchcancel.drag\", touchended)\n        .style(\"touch-action\", \"none\")\n        .style(\"-webkit-tap-highlight-color\", \"rgba(0,0,0,0)\");\n  }\n\n  function mousedowned() {\n    if (touchending || !filter.apply(this, arguments)) return;\n    var gesture = beforestart(\"mouse\", container.apply(this, arguments), d3Selection.mouse, this, arguments);\n    if (!gesture) return;\n    d3Selection.select(d3Selection.event.view).on(\"mousemove.drag\", mousemoved, true).on(\"mouseup.drag\", mouseupped, true);\n    nodrag(d3Selection.event.view);\n    nopropagation();\n    mousemoving = false;\n    mousedownx = d3Selection.event.clientX;\n    mousedowny = d3Selection.event.clientY;\n    gesture(\"start\");\n  }\n\n  function mousemoved() {\n    noevent();\n    if (!mousemoving) {\n      var dx = d3Selection.event.clientX - mousedownx, dy = d3Selection.event.clientY - mousedowny;\n      mousemoving = dx * dx + dy * dy > clickDistance2;\n    }\n    gestures.mouse(\"drag\");\n  }\n\n  function mouseupped() {\n    d3Selection.select(d3Selection.event.view).on(\"mousemove.drag mouseup.drag\", null);\n    yesdrag(d3Selection.event.view, mousemoving);\n    noevent();\n    gestures.mouse(\"end\");\n  }\n\n  function touchstarted() {\n    if (!filter.apply(this, arguments)) return;\n    var touches = d3Selection.event.changedTouches,\n        c = container.apply(this, arguments),\n        n = touches.length, i, gesture;\n\n    for (i = 0; i < n; ++i) {\n      if (gesture = beforestart(touches[i].identifier, c, d3Selection.touch, this, arguments)) {\n        nopropagation();\n        gesture(\"start\");\n      }\n    }\n  }\n\n  function touchmoved() {\n    var touches = d3Selection.event.changedTouches,\n        n = touches.length, i, gesture;\n\n    for (i = 0; i < n; ++i) {\n      if (gesture = gestures[touches[i].identifier]) {\n        noevent();\n        gesture(\"drag\");\n      }\n    }\n  }\n\n  function touchended() {\n    var touches = d3Selection.event.changedTouches,\n        n = touches.length, i, gesture;\n\n    if (touchending) clearTimeout(touchending);\n    touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!\n    for (i = 0; i < n; ++i) {\n      if (gesture = gestures[touches[i].identifier]) {\n        nopropagation();\n        gesture(\"end\");\n      }\n    }\n  }\n\n  function beforestart(id, container, point, that, args) {\n    var p = point(container, id), s, dx, dy,\n        sublisteners = listeners.copy();\n\n    if (!d3Selection.customEvent(new DragEvent(drag, \"beforestart\", s, id, active, p[0], p[1], 0, 0, sublisteners), function() {\n      if ((d3Selection.event.subject = s = subject.apply(that, args)) == null) return false;\n      dx = s.x - p[0] || 0;\n      dy = s.y - p[1] || 0;\n      return true;\n    })) return;\n\n    return function gesture(type) {\n      var p0 = p, n;\n      switch (type) {\n        case \"start\": gestures[id] = gesture, n = active++; break;\n        case \"end\": delete gestures[id], --active; // nobreak\n        case \"drag\": p = point(container, id), n = active; break;\n      }\n      d3Selection.customEvent(new DragEvent(drag, type, s, id, n, p[0] + dx, p[1] + dy, p[0] - p0[0], p[1] - p0[1], sublisteners), sublisteners.apply, sublisteners, [type, that, args]);\n    };\n  }\n\n  drag.filter = function(_) {\n    return arguments.length ? (filter = typeof _ === \"function\" ? _ : constant(!!_), drag) : filter;\n  };\n\n  drag.container = function(_) {\n    return arguments.length ? (container = typeof _ === \"function\" ? _ : constant(_), drag) : container;\n  };\n\n  drag.subject = function(_) {\n    return arguments.length ? (subject = typeof _ === \"function\" ? _ : constant(_), drag) : subject;\n  };\n\n  drag.touchable = function(_) {\n    return arguments.length ? (touchable = typeof _ === \"function\" ? _ : constant(!!_), drag) : touchable;\n  };\n\n  drag.on = function() {\n    var value = listeners.on.apply(listeners, arguments);\n    return value === listeners ? drag : value;\n  };\n\n  drag.clickDistance = function(_) {\n    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);\n  };\n\n  return drag;\n};\n\nexports.drag = drag;\nexports.dragDisable = nodrag;\nexports.dragEnable = yesdrag;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/d3-drag/build/d3-drag.js\n// module id = 190\n// module chunks = 75343954514761 234182462816062","// https://d3js.org/d3-ease/ Version 1.0.3. Copyright 2017 Mike Bostock.\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(factory((global.d3 = global.d3 || {})));\n}(this, (function (exports) { 'use strict';\n\nfunction linear(t) {\n  return +t;\n}\n\nfunction quadIn(t) {\n  return t * t;\n}\n\nfunction quadOut(t) {\n  return t * (2 - t);\n}\n\nfunction quadInOut(t) {\n  return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;\n}\n\nfunction cubicIn(t) {\n  return t * t * t;\n}\n\nfunction cubicOut(t) {\n  return --t * t * t + 1;\n}\n\nfunction cubicInOut(t) {\n  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;\n}\n\nvar exponent = 3;\n\nvar polyIn = (function custom(e) {\n  e = +e;\n\n  function polyIn(t) {\n    return Math.pow(t, e);\n  }\n\n  polyIn.exponent = custom;\n\n  return polyIn;\n})(exponent);\n\nvar polyOut = (function custom(e) {\n  e = +e;\n\n  function polyOut(t) {\n    return 1 - Math.pow(1 - t, e);\n  }\n\n  polyOut.exponent = custom;\n\n  return polyOut;\n})(exponent);\n\nvar polyInOut = (function custom(e) {\n  e = +e;\n\n  function polyInOut(t) {\n    return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;\n  }\n\n  polyInOut.exponent = custom;\n\n  return polyInOut;\n})(exponent);\n\nvar pi = Math.PI;\nvar halfPi = pi / 2;\n\nfunction sinIn(t) {\n  return 1 - Math.cos(t * halfPi);\n}\n\nfunction sinOut(t) {\n  return Math.sin(t * halfPi);\n}\n\nfunction sinInOut(t) {\n  return (1 - Math.cos(pi * t)) / 2;\n}\n\nfunction expIn(t) {\n  return Math.pow(2, 10 * t - 10);\n}\n\nfunction expOut(t) {\n  return 1 - Math.pow(2, -10 * t);\n}\n\nfunction expInOut(t) {\n  return ((t *= 2) <= 1 ? Math.pow(2, 10 * t - 10) : 2 - Math.pow(2, 10 - 10 * t)) / 2;\n}\n\nfunction circleIn(t) {\n  return 1 - Math.sqrt(1 - t * t);\n}\n\nfunction circleOut(t) {\n  return Math.sqrt(1 - --t * t);\n}\n\nfunction circleInOut(t) {\n  return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;\n}\n\nvar b1 = 4 / 11;\nvar b2 = 6 / 11;\nvar b3 = 8 / 11;\nvar b4 = 3 / 4;\nvar b5 = 9 / 11;\nvar b6 = 10 / 11;\nvar b7 = 15 / 16;\nvar b8 = 21 / 22;\nvar b9 = 63 / 64;\nvar b0 = 1 / b1 / b1;\n\nfunction bounceIn(t) {\n  return 1 - bounceOut(1 - t);\n}\n\nfunction bounceOut(t) {\n  return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;\n}\n\nfunction bounceInOut(t) {\n  return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;\n}\n\nvar overshoot = 1.70158;\n\nvar backIn = (function custom(s) {\n  s = +s;\n\n  function backIn(t) {\n    return t * t * ((s + 1) * t - s);\n  }\n\n  backIn.overshoot = custom;\n\n  return backIn;\n})(overshoot);\n\nvar backOut = (function custom(s) {\n  s = +s;\n\n  function backOut(t) {\n    return --t * t * ((s + 1) * t + s) + 1;\n  }\n\n  backOut.overshoot = custom;\n\n  return backOut;\n})(overshoot);\n\nvar backInOut = (function custom(s) {\n  s = +s;\n\n  function backInOut(t) {\n    return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;\n  }\n\n  backInOut.overshoot = custom;\n\n  return backInOut;\n})(overshoot);\n\nvar tau = 2 * Math.PI;\nvar amplitude = 1;\nvar period = 0.3;\n\nvar elasticIn = (function custom(a, p) {\n  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);\n\n  function elasticIn(t) {\n    return a * Math.pow(2, 10 * --t) * Math.sin((s - t) / p);\n  }\n\n  elasticIn.amplitude = function(a) { return custom(a, p * tau); };\n  elasticIn.period = function(p) { return custom(a, p); };\n\n  return elasticIn;\n})(amplitude, period);\n\nvar elasticOut = (function custom(a, p) {\n  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);\n\n  function elasticOut(t) {\n    return 1 - a * Math.pow(2, -10 * (t = +t)) * Math.sin((t + s) / p);\n  }\n\n  elasticOut.amplitude = function(a) { return custom(a, p * tau); };\n  elasticOut.period = function(p) { return custom(a, p); };\n\n  return elasticOut;\n})(amplitude, period);\n\nvar elasticInOut = (function custom(a, p) {\n  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);\n\n  function elasticInOut(t) {\n    return ((t = t * 2 - 1) < 0\n        ? a * Math.pow(2, 10 * t) * Math.sin((s - t) / p)\n        : 2 - a * Math.pow(2, -10 * t) * Math.sin((s + t) / p)) / 2;\n  }\n\n  elasticInOut.amplitude = function(a) { return custom(a, p * tau); };\n  elasticInOut.period = function(p) { return custom(a, p); };\n\n  return elasticInOut;\n})(amplitude, period);\n\nexports.easeLinear = linear;\nexports.easeQuad = quadInOut;\nexports.easeQuadIn = quadIn;\nexports.easeQuadOut = quadOut;\nexports.easeQuadInOut = quadInOut;\nexports.easeCubic = cubicInOut;\nexports.easeCubicIn = cubicIn;\nexports.easeCubicOut = cubicOut;\nexports.easeCubicInOut = cubicInOut;\nexports.easePoly = polyInOut;\nexports.easePolyIn = polyIn;\nexports.easePolyOut = polyOut;\nexports.easePolyInOut = polyInOut;\nexports.easeSin = sinInOut;\nexports.easeSinIn = sinIn;\nexports.easeSinOut = sinOut;\nexports.easeSinInOut = sinInOut;\nexports.easeExp = expInOut;\nexports.easeExpIn = expIn;\nexports.easeExpOut = expOut;\nexports.easeExpInOut = expInOut;\nexports.easeCircle = circleInOut;\nexports.easeCircleIn = circleIn;\nexports.easeCircleOut = circleOut;\nexports.easeCircleInOut = circleInOut;\nexports.easeBounce = bounceOut;\nexports.easeBounceIn = bounceIn;\nexports.easeBounceOut = bounceOut;\nexports.easeBounceInOut = bounceInOut;\nexports.easeBack = backInOut;\nexports.easeBackIn = backIn;\nexports.easeBackOut = backOut;\nexports.easeBackInOut = backInOut;\nexports.easeElastic = elasticOut;\nexports.easeElasticIn = elasticIn;\nexports.easeElasticOut = elasticOut;\nexports.easeElasticInOut = elasticInOut;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/d3-ease/build/d3-ease.js\n// module id = 362\n// module chunks = 234182462816062","// https://d3js.org/d3-geo/ Version 1.10.0. Copyright 2018 Mike Bostock.\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-array')) :\n\ttypeof define === 'function' && define.amd ? define(['exports', 'd3-array'], factory) :\n\t(factory((global.d3 = global.d3 || {}),global.d3));\n}(this, (function (exports,d3Array) { 'use strict';\n\n// Adds floating point numbers with twice the normal precision.\n// Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and\n// Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)\n// 305–363 (1997).\n// Code adapted from GeographicLib by Charles F. F. Karney,\n// http://geographiclib.sourceforge.net/\n\nfunction adder() {\n  return new Adder;\n}\n\nfunction Adder() {\n  this.reset();\n}\n\nAdder.prototype = {\n  constructor: Adder,\n  reset: function() {\n    this.s = // rounded value\n    this.t = 0; // exact error\n  },\n  add: function(y) {\n    add(temp, y, this.t);\n    add(this, temp.s, this.s);\n    if (this.s) this.t += temp.t;\n    else this.s = temp.t;\n  },\n  valueOf: function() {\n    return this.s;\n  }\n};\n\nvar temp = new Adder;\n\nfunction add(adder, a, b) {\n  var x = adder.s = a + b,\n      bv = x - a,\n      av = x - bv;\n  adder.t = (a - av) + (b - bv);\n}\n\nvar epsilon = 1e-6;\nvar epsilon2 = 1e-12;\nvar pi = Math.PI;\nvar halfPi = pi / 2;\nvar quarterPi = pi / 4;\nvar tau = pi * 2;\n\nvar degrees = 180 / pi;\nvar radians = pi / 180;\n\nvar abs = Math.abs;\nvar atan = Math.atan;\nvar atan2 = Math.atan2;\nvar cos = Math.cos;\nvar ceil = Math.ceil;\nvar exp = Math.exp;\n\nvar log = Math.log;\nvar pow = Math.pow;\nvar sin = Math.sin;\nvar sign = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };\nvar sqrt = Math.sqrt;\nvar tan = Math.tan;\n\nfunction acos(x) {\n  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);\n}\n\nfunction asin(x) {\n  return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);\n}\n\nfunction haversin(x) {\n  return (x = sin(x / 2)) * x;\n}\n\nfunction noop() {}\n\nfunction streamGeometry(geometry, stream) {\n  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {\n    streamGeometryType[geometry.type](geometry, stream);\n  }\n}\n\nvar streamObjectType = {\n  Feature: function(object, stream) {\n    streamGeometry(object.geometry, stream);\n  },\n  FeatureCollection: function(object, stream) {\n    var features = object.features, i = -1, n = features.length;\n    while (++i < n) streamGeometry(features[i].geometry, stream);\n  }\n};\n\nvar streamGeometryType = {\n  Sphere: function(object, stream) {\n    stream.sphere();\n  },\n  Point: function(object, stream) {\n    object = object.coordinates;\n    stream.point(object[0], object[1], object[2]);\n  },\n  MultiPoint: function(object, stream) {\n    var coordinates = object.coordinates, i = -1, n = coordinates.length;\n    while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);\n  },\n  LineString: function(object, stream) {\n    streamLine(object.coordinates, stream, 0);\n  },\n  MultiLineString: function(object, stream) {\n    var coordinates = object.coordinates, i = -1, n = coordinates.length;\n    while (++i < n) streamLine(coordinates[i], stream, 0);\n  },\n  Polygon: function(object, stream) {\n    streamPolygon(object.coordinates, stream);\n  },\n  MultiPolygon: function(object, stream) {\n    var coordinates = object.coordinates, i = -1, n = coordinates.length;\n    while (++i < n) streamPolygon(coordinates[i], stream);\n  },\n  GeometryCollection: function(object, stream) {\n    var geometries = object.geometries, i = -1, n = geometries.length;\n    while (++i < n) streamGeometry(geometries[i], stream);\n  }\n};\n\nfunction streamLine(coordinates, stream, closed) {\n  var i = -1, n = coordinates.length - closed, coordinate;\n  stream.lineStart();\n  while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);\n  stream.lineEnd();\n}\n\nfunction streamPolygon(coordinates, stream) {\n  var i = -1, n = coordinates.length;\n  stream.polygonStart();\n  while (++i < n) streamLine(coordinates[i], stream, 1);\n  stream.polygonEnd();\n}\n\nfunction geoStream(object, stream) {\n  if (object && streamObjectType.hasOwnProperty(object.type)) {\n    streamObjectType[object.type](object, stream);\n  } else {\n    streamGeometry(object, stream);\n  }\n}\n\nvar areaRingSum = adder();\n\nvar areaSum = adder();\nvar lambda00;\nvar phi00;\nvar lambda0;\nvar cosPhi0;\nvar sinPhi0;\n\nvar areaStream = {\n  point: noop,\n  lineStart: noop,\n  lineEnd: noop,\n  polygonStart: function() {\n    areaRingSum.reset();\n    areaStream.lineStart = areaRingStart;\n    areaStream.lineEnd = areaRingEnd;\n  },\n  polygonEnd: function() {\n    var areaRing = +areaRingSum;\n    areaSum.add(areaRing < 0 ? tau + areaRing : areaRing);\n    this.lineStart = this.lineEnd = this.point = noop;\n  },\n  sphere: function() {\n    areaSum.add(tau);\n  }\n};\n\nfunction areaRingStart() {\n  areaStream.point = areaPointFirst;\n}\n\nfunction areaRingEnd() {\n  areaPoint(lambda00, phi00);\n}\n\nfunction areaPointFirst(lambda, phi) {\n  areaStream.point = areaPoint;\n  lambda00 = lambda, phi00 = phi;\n  lambda *= radians, phi *= radians;\n  lambda0 = lambda, cosPhi0 = cos(phi = phi / 2 + quarterPi), sinPhi0 = sin(phi);\n}\n\nfunction areaPoint(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  phi = phi / 2 + quarterPi; // half the angular distance from south pole\n\n  // Spherical excess E for a spherical triangle with vertices: south pole,\n  // previous point, current point.  Uses a formula derived from Cagnoli’s\n  // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).\n  var dLambda = lambda - lambda0,\n      sdLambda = dLambda >= 0 ? 1 : -1,\n      adLambda = sdLambda * dLambda,\n      cosPhi = cos(phi),\n      sinPhi = sin(phi),\n      k = sinPhi0 * sinPhi,\n      u = cosPhi0 * cosPhi + k * cos(adLambda),\n      v = k * sdLambda * sin(adLambda);\n  areaRingSum.add(atan2(v, u));\n\n  // Advance the previous points.\n  lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;\n}\n\nfunction area(object) {\n  areaSum.reset();\n  geoStream(object, areaStream);\n  return areaSum * 2;\n}\n\nfunction spherical(cartesian) {\n  return [atan2(cartesian[1], cartesian[0]), asin(cartesian[2])];\n}\n\nfunction cartesian(spherical) {\n  var lambda = spherical[0], phi = spherical[1], cosPhi = cos(phi);\n  return [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi)];\n}\n\nfunction cartesianDot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n\nfunction cartesianCross(a, b) {\n  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];\n}\n\n// TODO return a\nfunction cartesianAddInPlace(a, b) {\n  a[0] += b[0], a[1] += b[1], a[2] += b[2];\n}\n\nfunction cartesianScale(vector, k) {\n  return [vector[0] * k, vector[1] * k, vector[2] * k];\n}\n\n// TODO return d\nfunction cartesianNormalizeInPlace(d) {\n  var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);\n  d[0] /= l, d[1] /= l, d[2] /= l;\n}\n\nvar lambda0$1;\nvar phi0;\nvar lambda1;\nvar phi1;\nvar lambda2;\nvar lambda00$1;\nvar phi00$1;\nvar p0;\nvar deltaSum = adder();\nvar ranges;\nvar range$1;\n\nvar boundsStream = {\n  point: boundsPoint,\n  lineStart: boundsLineStart,\n  lineEnd: boundsLineEnd,\n  polygonStart: function() {\n    boundsStream.point = boundsRingPoint;\n    boundsStream.lineStart = boundsRingStart;\n    boundsStream.lineEnd = boundsRingEnd;\n    deltaSum.reset();\n    areaStream.polygonStart();\n  },\n  polygonEnd: function() {\n    areaStream.polygonEnd();\n    boundsStream.point = boundsPoint;\n    boundsStream.lineStart = boundsLineStart;\n    boundsStream.lineEnd = boundsLineEnd;\n    if (areaRingSum < 0) lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);\n    else if (deltaSum > epsilon) phi1 = 90;\n    else if (deltaSum < -epsilon) phi0 = -90;\n    range$1[0] = lambda0$1, range$1[1] = lambda1;\n  }\n};\n\nfunction boundsPoint(lambda, phi) {\n  ranges.push(range$1 = [lambda0$1 = lambda, lambda1 = lambda]);\n  if (phi < phi0) phi0 = phi;\n  if (phi > phi1) phi1 = phi;\n}\n\nfunction linePoint(lambda, phi) {\n  var p = cartesian([lambda * radians, phi * radians]);\n  if (p0) {\n    var normal = cartesianCross(p0, p),\n        equatorial = [normal[1], -normal[0], 0],\n        inflection = cartesianCross(equatorial, normal);\n    cartesianNormalizeInPlace(inflection);\n    inflection = spherical(inflection);\n    var delta = lambda - lambda2,\n        sign$$1 = delta > 0 ? 1 : -1,\n        lambdai = inflection[0] * degrees * sign$$1,\n        phii,\n        antimeridian = abs(delta) > 180;\n    if (antimeridian ^ (sign$$1 * lambda2 < lambdai && lambdai < sign$$1 * lambda)) {\n      phii = inflection[1] * degrees;\n      if (phii > phi1) phi1 = phii;\n    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign$$1 * lambda2 < lambdai && lambdai < sign$$1 * lambda)) {\n      phii = -inflection[1] * degrees;\n      if (phii < phi0) phi0 = phii;\n    } else {\n      if (phi < phi0) phi0 = phi;\n      if (phi > phi1) phi1 = phi;\n    }\n    if (antimeridian) {\n      if (lambda < lambda2) {\n        if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;\n      } else {\n        if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;\n      }\n    } else {\n      if (lambda1 >= lambda0$1) {\n        if (lambda < lambda0$1) lambda0$1 = lambda;\n        if (lambda > lambda1) lambda1 = lambda;\n      } else {\n        if (lambda > lambda2) {\n          if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;\n        } else {\n          if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;\n        }\n      }\n    }\n  } else {\n    ranges.push(range$1 = [lambda0$1 = lambda, lambda1 = lambda]);\n  }\n  if (phi < phi0) phi0 = phi;\n  if (phi > phi1) phi1 = phi;\n  p0 = p, lambda2 = lambda;\n}\n\nfunction boundsLineStart() {\n  boundsStream.point = linePoint;\n}\n\nfunction boundsLineEnd() {\n  range$1[0] = lambda0$1, range$1[1] = lambda1;\n  boundsStream.point = boundsPoint;\n  p0 = null;\n}\n\nfunction boundsRingPoint(lambda, phi) {\n  if (p0) {\n    var delta = lambda - lambda2;\n    deltaSum.add(abs(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);\n  } else {\n    lambda00$1 = lambda, phi00$1 = phi;\n  }\n  areaStream.point(lambda, phi);\n  linePoint(lambda, phi);\n}\n\nfunction boundsRingStart() {\n  areaStream.lineStart();\n}\n\nfunction boundsRingEnd() {\n  boundsRingPoint(lambda00$1, phi00$1);\n  areaStream.lineEnd();\n  if (abs(deltaSum) > epsilon) lambda0$1 = -(lambda1 = 180);\n  range$1[0] = lambda0$1, range$1[1] = lambda1;\n  p0 = null;\n}\n\n// Finds the left-right distance between two longitudes.\n// This is almost the same as (lambda1 - lambda0 + 360°) % 360°, except that we want\n// the distance between ±180° to be 360°.\nfunction angle(lambda0, lambda1) {\n  return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;\n}\n\nfunction rangeCompare(a, b) {\n  return a[0] - b[0];\n}\n\nfunction rangeContains(range$$1, x) {\n  return range$$1[0] <= range$$1[1] ? range$$1[0] <= x && x <= range$$1[1] : x < range$$1[0] || range$$1[1] < x;\n}\n\nfunction bounds(feature) {\n  var i, n, a, b, merged, deltaMax, delta;\n\n  phi1 = lambda1 = -(lambda0$1 = phi0 = Infinity);\n  ranges = [];\n  geoStream(feature, boundsStream);\n\n  // First, sort ranges by their minimum longitudes.\n  if (n = ranges.length) {\n    ranges.sort(rangeCompare);\n\n    // Then, merge any ranges that overlap.\n    for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {\n      b = ranges[i];\n      if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {\n        if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];\n        if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];\n      } else {\n        merged.push(a = b);\n      }\n    }\n\n    // Finally, find the largest gap between the merged ranges.\n    // The final bounding box will be the inverse of this gap.\n    for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {\n      b = merged[i];\n      if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0$1 = b[0], lambda1 = a[1];\n    }\n  }\n\n  ranges = range$1 = null;\n\n  return lambda0$1 === Infinity || phi0 === Infinity\n      ? [[NaN, NaN], [NaN, NaN]]\n      : [[lambda0$1, phi0], [lambda1, phi1]];\n}\n\nvar W0;\nvar W1;\nvar X0;\nvar Y0;\nvar Z0;\nvar X1;\nvar Y1;\nvar Z1;\nvar X2;\nvar Y2;\nvar Z2;\nvar lambda00$2;\nvar phi00$2;\nvar x0;\nvar y0;\nvar z0; // previous point\n\nvar centroidStream = {\n  sphere: noop,\n  point: centroidPoint,\n  lineStart: centroidLineStart,\n  lineEnd: centroidLineEnd,\n  polygonStart: function() {\n    centroidStream.lineStart = centroidRingStart;\n    centroidStream.lineEnd = centroidRingEnd;\n  },\n  polygonEnd: function() {\n    centroidStream.lineStart = centroidLineStart;\n    centroidStream.lineEnd = centroidLineEnd;\n  }\n};\n\n// Arithmetic mean of Cartesian vectors.\nfunction centroidPoint(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  var cosPhi = cos(phi);\n  centroidPointCartesian(cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi));\n}\n\nfunction centroidPointCartesian(x, y, z) {\n  ++W0;\n  X0 += (x - X0) / W0;\n  Y0 += (y - Y0) / W0;\n  Z0 += (z - Z0) / W0;\n}\n\nfunction centroidLineStart() {\n  centroidStream.point = centroidLinePointFirst;\n}\n\nfunction centroidLinePointFirst(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  var cosPhi = cos(phi);\n  x0 = cosPhi * cos(lambda);\n  y0 = cosPhi * sin(lambda);\n  z0 = sin(phi);\n  centroidStream.point = centroidLinePoint;\n  centroidPointCartesian(x0, y0, z0);\n}\n\nfunction centroidLinePoint(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  var cosPhi = cos(phi),\n      x = cosPhi * cos(lambda),\n      y = cosPhi * sin(lambda),\n      z = sin(phi),\n      w = atan2(sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);\n  W1 += w;\n  X1 += w * (x0 + (x0 = x));\n  Y1 += w * (y0 + (y0 = y));\n  Z1 += w * (z0 + (z0 = z));\n  centroidPointCartesian(x0, y0, z0);\n}\n\nfunction centroidLineEnd() {\n  centroidStream.point = centroidPoint;\n}\n\n// See J. E. Brock, The Inertia Tensor for a Spherical Triangle,\n// J. Applied Mechanics 42, 239 (1975).\nfunction centroidRingStart() {\n  centroidStream.point = centroidRingPointFirst;\n}\n\nfunction centroidRingEnd() {\n  centroidRingPoint(lambda00$2, phi00$2);\n  centroidStream.point = centroidPoint;\n}\n\nfunction centroidRingPointFirst(lambda, phi) {\n  lambda00$2 = lambda, phi00$2 = phi;\n  lambda *= radians, phi *= radians;\n  centroidStream.point = centroidRingPoint;\n  var cosPhi = cos(phi);\n  x0 = cosPhi * cos(lambda);\n  y0 = cosPhi * sin(lambda);\n  z0 = sin(phi);\n  centroidPointCartesian(x0, y0, z0);\n}\n\nfunction centroidRingPoint(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  var cosPhi = cos(phi),\n      x = cosPhi * cos(lambda),\n      y = cosPhi * sin(lambda),\n      z = sin(phi),\n      cx = y0 * z - z0 * y,\n      cy = z0 * x - x0 * z,\n      cz = x0 * y - y0 * x,\n      m = sqrt(cx * cx + cy * cy + cz * cz),\n      w = asin(m), // line weight = angle\n      v = m && -w / m; // area weight multiplier\n  X2 += v * cx;\n  Y2 += v * cy;\n  Z2 += v * cz;\n  W1 += w;\n  X1 += w * (x0 + (x0 = x));\n  Y1 += w * (y0 + (y0 = y));\n  Z1 += w * (z0 + (z0 = z));\n  centroidPointCartesian(x0, y0, z0);\n}\n\nfunction centroid(object) {\n  W0 = W1 =\n  X0 = Y0 = Z0 =\n  X1 = Y1 = Z1 =\n  X2 = Y2 = Z2 = 0;\n  geoStream(object, centroidStream);\n\n  var x = X2,\n      y = Y2,\n      z = Z2,\n      m = x * x + y * y + z * z;\n\n  // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.\n  if (m < epsilon2) {\n    x = X1, y = Y1, z = Z1;\n    // If the feature has zero length, fall back to arithmetic mean of point vectors.\n    if (W1 < epsilon) x = X0, y = Y0, z = Z0;\n    m = x * x + y * y + z * z;\n    // If the feature still has an undefined ccentroid, then return.\n    if (m < epsilon2) return [NaN, NaN];\n  }\n\n  return [atan2(y, x) * degrees, asin(z / sqrt(m)) * degrees];\n}\n\nfunction constant(x) {\n  return function() {\n    return x;\n  };\n}\n\nfunction compose(a, b) {\n\n  function compose(x, y) {\n    return x = a(x, y), b(x[0], x[1]);\n  }\n\n  if (a.invert && b.invert) compose.invert = function(x, y) {\n    return x = b.invert(x, y), x && a.invert(x[0], x[1]);\n  };\n\n  return compose;\n}\n\nfunction rotationIdentity(lambda, phi) {\n  return [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];\n}\n\nrotationIdentity.invert = rotationIdentity;\n\nfunction rotateRadians(deltaLambda, deltaPhi, deltaGamma) {\n  return (deltaLambda %= tau) ? (deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma))\n    : rotationLambda(deltaLambda))\n    : (deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma)\n    : rotationIdentity);\n}\n\nfunction forwardRotationLambda(deltaLambda) {\n  return function(lambda, phi) {\n    return lambda += deltaLambda, [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];\n  };\n}\n\nfunction rotationLambda(deltaLambda) {\n  var rotation = forwardRotationLambda(deltaLambda);\n  rotation.invert = forwardRotationLambda(-deltaLambda);\n  return rotation;\n}\n\nfunction rotationPhiGamma(deltaPhi, deltaGamma) {\n  var cosDeltaPhi = cos(deltaPhi),\n      sinDeltaPhi = sin(deltaPhi),\n      cosDeltaGamma = cos(deltaGamma),\n      sinDeltaGamma = sin(deltaGamma);\n\n  function rotation(lambda, phi) {\n    var cosPhi = cos(phi),\n        x = cos(lambda) * cosPhi,\n        y = sin(lambda) * cosPhi,\n        z = sin(phi),\n        k = z * cosDeltaPhi + x * sinDeltaPhi;\n    return [\n      atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),\n      asin(k * cosDeltaGamma + y * sinDeltaGamma)\n    ];\n  }\n\n  rotation.invert = function(lambda, phi) {\n    var cosPhi = cos(phi),\n        x = cos(lambda) * cosPhi,\n        y = sin(lambda) * cosPhi,\n        z = sin(phi),\n        k = z * cosDeltaGamma - y * sinDeltaGamma;\n    return [\n      atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),\n      asin(k * cosDeltaPhi - x * sinDeltaPhi)\n    ];\n  };\n\n  return rotation;\n}\n\nfunction rotation(rotate) {\n  rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);\n\n  function forward(coordinates) {\n    coordinates = rotate(coordinates[0] * radians, coordinates[1] * radians);\n    return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;\n  }\n\n  forward.invert = function(coordinates) {\n    coordinates = rotate.invert(coordinates[0] * radians, coordinates[1] * radians);\n    return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;\n  };\n\n  return forward;\n}\n\n// Generates a circle centered at [0°, 0°], with a given radius and precision.\nfunction circleStream(stream, radius, delta, direction, t0, t1) {\n  if (!delta) return;\n  var cosRadius = cos(radius),\n      sinRadius = sin(radius),\n      step = direction * delta;\n  if (t0 == null) {\n    t0 = radius + direction * tau;\n    t1 = radius - step / 2;\n  } else {\n    t0 = circleRadius(cosRadius, t0);\n    t1 = circleRadius(cosRadius, t1);\n    if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * tau;\n  }\n  for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {\n    point = spherical([cosRadius, -sinRadius * cos(t), -sinRadius * sin(t)]);\n    stream.point(point[0], point[1]);\n  }\n}\n\n// Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].\nfunction circleRadius(cosRadius, point) {\n  point = cartesian(point), point[0] -= cosRadius;\n  cartesianNormalizeInPlace(point);\n  var radius = acos(-point[1]);\n  return ((-point[2] < 0 ? -radius : radius) + tau - epsilon) % tau;\n}\n\nfunction circle() {\n  var center = constant([0, 0]),\n      radius = constant(90),\n      precision = constant(6),\n      ring,\n      rotate,\n      stream = {point: point};\n\n  function point(x, y) {\n    ring.push(x = rotate(x, y));\n    x[0] *= degrees, x[1] *= degrees;\n  }\n\n  function circle() {\n    var c = center.apply(this, arguments),\n        r = radius.apply(this, arguments) * radians,\n        p = precision.apply(this, arguments) * radians;\n    ring = [];\n    rotate = rotateRadians(-c[0] * radians, -c[1] * radians, 0).invert;\n    circleStream(stream, r, p, 1);\n    c = {type: \"Polygon\", coordinates: [ring]};\n    ring = rotate = null;\n    return c;\n  }\n\n  circle.center = function(_) {\n    return arguments.length ? (center = typeof _ === \"function\" ? _ : constant([+_[0], +_[1]]), circle) : center;\n  };\n\n  circle.radius = function(_) {\n    return arguments.length ? (radius = typeof _ === \"function\" ? _ : constant(+_), circle) : radius;\n  };\n\n  circle.precision = function(_) {\n    return arguments.length ? (precision = typeof _ === \"function\" ? _ : constant(+_), circle) : precision;\n  };\n\n  return circle;\n}\n\nfunction clipBuffer() {\n  var lines = [],\n      line;\n  return {\n    point: function(x, y) {\n      line.push([x, y]);\n    },\n    lineStart: function() {\n      lines.push(line = []);\n    },\n    lineEnd: noop,\n    rejoin: function() {\n      if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));\n    },\n    result: function() {\n      var result = lines;\n      lines = [];\n      line = null;\n      return result;\n    }\n  };\n}\n\nfunction pointEqual(a, b) {\n  return abs(a[0] - b[0]) < epsilon && abs(a[1] - b[1]) < epsilon;\n}\n\nfunction Intersection(point, points, other, entry) {\n  this.x = point;\n  this.z = points;\n  this.o = other; // another intersection\n  this.e = entry; // is an entry?\n  this.v = false; // visited\n  this.n = this.p = null; // next & previous\n}\n\n// A generalized polygon clipping algorithm: given a polygon that has been cut\n// into its visible line segments, and rejoins the segments by interpolating\n// along the clip edge.\nfunction clipRejoin(segments, compareIntersection, startInside, interpolate, stream) {\n  var subject = [],\n      clip = [],\n      i,\n      n;\n\n  segments.forEach(function(segment) {\n    if ((n = segment.length - 1) <= 0) return;\n    var n, p0 = segment[0], p1 = segment[n], x;\n\n    // If the first and last points of a segment are coincident, then treat as a\n    // closed ring. TODO if all rings are closed, then the winding order of the\n    // exterior ring should be checked.\n    if (pointEqual(p0, p1)) {\n      stream.lineStart();\n      for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);\n      stream.lineEnd();\n      return;\n    }\n\n    subject.push(x = new Intersection(p0, segment, null, true));\n    clip.push(x.o = new Intersection(p0, null, x, false));\n    subject.push(x = new Intersection(p1, segment, null, false));\n    clip.push(x.o = new Intersection(p1, null, x, true));\n  });\n\n  if (!subject.length) return;\n\n  clip.sort(compareIntersection);\n  link(subject);\n  link(clip);\n\n  for (i = 0, n = clip.length; i < n; ++i) {\n    clip[i].e = startInside = !startInside;\n  }\n\n  var start = subject[0],\n      points,\n      point;\n\n  while (1) {\n    // Find first unvisited intersection.\n    var current = start,\n        isSubject = true;\n    while (current.v) if ((current = current.n) === start) return;\n    points = current.z;\n    stream.lineStart();\n    do {\n      current.v = current.o.v = true;\n      if (current.e) {\n        if (isSubject) {\n          for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);\n        } else {\n          interpolate(current.x, current.n.x, 1, stream);\n        }\n        current = current.n;\n      } else {\n        if (isSubject) {\n          points = current.p.z;\n          for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);\n        } else {\n          interpolate(current.x, current.p.x, -1, stream);\n        }\n        current = current.p;\n      }\n      current = current.o;\n      points = current.z;\n      isSubject = !isSubject;\n    } while (!current.v);\n    stream.lineEnd();\n  }\n}\n\nfunction link(array) {\n  if (!(n = array.length)) return;\n  var n,\n      i = 0,\n      a = array[0],\n      b;\n  while (++i < n) {\n    a.n = b = array[i];\n    b.p = a;\n    a = b;\n  }\n  a.n = b = array[0];\n  b.p = a;\n}\n\nvar sum = adder();\n\nfunction polygonContains(polygon, point) {\n  var lambda = point[0],\n      phi = point[1],\n      sinPhi = sin(phi),\n      normal = [sin(lambda), -cos(lambda), 0],\n      angle = 0,\n      winding = 0;\n\n  sum.reset();\n\n  if (sinPhi === 1) phi = halfPi + epsilon;\n  else if (sinPhi === -1) phi = -halfPi - epsilon;\n\n  for (var i = 0, n = polygon.length; i < n; ++i) {\n    if (!(m = (ring = polygon[i]).length)) continue;\n    var ring,\n        m,\n        point0 = ring[m - 1],\n        lambda0 = point0[0],\n        phi0 = point0[1] / 2 + quarterPi,\n        sinPhi0 = sin(phi0),\n        cosPhi0 = cos(phi0);\n\n    for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {\n      var point1 = ring[j],\n          lambda1 = point1[0],\n          phi1 = point1[1] / 2 + quarterPi,\n          sinPhi1 = sin(phi1),\n          cosPhi1 = cos(phi1),\n          delta = lambda1 - lambda0,\n          sign$$1 = delta >= 0 ? 1 : -1,\n          absDelta = sign$$1 * delta,\n          antimeridian = absDelta > pi,\n          k = sinPhi0 * sinPhi1;\n\n      sum.add(atan2(k * sign$$1 * sin(absDelta), cosPhi0 * cosPhi1 + k * cos(absDelta)));\n      angle += antimeridian ? delta + sign$$1 * tau : delta;\n\n      // Are the longitudes either side of the point’s meridian (lambda),\n      // and are the latitudes smaller than the parallel (phi)?\n      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {\n        var arc = cartesianCross(cartesian(point0), cartesian(point1));\n        cartesianNormalizeInPlace(arc);\n        var intersection = cartesianCross(normal, arc);\n        cartesianNormalizeInPlace(intersection);\n        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);\n        if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {\n          winding += antimeridian ^ delta >= 0 ? 1 : -1;\n        }\n      }\n    }\n  }\n\n  // First, determine whether the South pole is inside or outside:\n  //\n  // It is inside if:\n  // * the polygon winds around it in a clockwise direction.\n  // * the polygon does not (cumulatively) wind around it, but has a negative\n  //   (counter-clockwise) area.\n  //\n  // Second, count the (signed) number of times a segment crosses a lambda\n  // from the point to the South pole.  If it is zero, then the point is the\n  // same side as the South pole.\n\n  return (angle < -epsilon || angle < epsilon && sum < -epsilon) ^ (winding & 1);\n}\n\nfunction clip(pointVisible, clipLine, interpolate, start) {\n  return function(sink) {\n    var line = clipLine(sink),\n        ringBuffer = clipBuffer(),\n        ringSink = clipLine(ringBuffer),\n        polygonStarted = false,\n        polygon,\n        segments,\n        ring;\n\n    var clip = {\n      point: point,\n      lineStart: lineStart,\n      lineEnd: lineEnd,\n      polygonStart: function() {\n        clip.point = pointRing;\n        clip.lineStart = ringStart;\n        clip.lineEnd = ringEnd;\n        segments = [];\n        polygon = [];\n      },\n      polygonEnd: function() {\n        clip.point = point;\n        clip.lineStart = lineStart;\n        clip.lineEnd = lineEnd;\n        segments = d3Array.merge(segments);\n        var startInside = polygonContains(polygon, start);\n        if (segments.length) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          clipRejoin(segments, compareIntersection, startInside, interpolate, sink);\n        } else if (startInside) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          sink.lineStart();\n          interpolate(null, null, 1, sink);\n          sink.lineEnd();\n        }\n        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;\n        segments = polygon = null;\n      },\n      sphere: function() {\n        sink.polygonStart();\n        sink.lineStart();\n        interpolate(null, null, 1, sink);\n        sink.lineEnd();\n        sink.polygonEnd();\n      }\n    };\n\n    function point(lambda, phi) {\n      if (pointVisible(lambda, phi)) sink.point(lambda, phi);\n    }\n\n    function pointLine(lambda, phi) {\n      line.point(lambda, phi);\n    }\n\n    function lineStart() {\n      clip.point = pointLine;\n      line.lineStart();\n    }\n\n    function lineEnd() {\n      clip.point = point;\n      line.lineEnd();\n    }\n\n    function pointRing(lambda, phi) {\n      ring.push([lambda, phi]);\n      ringSink.point(lambda, phi);\n    }\n\n    function ringStart() {\n      ringSink.lineStart();\n      ring = [];\n    }\n\n    function ringEnd() {\n      pointRing(ring[0][0], ring[0][1]);\n      ringSink.lineEnd();\n\n      var clean = ringSink.clean(),\n          ringSegments = ringBuffer.result(),\n          i, n = ringSegments.length, m,\n          segment,\n          point;\n\n      ring.pop();\n      polygon.push(ring);\n      ring = null;\n\n      if (!n) return;\n\n      // No intersections.\n      if (clean & 1) {\n        segment = ringSegments[0];\n        if ((m = segment.length - 1) > 0) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          sink.lineStart();\n          for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);\n          sink.lineEnd();\n        }\n        return;\n      }\n\n      // Rejoin connected segments.\n      // TODO reuse ringBuffer.rejoin()?\n      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));\n\n      segments.push(ringSegments.filter(validSegment));\n    }\n\n    return clip;\n  };\n}\n\nfunction validSegment(segment) {\n  return segment.length > 1;\n}\n\n// Intersections are sorted along the clip edge. For both antimeridian cutting\n// and circle clipping, the same comparison is used.\nfunction compareIntersection(a, b) {\n  return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon : halfPi - a[1])\n       - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon : halfPi - b[1]);\n}\n\nvar clipAntimeridian = clip(\n  function() { return true; },\n  clipAntimeridianLine,\n  clipAntimeridianInterpolate,\n  [-pi, -halfPi]\n);\n\n// Takes a line and cuts into visible segments. Return values: 0 - there were\n// intersections or the line was empty; 1 - no intersections; 2 - there were\n// intersections, and the first and last segments should be rejoined.\nfunction clipAntimeridianLine(stream) {\n  var lambda0 = NaN,\n      phi0 = NaN,\n      sign0 = NaN,\n      clean; // no intersections\n\n  return {\n    lineStart: function() {\n      stream.lineStart();\n      clean = 1;\n    },\n    point: function(lambda1, phi1) {\n      var sign1 = lambda1 > 0 ? pi : -pi,\n          delta = abs(lambda1 - lambda0);\n      if (abs(delta - pi) < epsilon) { // line crosses a pole\n        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi : -halfPi);\n        stream.point(sign0, phi0);\n        stream.lineEnd();\n        stream.lineStart();\n        stream.point(sign1, phi0);\n        stream.point(lambda1, phi0);\n        clean = 0;\n      } else if (sign0 !== sign1 && delta >= pi) { // line crosses antimeridian\n        if (abs(lambda0 - sign0) < epsilon) lambda0 -= sign0 * epsilon; // handle degeneracies\n        if (abs(lambda1 - sign1) < epsilon) lambda1 -= sign1 * epsilon;\n        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);\n        stream.point(sign0, phi0);\n        stream.lineEnd();\n        stream.lineStart();\n        stream.point(sign1, phi0);\n        clean = 0;\n      }\n      stream.point(lambda0 = lambda1, phi0 = phi1);\n      sign0 = sign1;\n    },\n    lineEnd: function() {\n      stream.lineEnd();\n      lambda0 = phi0 = NaN;\n    },\n    clean: function() {\n      return 2 - clean; // if intersections, rejoin first and last segments\n    }\n  };\n}\n\nfunction clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {\n  var cosPhi0,\n      cosPhi1,\n      sinLambda0Lambda1 = sin(lambda0 - lambda1);\n  return abs(sinLambda0Lambda1) > epsilon\n      ? atan((sin(phi0) * (cosPhi1 = cos(phi1)) * sin(lambda1)\n          - sin(phi1) * (cosPhi0 = cos(phi0)) * sin(lambda0))\n          / (cosPhi0 * cosPhi1 * sinLambda0Lambda1))\n      : (phi0 + phi1) / 2;\n}\n\nfunction clipAntimeridianInterpolate(from, to, direction, stream) {\n  var phi;\n  if (from == null) {\n    phi = direction * halfPi;\n    stream.point(-pi, phi);\n    stream.point(0, phi);\n    stream.point(pi, phi);\n    stream.point(pi, 0);\n    stream.point(pi, -phi);\n    stream.point(0, -phi);\n    stream.point(-pi, -phi);\n    stream.point(-pi, 0);\n    stream.point(-pi, phi);\n  } else if (abs(from[0] - to[0]) > epsilon) {\n    var lambda = from[0] < to[0] ? pi : -pi;\n    phi = direction * lambda / 2;\n    stream.point(-lambda, phi);\n    stream.point(0, phi);\n    stream.point(lambda, phi);\n  } else {\n    stream.point(to[0], to[1]);\n  }\n}\n\nfunction clipCircle(radius) {\n  var cr = cos(radius),\n      delta = 6 * radians,\n      smallRadius = cr > 0,\n      notHemisphere = abs(cr) > epsilon; // TODO optimise for this common case\n\n  function interpolate(from, to, direction, stream) {\n    circleStream(stream, radius, delta, direction, from, to);\n  }\n\n  function visible(lambda, phi) {\n    return cos(lambda) * cos(phi) > cr;\n  }\n\n  // Takes a line and cuts into visible segments. Return values used for polygon\n  // clipping: 0 - there were intersections or the line was empty; 1 - no\n  // intersections 2 - there were intersections, and the first and last segments\n  // should be rejoined.\n  function clipLine(stream) {\n    var point0, // previous point\n        c0, // code for previous point\n        v0, // visibility of previous point\n        v00, // visibility of first point\n        clean; // no intersections\n    return {\n      lineStart: function() {\n        v00 = v0 = false;\n        clean = 1;\n      },\n      point: function(lambda, phi) {\n        var point1 = [lambda, phi],\n            point2,\n            v = visible(lambda, phi),\n            c = smallRadius\n              ? v ? 0 : code(lambda, phi)\n              : v ? code(lambda + (lambda < 0 ? pi : -pi), phi) : 0;\n        if (!point0 && (v00 = v0 = v)) stream.lineStart();\n        // Handle degeneracies.\n        // TODO ignore if not clipping polygons.\n        if (v !== v0) {\n          point2 = intersect(point0, point1);\n          if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2)) {\n            point1[0] += epsilon;\n            point1[1] += epsilon;\n            v = visible(point1[0], point1[1]);\n          }\n        }\n        if (v !== v0) {\n          clean = 0;\n          if (v) {\n            // outside going in\n            stream.lineStart();\n            point2 = intersect(point1, point0);\n            stream.point(point2[0], point2[1]);\n          } else {\n            // inside going out\n            point2 = intersect(point0, point1);\n            stream.point(point2[0], point2[1]);\n            stream.lineEnd();\n          }\n          point0 = point2;\n        } else if (notHemisphere && point0 && smallRadius ^ v) {\n          var t;\n          // If the codes for two points are different, or are both zero,\n          // and there this segment intersects with the small circle.\n          if (!(c & c0) && (t = intersect(point1, point0, true))) {\n            clean = 0;\n            if (smallRadius) {\n              stream.lineStart();\n              stream.point(t[0][0], t[0][1]);\n              stream.point(t[1][0], t[1][1]);\n              stream.lineEnd();\n            } else {\n              stream.point(t[1][0], t[1][1]);\n              stream.lineEnd();\n              stream.lineStart();\n              stream.point(t[0][0], t[0][1]);\n            }\n          }\n        }\n        if (v && (!point0 || !pointEqual(point0, point1))) {\n          stream.point(point1[0], point1[1]);\n        }\n        point0 = point1, v0 = v, c0 = c;\n      },\n      lineEnd: function() {\n        if (v0) stream.lineEnd();\n        point0 = null;\n      },\n      // Rejoin first and last segments if there were intersections and the first\n      // and last points were visible.\n      clean: function() {\n        return clean | ((v00 && v0) << 1);\n      }\n    };\n  }\n\n  // Intersects the great circle between a and b with the clip circle.\n  function intersect(a, b, two) {\n    var pa = cartesian(a),\n        pb = cartesian(b);\n\n    // We have two planes, n1.p = d1 and n2.p = d2.\n    // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 ⨯ n2).\n    var n1 = [1, 0, 0], // normal\n        n2 = cartesianCross(pa, pb),\n        n2n2 = cartesianDot(n2, n2),\n        n1n2 = n2[0], // cartesianDot(n1, n2),\n        determinant = n2n2 - n1n2 * n1n2;\n\n    // Two polar points.\n    if (!determinant) return !two && a;\n\n    var c1 =  cr * n2n2 / determinant,\n        c2 = -cr * n1n2 / determinant,\n        n1xn2 = cartesianCross(n1, n2),\n        A = cartesianScale(n1, c1),\n        B = cartesianScale(n2, c2);\n    cartesianAddInPlace(A, B);\n\n    // Solve |p(t)|^2 = 1.\n    var u = n1xn2,\n        w = cartesianDot(A, u),\n        uu = cartesianDot(u, u),\n        t2 = w * w - uu * (cartesianDot(A, A) - 1);\n\n    if (t2 < 0) return;\n\n    var t = sqrt(t2),\n        q = cartesianScale(u, (-w - t) / uu);\n    cartesianAddInPlace(q, A);\n    q = spherical(q);\n\n    if (!two) return q;\n\n    // Two intersection points.\n    var lambda0 = a[0],\n        lambda1 = b[0],\n        phi0 = a[1],\n        phi1 = b[1],\n        z;\n\n    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;\n\n    var delta = lambda1 - lambda0,\n        polar = abs(delta - pi) < epsilon,\n        meridian = polar || delta < epsilon;\n\n    if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;\n\n    // Check that the first point is between a and b.\n    if (meridian\n        ? polar\n          ? phi0 + phi1 > 0 ^ q[1] < (abs(q[0] - lambda0) < epsilon ? phi0 : phi1)\n          : phi0 <= q[1] && q[1] <= phi1\n        : delta > pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {\n      var q1 = cartesianScale(u, (-w + t) / uu);\n      cartesianAddInPlace(q1, A);\n      return [q, spherical(q1)];\n    }\n  }\n\n  // Generates a 4-bit vector representing the location of a point relative to\n  // the small circle's bounding box.\n  function code(lambda, phi) {\n    var r = smallRadius ? radius : pi - radius,\n        code = 0;\n    if (lambda < -r) code |= 1; // left\n    else if (lambda > r) code |= 2; // right\n    if (phi < -r) code |= 4; // below\n    else if (phi > r) code |= 8; // above\n    return code;\n  }\n\n  return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi, radius - pi]);\n}\n\nfunction clipLine(a, b, x0, y0, x1, y1) {\n  var ax = a[0],\n      ay = a[1],\n      bx = b[0],\n      by = b[1],\n      t0 = 0,\n      t1 = 1,\n      dx = bx - ax,\n      dy = by - ay,\n      r;\n\n  r = x0 - ax;\n  if (!dx && r > 0) return;\n  r /= dx;\n  if (dx < 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  } else if (dx > 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  }\n\n  r = x1 - ax;\n  if (!dx && r < 0) return;\n  r /= dx;\n  if (dx < 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  } else if (dx > 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  }\n\n  r = y0 - ay;\n  if (!dy && r > 0) return;\n  r /= dy;\n  if (dy < 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  } else if (dy > 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  }\n\n  r = y1 - ay;\n  if (!dy && r < 0) return;\n  r /= dy;\n  if (dy < 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  } else if (dy > 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  }\n\n  if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;\n  if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;\n  return true;\n}\n\nvar clipMax = 1e9;\nvar clipMin = -clipMax;\n\n// TODO Use d3-polygon’s polygonContains here for the ring check?\n// TODO Eliminate duplicate buffering in clipBuffer and polygon.push?\n\nfunction clipRectangle(x0, y0, x1, y1) {\n\n  function visible(x, y) {\n    return x0 <= x && x <= x1 && y0 <= y && y <= y1;\n  }\n\n  function interpolate(from, to, direction, stream) {\n    var a = 0, a1 = 0;\n    if (from == null\n        || (a = corner(from, direction)) !== (a1 = corner(to, direction))\n        || comparePoint(from, to) < 0 ^ direction > 0) {\n      do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);\n      while ((a = (a + direction + 4) % 4) !== a1);\n    } else {\n      stream.point(to[0], to[1]);\n    }\n  }\n\n  function corner(p, direction) {\n    return abs(p[0] - x0) < epsilon ? direction > 0 ? 0 : 3\n        : abs(p[0] - x1) < epsilon ? direction > 0 ? 2 : 1\n        : abs(p[1] - y0) < epsilon ? direction > 0 ? 1 : 0\n        : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon\n  }\n\n  function compareIntersection(a, b) {\n    return comparePoint(a.x, b.x);\n  }\n\n  function comparePoint(a, b) {\n    var ca = corner(a, 1),\n        cb = corner(b, 1);\n    return ca !== cb ? ca - cb\n        : ca === 0 ? b[1] - a[1]\n        : ca === 1 ? a[0] - b[0]\n        : ca === 2 ? a[1] - b[1]\n        : b[0] - a[0];\n  }\n\n  return function(stream) {\n    var activeStream = stream,\n        bufferStream = clipBuffer(),\n        segments,\n        polygon,\n        ring,\n        x__, y__, v__, // first point\n        x_, y_, v_, // previous point\n        first,\n        clean;\n\n    var clipStream = {\n      point: point,\n      lineStart: lineStart,\n      lineEnd: lineEnd,\n      polygonStart: polygonStart,\n      polygonEnd: polygonEnd\n    };\n\n    function point(x, y) {\n      if (visible(x, y)) activeStream.point(x, y);\n    }\n\n    function polygonInside() {\n      var winding = 0;\n\n      for (var i = 0, n = polygon.length; i < n; ++i) {\n        for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {\n          a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];\n          if (a1 <= y1) { if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding; }\n          else { if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding; }\n        }\n      }\n\n      return winding;\n    }\n\n    // Buffer geometry within a polygon and then clip it en masse.\n    function polygonStart() {\n      activeStream = bufferStream, segments = [], polygon = [], clean = true;\n    }\n\n    function polygonEnd() {\n      var startInside = polygonInside(),\n          cleanInside = clean && startInside,\n          visible = (segments = d3Array.merge(segments)).length;\n      if (cleanInside || visible) {\n        stream.polygonStart();\n        if (cleanInside) {\n          stream.lineStart();\n          interpolate(null, null, 1, stream);\n          stream.lineEnd();\n        }\n        if (visible) {\n          clipRejoin(segments, compareIntersection, startInside, interpolate, stream);\n        }\n        stream.polygonEnd();\n      }\n      activeStream = stream, segments = polygon = ring = null;\n    }\n\n    function lineStart() {\n      clipStream.point = linePoint;\n      if (polygon) polygon.push(ring = []);\n      first = true;\n      v_ = false;\n      x_ = y_ = NaN;\n    }\n\n    // TODO rather than special-case polygons, simply handle them separately.\n    // Ideally, coincident intersection points should be jittered to avoid\n    // clipping issues.\n    function lineEnd() {\n      if (segments) {\n        linePoint(x__, y__);\n        if (v__ && v_) bufferStream.rejoin();\n        segments.push(bufferStream.result());\n      }\n      clipStream.point = point;\n      if (v_) activeStream.lineEnd();\n    }\n\n    function linePoint(x, y) {\n      var v = visible(x, y);\n      if (polygon) ring.push([x, y]);\n      if (first) {\n        x__ = x, y__ = y, v__ = v;\n        first = false;\n        if (v) {\n          activeStream.lineStart();\n          activeStream.point(x, y);\n        }\n      } else {\n        if (v && v_) activeStream.point(x, y);\n        else {\n          var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],\n              b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];\n          if (clipLine(a, b, x0, y0, x1, y1)) {\n            if (!v_) {\n              activeStream.lineStart();\n              activeStream.point(a[0], a[1]);\n            }\n            activeStream.point(b[0], b[1]);\n            if (!v) activeStream.lineEnd();\n            clean = false;\n          } else if (v) {\n            activeStream.lineStart();\n            activeStream.point(x, y);\n            clean = false;\n          }\n        }\n      }\n      x_ = x, y_ = y, v_ = v;\n    }\n\n    return clipStream;\n  };\n}\n\nfunction extent() {\n  var x0 = 0,\n      y0 = 0,\n      x1 = 960,\n      y1 = 500,\n      cache,\n      cacheStream,\n      clip;\n\n  return clip = {\n    stream: function(stream) {\n      return cache && cacheStream === stream ? cache : cache = clipRectangle(x0, y0, x1, y1)(cacheStream = stream);\n    },\n    extent: function(_) {\n      return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [[x0, y0], [x1, y1]];\n    }\n  };\n}\n\nvar lengthSum = adder();\nvar lambda0$2;\nvar sinPhi0$1;\nvar cosPhi0$1;\n\nvar lengthStream = {\n  sphere: noop,\n  point: noop,\n  lineStart: lengthLineStart,\n  lineEnd: noop,\n  polygonStart: noop,\n  polygonEnd: noop\n};\n\nfunction lengthLineStart() {\n  lengthStream.point = lengthPointFirst;\n  lengthStream.lineEnd = lengthLineEnd;\n}\n\nfunction lengthLineEnd() {\n  lengthStream.point = lengthStream.lineEnd = noop;\n}\n\nfunction lengthPointFirst(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  lambda0$2 = lambda, sinPhi0$1 = sin(phi), cosPhi0$1 = cos(phi);\n  lengthStream.point = lengthPoint;\n}\n\nfunction lengthPoint(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  var sinPhi = sin(phi),\n      cosPhi = cos(phi),\n      delta = abs(lambda - lambda0$2),\n      cosDelta = cos(delta),\n      sinDelta = sin(delta),\n      x = cosPhi * sinDelta,\n      y = cosPhi0$1 * sinPhi - sinPhi0$1 * cosPhi * cosDelta,\n      z = sinPhi0$1 * sinPhi + cosPhi0$1 * cosPhi * cosDelta;\n  lengthSum.add(atan2(sqrt(x * x + y * y), z));\n  lambda0$2 = lambda, sinPhi0$1 = sinPhi, cosPhi0$1 = cosPhi;\n}\n\nfunction length(object) {\n  lengthSum.reset();\n  geoStream(object, lengthStream);\n  return +lengthSum;\n}\n\nvar coordinates = [null, null];\nvar object = {type: \"LineString\", coordinates: coordinates};\n\nfunction distance(a, b) {\n  coordinates[0] = a;\n  coordinates[1] = b;\n  return length(object);\n}\n\nvar containsObjectType = {\n  Feature: function(object, point) {\n    return containsGeometry(object.geometry, point);\n  },\n  FeatureCollection: function(object, point) {\n    var features = object.features, i = -1, n = features.length;\n    while (++i < n) if (containsGeometry(features[i].geometry, point)) return true;\n    return false;\n  }\n};\n\nvar containsGeometryType = {\n  Sphere: function() {\n    return true;\n  },\n  Point: function(object, point) {\n    return containsPoint(object.coordinates, point);\n  },\n  MultiPoint: function(object, point) {\n    var coordinates = object.coordinates, i = -1, n = coordinates.length;\n    while (++i < n) if (containsPoint(coordinates[i], point)) return true;\n    return false;\n  },\n  LineString: function(object, point) {\n    return containsLine(object.coordinates, point);\n  },\n  MultiLineString: function(object, point) {\n    var coordinates = object.coordinates, i = -1, n = coordinates.length;\n    while (++i < n) if (containsLine(coordinates[i], point)) return true;\n    return false;\n  },\n  Polygon: function(object, point) {\n    return containsPolygon(object.coordinates, point);\n  },\n  MultiPolygon: function(object, point) {\n    var coordinates = object.coordinates, i = -1, n = coordinates.length;\n    while (++i < n) if (containsPolygon(coordinates[i], point)) return true;\n    return false;\n  },\n  GeometryCollection: function(object, point) {\n    var geometries = object.geometries, i = -1, n = geometries.length;\n    while (++i < n) if (containsGeometry(geometries[i], point)) return true;\n    return false;\n  }\n};\n\nfunction containsGeometry(geometry, point) {\n  return geometry && containsGeometryType.hasOwnProperty(geometry.type)\n      ? containsGeometryType[geometry.type](geometry, point)\n      : false;\n}\n\nfunction containsPoint(coordinates, point) {\n  return distance(coordinates, point) === 0;\n}\n\nfunction containsLine(coordinates, point) {\n  var ab = distance(coordinates[0], coordinates[1]),\n      ao = distance(coordinates[0], point),\n      ob = distance(point, coordinates[1]);\n  return ao + ob <= ab + epsilon;\n}\n\nfunction containsPolygon(coordinates, point) {\n  return !!polygonContains(coordinates.map(ringRadians), pointRadians(point));\n}\n\nfunction ringRadians(ring) {\n  return ring = ring.map(pointRadians), ring.pop(), ring;\n}\n\nfunction pointRadians(point) {\n  return [point[0] * radians, point[1] * radians];\n}\n\nfunction contains(object, point) {\n  return (object && containsObjectType.hasOwnProperty(object.type)\n      ? containsObjectType[object.type]\n      : containsGeometry)(object, point);\n}\n\nfunction graticuleX(y0, y1, dy) {\n  var y = d3Array.range(y0, y1 - epsilon, dy).concat(y1);\n  return function(x) { return y.map(function(y) { return [x, y]; }); };\n}\n\nfunction graticuleY(x0, x1, dx) {\n  var x = d3Array.range(x0, x1 - epsilon, dx).concat(x1);\n  return function(y) { return x.map(function(x) { return [x, y]; }); };\n}\n\nfunction graticule() {\n  var x1, x0, X1, X0,\n      y1, y0, Y1, Y0,\n      dx = 10, dy = dx, DX = 90, DY = 360,\n      x, y, X, Y,\n      precision = 2.5;\n\n  function graticule() {\n    return {type: \"MultiLineString\", coordinates: lines()};\n  }\n\n  function lines() {\n    return d3Array.range(ceil(X0 / DX) * DX, X1, DX).map(X)\n        .concat(d3Array.range(ceil(Y0 / DY) * DY, Y1, DY).map(Y))\n        .concat(d3Array.range(ceil(x0 / dx) * dx, x1, dx).filter(function(x) { return abs(x % DX) > epsilon; }).map(x))\n        .concat(d3Array.range(ceil(y0 / dy) * dy, y1, dy).filter(function(y) { return abs(y % DY) > epsilon; }).map(y));\n  }\n\n  graticule.lines = function() {\n    return lines().map(function(coordinates) { return {type: \"LineString\", coordinates: coordinates}; });\n  };\n\n  graticule.outline = function() {\n    return {\n      type: \"Polygon\",\n      coordinates: [\n        X(X0).concat(\n        Y(Y1).slice(1),\n        X(X1).reverse().slice(1),\n        Y(Y0).reverse().slice(1))\n      ]\n    };\n  };\n\n  graticule.extent = function(_) {\n    if (!arguments.length) return graticule.extentMinor();\n    return graticule.extentMajor(_).extentMinor(_);\n  };\n\n  graticule.extentMajor = function(_) {\n    if (!arguments.length) return [[X0, Y0], [X1, Y1]];\n    X0 = +_[0][0], X1 = +_[1][0];\n    Y0 = +_[0][1], Y1 = +_[1][1];\n    if (X0 > X1) _ = X0, X0 = X1, X1 = _;\n    if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;\n    return graticule.precision(precision);\n  };\n\n  graticule.extentMinor = function(_) {\n    if (!arguments.length) return [[x0, y0], [x1, y1]];\n    x0 = +_[0][0], x1 = +_[1][0];\n    y0 = +_[0][1], y1 = +_[1][1];\n    if (x0 > x1) _ = x0, x0 = x1, x1 = _;\n    if (y0 > y1) _ = y0, y0 = y1, y1 = _;\n    return graticule.precision(precision);\n  };\n\n  graticule.step = function(_) {\n    if (!arguments.length) return graticule.stepMinor();\n    return graticule.stepMajor(_).stepMinor(_);\n  };\n\n  graticule.stepMajor = function(_) {\n    if (!arguments.length) return [DX, DY];\n    DX = +_[0], DY = +_[1];\n    return graticule;\n  };\n\n  graticule.stepMinor = function(_) {\n    if (!arguments.length) return [dx, dy];\n    dx = +_[0], dy = +_[1];\n    return graticule;\n  };\n\n  graticule.precision = function(_) {\n    if (!arguments.length) return precision;\n    precision = +_;\n    x = graticuleX(y0, y1, 90);\n    y = graticuleY(x0, x1, precision);\n    X = graticuleX(Y0, Y1, 90);\n    Y = graticuleY(X0, X1, precision);\n    return graticule;\n  };\n\n  return graticule\n      .extentMajor([[-180, -90 + epsilon], [180, 90 - epsilon]])\n      .extentMinor([[-180, -80 - epsilon], [180, 80 + epsilon]]);\n}\n\nfunction graticule10() {\n  return graticule()();\n}\n\nfunction interpolate(a, b) {\n  var x0 = a[0] * radians,\n      y0 = a[1] * radians,\n      x1 = b[0] * radians,\n      y1 = b[1] * radians,\n      cy0 = cos(y0),\n      sy0 = sin(y0),\n      cy1 = cos(y1),\n      sy1 = sin(y1),\n      kx0 = cy0 * cos(x0),\n      ky0 = cy0 * sin(x0),\n      kx1 = cy1 * cos(x1),\n      ky1 = cy1 * sin(x1),\n      d = 2 * asin(sqrt(haversin(y1 - y0) + cy0 * cy1 * haversin(x1 - x0))),\n      k = sin(d);\n\n  var interpolate = d ? function(t) {\n    var B = sin(t *= d) / k,\n        A = sin(d - t) / k,\n        x = A * kx0 + B * kx1,\n        y = A * ky0 + B * ky1,\n        z = A * sy0 + B * sy1;\n    return [\n      atan2(y, x) * degrees,\n      atan2(z, sqrt(x * x + y * y)) * degrees\n    ];\n  } : function() {\n    return [x0 * degrees, y0 * degrees];\n  };\n\n  interpolate.distance = d;\n\n  return interpolate;\n}\n\nfunction identity(x) {\n  return x;\n}\n\nvar areaSum$1 = adder();\nvar areaRingSum$1 = adder();\nvar x00;\nvar y00;\nvar x0$1;\nvar y0$1;\n\nvar areaStream$1 = {\n  point: noop,\n  lineStart: noop,\n  lineEnd: noop,\n  polygonStart: function() {\n    areaStream$1.lineStart = areaRingStart$1;\n    areaStream$1.lineEnd = areaRingEnd$1;\n  },\n  polygonEnd: function() {\n    areaStream$1.lineStart = areaStream$1.lineEnd = areaStream$1.point = noop;\n    areaSum$1.add(abs(areaRingSum$1));\n    areaRingSum$1.reset();\n  },\n  result: function() {\n    var area = areaSum$1 / 2;\n    areaSum$1.reset();\n    return area;\n  }\n};\n\nfunction areaRingStart$1() {\n  areaStream$1.point = areaPointFirst$1;\n}\n\nfunction areaPointFirst$1(x, y) {\n  areaStream$1.point = areaPoint$1;\n  x00 = x0$1 = x, y00 = y0$1 = y;\n}\n\nfunction areaPoint$1(x, y) {\n  areaRingSum$1.add(y0$1 * x - x0$1 * y);\n  x0$1 = x, y0$1 = y;\n}\n\nfunction areaRingEnd$1() {\n  areaPoint$1(x00, y00);\n}\n\nvar x0$2 = Infinity;\nvar y0$2 = x0$2;\nvar x1 = -x0$2;\nvar y1 = x1;\n\nvar boundsStream$1 = {\n  point: boundsPoint$1,\n  lineStart: noop,\n  lineEnd: noop,\n  polygonStart: noop,\n  polygonEnd: noop,\n  result: function() {\n    var bounds = [[x0$2, y0$2], [x1, y1]];\n    x1 = y1 = -(y0$2 = x0$2 = Infinity);\n    return bounds;\n  }\n};\n\nfunction boundsPoint$1(x, y) {\n  if (x < x0$2) x0$2 = x;\n  if (x > x1) x1 = x;\n  if (y < y0$2) y0$2 = y;\n  if (y > y1) y1 = y;\n}\n\n// TODO Enforce positive area for exterior, negative area for interior?\n\nvar X0$1 = 0;\nvar Y0$1 = 0;\nvar Z0$1 = 0;\nvar X1$1 = 0;\nvar Y1$1 = 0;\nvar Z1$1 = 0;\nvar X2$1 = 0;\nvar Y2$1 = 0;\nvar Z2$1 = 0;\nvar x00$1;\nvar y00$1;\nvar x0$3;\nvar y0$3;\n\nvar centroidStream$1 = {\n  point: centroidPoint$1,\n  lineStart: centroidLineStart$1,\n  lineEnd: centroidLineEnd$1,\n  polygonStart: function() {\n    centroidStream$1.lineStart = centroidRingStart$1;\n    centroidStream$1.lineEnd = centroidRingEnd$1;\n  },\n  polygonEnd: function() {\n    centroidStream$1.point = centroidPoint$1;\n    centroidStream$1.lineStart = centroidLineStart$1;\n    centroidStream$1.lineEnd = centroidLineEnd$1;\n  },\n  result: function() {\n    var centroid = Z2$1 ? [X2$1 / Z2$1, Y2$1 / Z2$1]\n        : Z1$1 ? [X1$1 / Z1$1, Y1$1 / Z1$1]\n        : Z0$1 ? [X0$1 / Z0$1, Y0$1 / Z0$1]\n        : [NaN, NaN];\n    X0$1 = Y0$1 = Z0$1 =\n    X1$1 = Y1$1 = Z1$1 =\n    X2$1 = Y2$1 = Z2$1 = 0;\n    return centroid;\n  }\n};\n\nfunction centroidPoint$1(x, y) {\n  X0$1 += x;\n  Y0$1 += y;\n  ++Z0$1;\n}\n\nfunction centroidLineStart$1() {\n  centroidStream$1.point = centroidPointFirstLine;\n}\n\nfunction centroidPointFirstLine(x, y) {\n  centroidStream$1.point = centroidPointLine;\n  centroidPoint$1(x0$3 = x, y0$3 = y);\n}\n\nfunction centroidPointLine(x, y) {\n  var dx = x - x0$3, dy = y - y0$3, z = sqrt(dx * dx + dy * dy);\n  X1$1 += z * (x0$3 + x) / 2;\n  Y1$1 += z * (y0$3 + y) / 2;\n  Z1$1 += z;\n  centroidPoint$1(x0$3 = x, y0$3 = y);\n}\n\nfunction centroidLineEnd$1() {\n  centroidStream$1.point = centroidPoint$1;\n}\n\nfunction centroidRingStart$1() {\n  centroidStream$1.point = centroidPointFirstRing;\n}\n\nfunction centroidRingEnd$1() {\n  centroidPointRing(x00$1, y00$1);\n}\n\nfunction centroidPointFirstRing(x, y) {\n  centroidStream$1.point = centroidPointRing;\n  centroidPoint$1(x00$1 = x0$3 = x, y00$1 = y0$3 = y);\n}\n\nfunction centroidPointRing(x, y) {\n  var dx = x - x0$3,\n      dy = y - y0$3,\n      z = sqrt(dx * dx + dy * dy);\n\n  X1$1 += z * (x0$3 + x) / 2;\n  Y1$1 += z * (y0$3 + y) / 2;\n  Z1$1 += z;\n\n  z = y0$3 * x - x0$3 * y;\n  X2$1 += z * (x0$3 + x);\n  Y2$1 += z * (y0$3 + y);\n  Z2$1 += z * 3;\n  centroidPoint$1(x0$3 = x, y0$3 = y);\n}\n\nfunction PathContext(context) {\n  this._context = context;\n}\n\nPathContext.prototype = {\n  _radius: 4.5,\n  pointRadius: function(_) {\n    return this._radius = _, this;\n  },\n  polygonStart: function() {\n    this._line = 0;\n  },\n  polygonEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line === 0) this._context.closePath();\n    this._point = NaN;\n  },\n  point: function(x, y) {\n    switch (this._point) {\n      case 0: {\n        this._context.moveTo(x, y);\n        this._point = 1;\n        break;\n      }\n      case 1: {\n        this._context.lineTo(x, y);\n        break;\n      }\n      default: {\n        this._context.moveTo(x + this._radius, y);\n        this._context.arc(x, y, this._radius, 0, tau);\n        break;\n      }\n    }\n  },\n  result: noop\n};\n\nvar lengthSum$1 = adder();\nvar lengthRing;\nvar x00$2;\nvar y00$2;\nvar x0$4;\nvar y0$4;\n\nvar lengthStream$1 = {\n  point: noop,\n  lineStart: function() {\n    lengthStream$1.point = lengthPointFirst$1;\n  },\n  lineEnd: function() {\n    if (lengthRing) lengthPoint$1(x00$2, y00$2);\n    lengthStream$1.point = noop;\n  },\n  polygonStart: function() {\n    lengthRing = true;\n  },\n  polygonEnd: function() {\n    lengthRing = null;\n  },\n  result: function() {\n    var length = +lengthSum$1;\n    lengthSum$1.reset();\n    return length;\n  }\n};\n\nfunction lengthPointFirst$1(x, y) {\n  lengthStream$1.point = lengthPoint$1;\n  x00$2 = x0$4 = x, y00$2 = y0$4 = y;\n}\n\nfunction lengthPoint$1(x, y) {\n  x0$4 -= x, y0$4 -= y;\n  lengthSum$1.add(sqrt(x0$4 * x0$4 + y0$4 * y0$4));\n  x0$4 = x, y0$4 = y;\n}\n\nfunction PathString() {\n  this._string = [];\n}\n\nPathString.prototype = {\n  _radius: 4.5,\n  _circle: circle$1(4.5),\n  pointRadius: function(_) {\n    if ((_ = +_) !== this._radius) this._radius = _, this._circle = null;\n    return this;\n  },\n  polygonStart: function() {\n    this._line = 0;\n  },\n  polygonEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line === 0) this._string.push(\"Z\");\n    this._point = NaN;\n  },\n  point: function(x, y) {\n    switch (this._point) {\n      case 0: {\n        this._string.push(\"M\", x, \",\", y);\n        this._point = 1;\n        break;\n      }\n      case 1: {\n        this._string.push(\"L\", x, \",\", y);\n        break;\n      }\n      default: {\n        if (this._circle == null) this._circle = circle$1(this._radius);\n        this._string.push(\"M\", x, \",\", y, this._circle);\n        break;\n      }\n    }\n  },\n  result: function() {\n    if (this._string.length) {\n      var result = this._string.join(\"\");\n      this._string = [];\n      return result;\n    } else {\n      return null;\n    }\n  }\n};\n\nfunction circle$1(radius) {\n  return \"m0,\" + radius\n      + \"a\" + radius + \",\" + radius + \" 0 1,1 0,\" + -2 * radius\n      + \"a\" + radius + \",\" + radius + \" 0 1,1 0,\" + 2 * radius\n      + \"z\";\n}\n\nfunction index(projection, context) {\n  var pointRadius = 4.5,\n      projectionStream,\n      contextStream;\n\n  function path(object) {\n    if (object) {\n      if (typeof pointRadius === \"function\") contextStream.pointRadius(+pointRadius.apply(this, arguments));\n      geoStream(object, projectionStream(contextStream));\n    }\n    return contextStream.result();\n  }\n\n  path.area = function(object) {\n    geoStream(object, projectionStream(areaStream$1));\n    return areaStream$1.result();\n  };\n\n  path.measure = function(object) {\n    geoStream(object, projectionStream(lengthStream$1));\n    return lengthStream$1.result();\n  };\n\n  path.bounds = function(object) {\n    geoStream(object, projectionStream(boundsStream$1));\n    return boundsStream$1.result();\n  };\n\n  path.centroid = function(object) {\n    geoStream(object, projectionStream(centroidStream$1));\n    return centroidStream$1.result();\n  };\n\n  path.projection = function(_) {\n    return arguments.length ? (projectionStream = _ == null ? (projection = null, identity) : (projection = _).stream, path) : projection;\n  };\n\n  path.context = function(_) {\n    if (!arguments.length) return context;\n    contextStream = _ == null ? (context = null, new PathString) : new PathContext(context = _);\n    if (typeof pointRadius !== \"function\") contextStream.pointRadius(pointRadius);\n    return path;\n  };\n\n  path.pointRadius = function(_) {\n    if (!arguments.length) return pointRadius;\n    pointRadius = typeof _ === \"function\" ? _ : (contextStream.pointRadius(+_), +_);\n    return path;\n  };\n\n  return path.projection(projection).context(context);\n}\n\nfunction transform(methods) {\n  return {\n    stream: transformer(methods)\n  };\n}\n\nfunction transformer(methods) {\n  return function(stream) {\n    var s = new TransformStream;\n    for (var key in methods) s[key] = methods[key];\n    s.stream = stream;\n    return s;\n  };\n}\n\nfunction TransformStream() {}\n\nTransformStream.prototype = {\n  constructor: TransformStream,\n  point: function(x, y) { this.stream.point(x, y); },\n  sphere: function() { this.stream.sphere(); },\n  lineStart: function() { this.stream.lineStart(); },\n  lineEnd: function() { this.stream.lineEnd(); },\n  polygonStart: function() { this.stream.polygonStart(); },\n  polygonEnd: function() { this.stream.polygonEnd(); }\n};\n\nfunction fit(projection, fitBounds, object) {\n  var clip = projection.clipExtent && projection.clipExtent();\n  projection.scale(150).translate([0, 0]);\n  if (clip != null) projection.clipExtent(null);\n  geoStream(object, projection.stream(boundsStream$1));\n  fitBounds(boundsStream$1.result());\n  if (clip != null) projection.clipExtent(clip);\n  return projection;\n}\n\nfunction fitExtent(projection, extent, object) {\n  return fit(projection, function(b) {\n    var w = extent[1][0] - extent[0][0],\n        h = extent[1][1] - extent[0][1],\n        k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),\n        x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,\n        y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;\n    projection.scale(150 * k).translate([x, y]);\n  }, object);\n}\n\nfunction fitSize(projection, size, object) {\n  return fitExtent(projection, [[0, 0], size], object);\n}\n\nfunction fitWidth(projection, width, object) {\n  return fit(projection, function(b) {\n    var w = +width,\n        k = w / (b[1][0] - b[0][0]),\n        x = (w - k * (b[1][0] + b[0][0])) / 2,\n        y = -k * b[0][1];\n    projection.scale(150 * k).translate([x, y]);\n  }, object);\n}\n\nfunction fitHeight(projection, height, object) {\n  return fit(projection, function(b) {\n    var h = +height,\n        k = h / (b[1][1] - b[0][1]),\n        x = -k * b[0][0],\n        y = (h - k * (b[1][1] + b[0][1])) / 2;\n    projection.scale(150 * k).translate([x, y]);\n  }, object);\n}\n\nvar maxDepth = 16;\nvar cosMinDistance = cos(30 * radians); // cos(minimum angular distance)\n\nfunction resample(project, delta2) {\n  return +delta2 ? resample$1(project, delta2) : resampleNone(project);\n}\n\nfunction resampleNone(project) {\n  return transformer({\n    point: function(x, y) {\n      x = project(x, y);\n      this.stream.point(x[0], x[1]);\n    }\n  });\n}\n\nfunction resample$1(project, delta2) {\n\n  function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {\n    var dx = x1 - x0,\n        dy = y1 - y0,\n        d2 = dx * dx + dy * dy;\n    if (d2 > 4 * delta2 && depth--) {\n      var a = a0 + a1,\n          b = b0 + b1,\n          c = c0 + c1,\n          m = sqrt(a * a + b * b + c * c),\n          phi2 = asin(c /= m),\n          lambda2 = abs(abs(c) - 1) < epsilon || abs(lambda0 - lambda1) < epsilon ? (lambda0 + lambda1) / 2 : atan2(b, a),\n          p = project(lambda2, phi2),\n          x2 = p[0],\n          y2 = p[1],\n          dx2 = x2 - x0,\n          dy2 = y2 - y0,\n          dz = dy * dx2 - dx * dy2;\n      if (dz * dz / d2 > delta2 // perpendicular projected distance\n          || abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end\n          || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) { // angular distance\n        resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);\n        stream.point(x2, y2);\n        resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);\n      }\n    }\n  }\n  return function(stream) {\n    var lambda00, x00, y00, a00, b00, c00, // first point\n        lambda0, x0, y0, a0, b0, c0; // previous point\n\n    var resampleStream = {\n      point: point,\n      lineStart: lineStart,\n      lineEnd: lineEnd,\n      polygonStart: function() { stream.polygonStart(); resampleStream.lineStart = ringStart; },\n      polygonEnd: function() { stream.polygonEnd(); resampleStream.lineStart = lineStart; }\n    };\n\n    function point(x, y) {\n      x = project(x, y);\n      stream.point(x[0], x[1]);\n    }\n\n    function lineStart() {\n      x0 = NaN;\n      resampleStream.point = linePoint;\n      stream.lineStart();\n    }\n\n    function linePoint(lambda, phi) {\n      var c = cartesian([lambda, phi]), p = project(lambda, phi);\n      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);\n      stream.point(x0, y0);\n    }\n\n    function lineEnd() {\n      resampleStream.point = point;\n      stream.lineEnd();\n    }\n\n    function ringStart() {\n      lineStart();\n      resampleStream.point = ringPoint;\n      resampleStream.lineEnd = ringEnd;\n    }\n\n    function ringPoint(lambda, phi) {\n      linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;\n      resampleStream.point = linePoint;\n    }\n\n    function ringEnd() {\n      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);\n      resampleStream.lineEnd = lineEnd;\n      lineEnd();\n    }\n\n    return resampleStream;\n  };\n}\n\nvar transformRadians = transformer({\n  point: function(x, y) {\n    this.stream.point(x * radians, y * radians);\n  }\n});\n\nfunction transformRotate(rotate) {\n  return transformer({\n    point: function(x, y) {\n      var r = rotate(x, y);\n      return this.stream.point(r[0], r[1]);\n    }\n  });\n}\n\nfunction scaleTranslate(k, dx, dy) {\n  function transform$$1(x, y) {\n    return [dx + k * x, dy - k * y];\n  }\n  transform$$1.invert = function(x, y) {\n    return [(x - dx) / k, (dy - y) / k];\n  };\n  return transform$$1;\n}\n\nfunction scaleTranslateRotate(k, dx, dy, alpha) {\n  var cosAlpha = cos(alpha),\n      sinAlpha = sin(alpha),\n      a = cosAlpha * k,\n      b = sinAlpha * k,\n      ai = cosAlpha / k,\n      bi = sinAlpha / k,\n      ci = (sinAlpha * dy - cosAlpha * dx) / k,\n      fi = (sinAlpha * dx + cosAlpha * dy) / k;\n  function transform$$1(x, y) {\n    return [a * x - b * y + dx, dy - b * x - a * y];\n  }\n  transform$$1.invert = function(x, y) {\n    return [ai * x - bi * y + ci, fi - bi * x - ai * y];\n  };\n  return transform$$1;\n}\n\nfunction projection(project) {\n  return projectionMutator(function() { return project; })();\n}\n\nfunction projectionMutator(projectAt) {\n  var project,\n      k = 150, // scale\n      x = 480, y = 250, // translate\n      lambda = 0, phi = 0, // center\n      deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, // pre-rotate\n      alpha = 0, // post-rotate\n      theta = null, preclip = clipAntimeridian, // pre-clip angle\n      x0 = null, y0, x1, y1, postclip = identity, // post-clip extent\n      delta2 = 0.5, // precision\n      projectResample,\n      projectTransform,\n      projectRotateTransform,\n      cache,\n      cacheStream;\n\n  function projection(point) {\n    return projectRotateTransform(point[0] * radians, point[1] * radians);\n  }\n\n  function invert(point) {\n    point = projectRotateTransform.invert(point[0], point[1]);\n    return point && [point[0] * degrees, point[1] * degrees];\n  }\n\n  projection.stream = function(stream) {\n    return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));\n  };\n\n  projection.preclip = function(_) {\n    return arguments.length ? (preclip = _, theta = undefined, reset()) : preclip;\n  };\n\n  projection.postclip = function(_) {\n    return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;\n  };\n\n  projection.clipAngle = function(_) {\n    return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees;\n  };\n\n  projection.clipExtent = function(_) {\n    return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];\n  };\n\n  projection.scale = function(_) {\n    return arguments.length ? (k = +_, recenter()) : k;\n  };\n\n  projection.translate = function(_) {\n    return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];\n  };\n\n  projection.center = function(_) {\n    return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees, phi * degrees];\n  };\n\n  projection.rotate = function(_) {\n    return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];\n  };\n\n  projection.angle = function(_) {\n    return arguments.length ? (alpha = _ % 360 * radians, recenter()) : alpha * degrees;\n  };\n\n  projection.precision = function(_) {\n    return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt(delta2);\n  };\n\n  projection.fitExtent = function(extent, object) {\n    return fitExtent(projection, extent, object);\n  };\n\n  projection.fitSize = function(size, object) {\n    return fitSize(projection, size, object);\n  };\n\n  projection.fitWidth = function(width, object) {\n    return fitWidth(projection, width, object);\n  };\n\n  projection.fitHeight = function(height, object) {\n    return fitHeight(projection, height, object);\n  };\n\n  function recenter() {\n    var center = scaleTranslateRotate(k, 0, 0, alpha).apply(null, project(lambda, phi)),\n        transform$$1 = (alpha ? scaleTranslateRotate : scaleTranslate)(k, x - center[0], y - center[1], alpha);\n    rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma);\n    projectTransform = compose(project, transform$$1);\n    projectRotateTransform = compose(rotate, projectTransform);\n    projectResample = resample(projectTransform, delta2);\n    return reset();\n  }\n\n  function reset() {\n    cache = cacheStream = null;\n    return projection;\n  }\n\n  return function() {\n    project = projectAt.apply(this, arguments);\n    projection.invert = project.invert && invert;\n    return recenter();\n  };\n}\n\nfunction conicProjection(projectAt) {\n  var phi0 = 0,\n      phi1 = pi / 3,\n      m = projectionMutator(projectAt),\n      p = m(phi0, phi1);\n\n  p.parallels = function(_) {\n    return arguments.length ? m(phi0 = _[0] * radians, phi1 = _[1] * radians) : [phi0 * degrees, phi1 * degrees];\n  };\n\n  return p;\n}\n\nfunction cylindricalEqualAreaRaw(phi0) {\n  var cosPhi0 = cos(phi0);\n\n  function forward(lambda, phi) {\n    return [lambda * cosPhi0, sin(phi) / cosPhi0];\n  }\n\n  forward.invert = function(x, y) {\n    return [x / cosPhi0, asin(y * cosPhi0)];\n  };\n\n  return forward;\n}\n\nfunction conicEqualAreaRaw(y0, y1) {\n  var sy0 = sin(y0), n = (sy0 + sin(y1)) / 2;\n\n  // Are the parallels symmetrical around the Equator?\n  if (abs(n) < epsilon) return cylindricalEqualAreaRaw(y0);\n\n  var c = 1 + sy0 * (2 * n - sy0), r0 = sqrt(c) / n;\n\n  function project(x, y) {\n    var r = sqrt(c - 2 * n * sin(y)) / n;\n    return [r * sin(x *= n), r0 - r * cos(x)];\n  }\n\n  project.invert = function(x, y) {\n    var r0y = r0 - y;\n    return [atan2(x, abs(r0y)) / n * sign(r0y), asin((c - (x * x + r0y * r0y) * n * n) / (2 * n))];\n  };\n\n  return project;\n}\n\nfunction conicEqualArea() {\n  return conicProjection(conicEqualAreaRaw)\n      .scale(155.424)\n      .center([0, 33.6442]);\n}\n\nfunction albers() {\n  return conicEqualArea()\n      .parallels([29.5, 45.5])\n      .scale(1070)\n      .translate([480, 250])\n      .rotate([96, 0])\n      .center([-0.6, 38.7]);\n}\n\n// The projections must have mutually exclusive clip regions on the sphere,\n// as this will avoid emitting interleaving lines and polygons.\nfunction multiplex(streams) {\n  var n = streams.length;\n  return {\n    point: function(x, y) { var i = -1; while (++i < n) streams[i].point(x, y); },\n    sphere: function() { var i = -1; while (++i < n) streams[i].sphere(); },\n    lineStart: function() { var i = -1; while (++i < n) streams[i].lineStart(); },\n    lineEnd: function() { var i = -1; while (++i < n) streams[i].lineEnd(); },\n    polygonStart: function() { var i = -1; while (++i < n) streams[i].polygonStart(); },\n    polygonEnd: function() { var i = -1; while (++i < n) streams[i].polygonEnd(); }\n  };\n}\n\n// A composite projection for the United States, configured by default for\n// 960×500. The projection also works quite well at 960×600 if you change the\n// scale to 1285 and adjust the translate accordingly. The set of standard\n// parallels for each region comes from USGS, which is published here:\n// http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers\nfunction albersUsa() {\n  var cache,\n      cacheStream,\n      lower48 = albers(), lower48Point,\n      alaska = conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, // EPSG:3338\n      hawaii = conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, // ESRI:102007\n      point, pointStream = {point: function(x, y) { point = [x, y]; }};\n\n  function albersUsa(coordinates) {\n    var x = coordinates[0], y = coordinates[1];\n    return point = null, (lower48Point.point(x, y), point)\n        || (alaskaPoint.point(x, y), point)\n        || (hawaiiPoint.point(x, y), point);\n  }\n\n  albersUsa.invert = function(coordinates) {\n    var k = lower48.scale(),\n        t = lower48.translate(),\n        x = (coordinates[0] - t[0]) / k,\n        y = (coordinates[1] - t[1]) / k;\n    return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska\n        : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii\n        : lower48).invert(coordinates);\n  };\n\n  albersUsa.stream = function(stream) {\n    return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);\n  };\n\n  albersUsa.precision = function(_) {\n    if (!arguments.length) return lower48.precision();\n    lower48.precision(_), alaska.precision(_), hawaii.precision(_);\n    return reset();\n  };\n\n  albersUsa.scale = function(_) {\n    if (!arguments.length) return lower48.scale();\n    lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);\n    return albersUsa.translate(lower48.translate());\n  };\n\n  albersUsa.translate = function(_) {\n    if (!arguments.length) return lower48.translate();\n    var k = lower48.scale(), x = +_[0], y = +_[1];\n\n    lower48Point = lower48\n        .translate(_)\n        .clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]])\n        .stream(pointStream);\n\n    alaskaPoint = alaska\n        .translate([x - 0.307 * k, y + 0.201 * k])\n        .clipExtent([[x - 0.425 * k + epsilon, y + 0.120 * k + epsilon], [x - 0.214 * k - epsilon, y + 0.234 * k - epsilon]])\n        .stream(pointStream);\n\n    hawaiiPoint = hawaii\n        .translate([x - 0.205 * k, y + 0.212 * k])\n        .clipExtent([[x - 0.214 * k + epsilon, y + 0.166 * k + epsilon], [x - 0.115 * k - epsilon, y + 0.234 * k - epsilon]])\n        .stream(pointStream);\n\n    return reset();\n  };\n\n  albersUsa.fitExtent = function(extent, object) {\n    return fitExtent(albersUsa, extent, object);\n  };\n\n  albersUsa.fitSize = function(size, object) {\n    return fitSize(albersUsa, size, object);\n  };\n\n  albersUsa.fitWidth = function(width, object) {\n    return fitWidth(albersUsa, width, object);\n  };\n\n  albersUsa.fitHeight = function(height, object) {\n    return fitHeight(albersUsa, height, object);\n  };\n\n  function reset() {\n    cache = cacheStream = null;\n    return albersUsa;\n  }\n\n  return albersUsa.scale(1070);\n}\n\nfunction azimuthalRaw(scale) {\n  return function(x, y) {\n    var cx = cos(x),\n        cy = cos(y),\n        k = scale(cx * cy);\n    return [\n      k * cy * sin(x),\n      k * sin(y)\n    ];\n  }\n}\n\nfunction azimuthalInvert(angle) {\n  return function(x, y) {\n    var z = sqrt(x * x + y * y),\n        c = angle(z),\n        sc = sin(c),\n        cc = cos(c);\n    return [\n      atan2(x * sc, z * cc),\n      asin(z && y * sc / z)\n    ];\n  }\n}\n\nvar azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {\n  return sqrt(2 / (1 + cxcy));\n});\n\nazimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {\n  return 2 * asin(z / 2);\n});\n\nfunction azimuthalEqualArea() {\n  return projection(azimuthalEqualAreaRaw)\n      .scale(124.75)\n      .clipAngle(180 - 1e-3);\n}\n\nvar azimuthalEquidistantRaw = azimuthalRaw(function(c) {\n  return (c = acos(c)) && c / sin(c);\n});\n\nazimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {\n  return z;\n});\n\nfunction azimuthalEquidistant() {\n  return projection(azimuthalEquidistantRaw)\n      .scale(79.4188)\n      .clipAngle(180 - 1e-3);\n}\n\nfunction mercatorRaw(lambda, phi) {\n  return [lambda, log(tan((halfPi + phi) / 2))];\n}\n\nmercatorRaw.invert = function(x, y) {\n  return [x, 2 * atan(exp(y)) - halfPi];\n};\n\nfunction mercator() {\n  return mercatorProjection(mercatorRaw)\n      .scale(961 / tau);\n}\n\nfunction mercatorProjection(project) {\n  var m = projection(project),\n      center = m.center,\n      scale = m.scale,\n      translate = m.translate,\n      clipExtent = m.clipExtent,\n      x0 = null, y0, x1, y1; // clip extent\n\n  m.scale = function(_) {\n    return arguments.length ? (scale(_), reclip()) : scale();\n  };\n\n  m.translate = function(_) {\n    return arguments.length ? (translate(_), reclip()) : translate();\n  };\n\n  m.center = function(_) {\n    return arguments.length ? (center(_), reclip()) : center();\n  };\n\n  m.clipExtent = function(_) {\n    return arguments.length ? (_ == null ? x0 = y0 = x1 = y1 = null : (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reclip()) : x0 == null ? null : [[x0, y0], [x1, y1]];\n  };\n\n  function reclip() {\n    var k = pi * scale(),\n        t = m(rotation(m.rotate()).invert([0, 0]));\n    return clipExtent(x0 == null\n        ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw\n        ? [[Math.max(t[0] - k, x0), y0], [Math.min(t[0] + k, x1), y1]]\n        : [[x0, Math.max(t[1] - k, y0)], [x1, Math.min(t[1] + k, y1)]]);\n  }\n\n  return reclip();\n}\n\nfunction tany(y) {\n  return tan((halfPi + y) / 2);\n}\n\nfunction conicConformalRaw(y0, y1) {\n  var cy0 = cos(y0),\n      n = y0 === y1 ? sin(y0) : log(cy0 / cos(y1)) / log(tany(y1) / tany(y0)),\n      f = cy0 * pow(tany(y0), n) / n;\n\n  if (!n) return mercatorRaw;\n\n  function project(x, y) {\n    if (f > 0) { if (y < -halfPi + epsilon) y = -halfPi + epsilon; }\n    else { if (y > halfPi - epsilon) y = halfPi - epsilon; }\n    var r = f / pow(tany(y), n);\n    return [r * sin(n * x), f - r * cos(n * x)];\n  }\n\n  project.invert = function(x, y) {\n    var fy = f - y, r = sign(n) * sqrt(x * x + fy * fy);\n    return [atan2(x, abs(fy)) / n * sign(fy), 2 * atan(pow(f / r, 1 / n)) - halfPi];\n  };\n\n  return project;\n}\n\nfunction conicConformal() {\n  return conicProjection(conicConformalRaw)\n      .scale(109.5)\n      .parallels([30, 30]);\n}\n\nfunction equirectangularRaw(lambda, phi) {\n  return [lambda, phi];\n}\n\nequirectangularRaw.invert = equirectangularRaw;\n\nfunction equirectangular() {\n  return projection(equirectangularRaw)\n      .scale(152.63);\n}\n\nfunction conicEquidistantRaw(y0, y1) {\n  var cy0 = cos(y0),\n      n = y0 === y1 ? sin(y0) : (cy0 - cos(y1)) / (y1 - y0),\n      g = cy0 / n + y0;\n\n  if (abs(n) < epsilon) return equirectangularRaw;\n\n  function project(x, y) {\n    var gy = g - y, nx = n * x;\n    return [gy * sin(nx), g - gy * cos(nx)];\n  }\n\n  project.invert = function(x, y) {\n    var gy = g - y;\n    return [atan2(x, abs(gy)) / n * sign(gy), g - sign(n) * sqrt(x * x + gy * gy)];\n  };\n\n  return project;\n}\n\nfunction conicEquidistant() {\n  return conicProjection(conicEquidistantRaw)\n      .scale(131.154)\n      .center([0, 13.9389]);\n}\n\nfunction gnomonicRaw(x, y) {\n  var cy = cos(y), k = cos(x) * cy;\n  return [cy * sin(x) / k, sin(y) / k];\n}\n\ngnomonicRaw.invert = azimuthalInvert(atan);\n\nfunction gnomonic() {\n  return projection(gnomonicRaw)\n      .scale(144.049)\n      .clipAngle(60);\n}\n\nfunction scaleTranslate$1(kx, ky, tx, ty) {\n  return kx === 1 && ky === 1 && tx === 0 && ty === 0 ? identity : transformer({\n    point: function(x, y) {\n      this.stream.point(x * kx + tx, y * ky + ty);\n    }\n  });\n}\n\nfunction identity$1() {\n  var k = 1, tx = 0, ty = 0, sx = 1, sy = 1, transform$$1 = identity, // scale, translate and reflect\n      x0 = null, y0, x1, y1, // clip extent\n      postclip = identity,\n      cache,\n      cacheStream,\n      projection;\n\n  function reset() {\n    cache = cacheStream = null;\n    return projection;\n  }\n\n  return projection = {\n    stream: function(stream) {\n      return cache && cacheStream === stream ? cache : cache = transform$$1(postclip(cacheStream = stream));\n    },\n    postclip: function(_) {\n      return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;\n    },\n    clipExtent: function(_) {\n      return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];\n    },\n    scale: function(_) {\n      return arguments.length ? (transform$$1 = scaleTranslate$1((k = +_) * sx, k * sy, tx, ty), reset()) : k;\n    },\n    translate: function(_) {\n      return arguments.length ? (transform$$1 = scaleTranslate$1(k * sx, k * sy, tx = +_[0], ty = +_[1]), reset()) : [tx, ty];\n    },\n    reflectX: function(_) {\n      return arguments.length ? (transform$$1 = scaleTranslate$1(k * (sx = _ ? -1 : 1), k * sy, tx, ty), reset()) : sx < 0;\n    },\n    reflectY: function(_) {\n      return arguments.length ? (transform$$1 = scaleTranslate$1(k * sx, k * (sy = _ ? -1 : 1), tx, ty), reset()) : sy < 0;\n    },\n    fitExtent: function(extent, object) {\n      return fitExtent(projection, extent, object);\n    },\n    fitSize: function(size, object) {\n      return fitSize(projection, size, object);\n    },\n    fitWidth: function(width, object) {\n      return fitWidth(projection, width, object);\n    },\n    fitHeight: function(height, object) {\n      return fitHeight(projection, height, object);\n    }\n  };\n}\n\nfunction naturalEarth1Raw(lambda, phi) {\n  var phi2 = phi * phi, phi4 = phi2 * phi2;\n  return [\n    lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (0.003971 * phi2 - 0.001529 * phi4))),\n    phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4)))\n  ];\n}\n\nnaturalEarth1Raw.invert = function(x, y) {\n  var phi = y, i = 25, delta;\n  do {\n    var phi2 = phi * phi, phi4 = phi2 * phi2;\n    phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4))) - y) /\n        (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 0.005916 * 11 * phi4)));\n  } while (abs(delta) > epsilon && --i > 0);\n  return [\n    x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (0.003971 - 0.001529 * phi2)))),\n    phi\n  ];\n};\n\nfunction naturalEarth1() {\n  return projection(naturalEarth1Raw)\n      .scale(175.295);\n}\n\nfunction orthographicRaw(x, y) {\n  return [cos(y) * sin(x), sin(y)];\n}\n\northographicRaw.invert = azimuthalInvert(asin);\n\nfunction orthographic() {\n  return projection(orthographicRaw)\n      .scale(249.5)\n      .clipAngle(90 + epsilon);\n}\n\nfunction stereographicRaw(x, y) {\n  var cy = cos(y), k = 1 + cos(x) * cy;\n  return [cy * sin(x) / k, sin(y) / k];\n}\n\nstereographicRaw.invert = azimuthalInvert(function(z) {\n  return 2 * atan(z);\n});\n\nfunction stereographic() {\n  return projection(stereographicRaw)\n      .scale(250)\n      .clipAngle(142);\n}\n\nfunction transverseMercatorRaw(lambda, phi) {\n  return [log(tan((halfPi + phi) / 2)), -lambda];\n}\n\ntransverseMercatorRaw.invert = function(x, y) {\n  return [-y, 2 * atan(exp(x)) - halfPi];\n};\n\nfunction transverseMercator() {\n  var m = mercatorProjection(transverseMercatorRaw),\n      center = m.center,\n      rotate = m.rotate;\n\n  m.center = function(_) {\n    return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);\n  };\n\n  m.rotate = function(_) {\n    return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);\n  };\n\n  return rotate([0, 0, 90])\n      .scale(159.155);\n}\n\nexports.geoArea = area;\nexports.geoBounds = bounds;\nexports.geoCentroid = centroid;\nexports.geoCircle = circle;\nexports.geoClipAntimeridian = clipAntimeridian;\nexports.geoClipCircle = clipCircle;\nexports.geoClipExtent = extent;\nexports.geoClipRectangle = clipRectangle;\nexports.geoContains = contains;\nexports.geoDistance = distance;\nexports.geoGraticule = graticule;\nexports.geoGraticule10 = graticule10;\nexports.geoInterpolate = interpolate;\nexports.geoLength = length;\nexports.geoPath = index;\nexports.geoAlbers = albers;\nexports.geoAlbersUsa = albersUsa;\nexports.geoAzimuthalEqualArea = azimuthalEqualArea;\nexports.geoAzimuthalEqualAreaRaw = azimuthalEqualAreaRaw;\nexports.geoAzimuthalEquidistant = azimuthalEquidistant;\nexports.geoAzimuthalEquidistantRaw = azimuthalEquidistantRaw;\nexports.geoConicConformal = conicConformal;\nexports.geoConicConformalRaw = conicConformalRaw;\nexports.geoConicEqualArea = conicEqualArea;\nexports.geoConicEqualAreaRaw = conicEqualAreaRaw;\nexports.geoConicEquidistant = conicEquidistant;\nexports.geoConicEquidistantRaw = conicEquidistantRaw;\nexports.geoEquirectangular = equirectangular;\nexports.geoEquirectangularRaw = equirectangularRaw;\nexports.geoGnomonic = gnomonic;\nexports.geoGnomonicRaw = gnomonicRaw;\nexports.geoIdentity = identity$1;\nexports.geoProjection = projection;\nexports.geoProjectionMutator = projectionMutator;\nexports.geoMercator = mercator;\nexports.geoMercatorRaw = mercatorRaw;\nexports.geoNaturalEarth1 = naturalEarth1;\nexports.geoNaturalEarth1Raw = naturalEarth1Raw;\nexports.geoOrthographic = orthographic;\nexports.geoOrthographicRaw = orthographicRaw;\nexports.geoStereographic = stereographic;\nexports.geoStereographicRaw = stereographicRaw;\nexports.geoTransverseMercator = transverseMercator;\nexports.geoTransverseMercatorRaw = transverseMercatorRaw;\nexports.geoRotation = rotation;\nexports.geoStream = geoStream;\nexports.geoTransform = transform;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/d3-geo/dist/d3-geo.js\n// module id = 191\n// module chunks = 115685857604607 234182462816062","// https://d3js.org/d3-timer/ Version 1.0.7. Copyright 2017 Mike Bostock.\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(factory((global.d3 = global.d3 || {})));\n}(this, (function (exports) { 'use strict';\n\nvar frame = 0;\nvar timeout = 0;\nvar interval = 0;\nvar pokeDelay = 1000;\nvar taskHead;\nvar taskTail;\nvar clockLast = 0;\nvar clockNow = 0;\nvar clockSkew = 0;\nvar clock = typeof performance === \"object\" && performance.now ? performance : Date;\nvar setFrame = typeof window === \"object\" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };\n\nfunction now() {\n  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);\n}\n\nfunction clearNow() {\n  clockNow = 0;\n}\n\nfunction Timer() {\n  this._call =\n  this._time =\n  this._next = null;\n}\n\nTimer.prototype = timer.prototype = {\n  constructor: Timer,\n  restart: function(callback, delay, time) {\n    if (typeof callback !== \"function\") throw new TypeError(\"callback is not a function\");\n    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);\n    if (!this._next && taskTail !== this) {\n      if (taskTail) taskTail._next = this;\n      else taskHead = this;\n      taskTail = this;\n    }\n    this._call = callback;\n    this._time = time;\n    sleep();\n  },\n  stop: function() {\n    if (this._call) {\n      this._call = null;\n      this._time = Infinity;\n      sleep();\n    }\n  }\n};\n\nfunction timer(callback, delay, time) {\n  var t = new Timer;\n  t.restart(callback, delay, time);\n  return t;\n}\n\nfunction timerFlush() {\n  now(); // Get the current time, if not already set.\n  ++frame; // Pretend we’ve set an alarm, if we haven’t already.\n  var t = taskHead, e;\n  while (t) {\n    if ((e = clockNow - t._time) >= 0) t._call.call(null, e);\n    t = t._next;\n  }\n  --frame;\n}\n\nfunction wake() {\n  clockNow = (clockLast = clock.now()) + clockSkew;\n  frame = timeout = 0;\n  try {\n    timerFlush();\n  } finally {\n    frame = 0;\n    nap();\n    clockNow = 0;\n  }\n}\n\nfunction poke() {\n  var now = clock.now(), delay = now - clockLast;\n  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;\n}\n\nfunction nap() {\n  var t0, t1 = taskHead, t2, time = Infinity;\n  while (t1) {\n    if (t1._call) {\n      if (time > t1._time) time = t1._time;\n      t0 = t1, t1 = t1._next;\n    } else {\n      t2 = t1._next, t1._next = null;\n      t1 = t0 ? t0._next = t2 : taskHead = t2;\n    }\n  }\n  taskTail = t0;\n  sleep(time);\n}\n\nfunction sleep(time) {\n  if (frame) return; // Soonest alarm already set, or will be.\n  if (timeout) timeout = clearTimeout(timeout);\n  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.\n  if (delay > 24) {\n    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);\n    if (interval) interval = clearInterval(interval);\n  } else {\n    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);\n    frame = 1, setFrame(wake);\n  }\n}\n\nvar timeout$1 = function(callback, delay, time) {\n  var t = new Timer;\n  delay = delay == null ? 0 : +delay;\n  t.restart(function(elapsed) {\n    t.stop();\n    callback(elapsed + delay);\n  }, delay, time);\n  return t;\n};\n\nvar interval$1 = function(callback, delay, time) {\n  var t = new Timer, total = delay;\n  if (delay == null) return t.restart(callback, delay, time), t;\n  delay = +delay, time = time == null ? now() : +time;\n  t.restart(function tick(elapsed) {\n    elapsed += total;\n    t.restart(tick, total += delay, time);\n    callback(elapsed);\n  }, delay, time);\n  return t;\n};\n\nexports.now = now;\nexports.timer = timer;\nexports.timerFlush = timerFlush;\nexports.timeout = timeout$1;\nexports.interval = interval$1;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/d3-timer/build/d3-timer.js\n// module id = 192\n// module chunks = 75343954514761 234182462816062","// https://d3js.org/d3-transition/ Version 1.1.1. Copyright 2017 Mike Bostock.\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-selection'), require('d3-dispatch'), require('d3-timer'), require('d3-interpolate'), require('d3-color'), require('d3-ease')) :\n\ttypeof define === 'function' && define.amd ? define(['exports', 'd3-selection', 'd3-dispatch', 'd3-timer', 'd3-interpolate', 'd3-color', 'd3-ease'], factory) :\n\t(factory((global.d3 = global.d3 || {}),global.d3,global.d3,global.d3,global.d3,global.d3,global.d3));\n}(this, (function (exports,d3Selection,d3Dispatch,d3Timer,d3Interpolate,d3Color,d3Ease) { 'use strict';\n\nvar emptyOn = d3Dispatch.dispatch(\"start\", \"end\", \"interrupt\");\nvar emptyTween = [];\n\nvar CREATED = 0;\nvar SCHEDULED = 1;\nvar STARTING = 2;\nvar STARTED = 3;\nvar RUNNING = 4;\nvar ENDING = 5;\nvar ENDED = 6;\n\nvar schedule = function(node, name, id, index, group, timing) {\n  var schedules = node.__transition;\n  if (!schedules) node.__transition = {};\n  else if (id in schedules) return;\n  create(node, id, {\n    name: name,\n    index: index, // For context during callback.\n    group: group, // For context during callback.\n    on: emptyOn,\n    tween: emptyTween,\n    time: timing.time,\n    delay: timing.delay,\n    duration: timing.duration,\n    ease: timing.ease,\n    timer: null,\n    state: CREATED\n  });\n};\n\nfunction init(node, id) {\n  var schedule = get(node, id);\n  if (schedule.state > CREATED) throw new Error(\"too late; already scheduled\");\n  return schedule;\n}\n\nfunction set(node, id) {\n  var schedule = get(node, id);\n  if (schedule.state > STARTING) throw new Error(\"too late; already started\");\n  return schedule;\n}\n\nfunction get(node, id) {\n  var schedule = node.__transition;\n  if (!schedule || !(schedule = schedule[id])) throw new Error(\"transition not found\");\n  return schedule;\n}\n\nfunction create(node, id, self) {\n  var schedules = node.__transition,\n      tween;\n\n  // Initialize the self timer when the transition is created.\n  // Note the actual delay is not known until the first callback!\n  schedules[id] = self;\n  self.timer = d3Timer.timer(schedule, 0, self.time);\n\n  function schedule(elapsed) {\n    self.state = SCHEDULED;\n    self.timer.restart(start, self.delay, self.time);\n\n    // If the elapsed delay is less than our first sleep, start immediately.\n    if (self.delay <= elapsed) start(elapsed - self.delay);\n  }\n\n  function start(elapsed) {\n    var i, j, n, o;\n\n    // If the state is not SCHEDULED, then we previously errored on start.\n    if (self.state !== SCHEDULED) return stop();\n\n    for (i in schedules) {\n      o = schedules[i];\n      if (o.name !== self.name) continue;\n\n      // While this element already has a starting transition during this frame,\n      // defer starting an interrupting transition until that transition has a\n      // chance to tick (and possibly end); see d3/d3-transition#54!\n      if (o.state === STARTED) return d3Timer.timeout(start);\n\n      // Interrupt the active transition, if any.\n      // Dispatch the interrupt event.\n      if (o.state === RUNNING) {\n        o.state = ENDED;\n        o.timer.stop();\n        o.on.call(\"interrupt\", node, node.__data__, o.index, o.group);\n        delete schedules[i];\n      }\n\n      // Cancel any pre-empted transitions. No interrupt event is dispatched\n      // because the cancelled transitions never started. Note that this also\n      // removes this transition from the pending list!\n      else if (+i < id) {\n        o.state = ENDED;\n        o.timer.stop();\n        delete schedules[i];\n      }\n    }\n\n    // Defer the first tick to end of the current frame; see d3/d3#1576.\n    // Note the transition may be canceled after start and before the first tick!\n    // Note this must be scheduled before the start event; see d3/d3-transition#16!\n    // Assuming this is successful, subsequent callbacks go straight to tick.\n    d3Timer.timeout(function() {\n      if (self.state === STARTED) {\n        self.state = RUNNING;\n        self.timer.restart(tick, self.delay, self.time);\n        tick(elapsed);\n      }\n    });\n\n    // Dispatch the start event.\n    // Note this must be done before the tween are initialized.\n    self.state = STARTING;\n    self.on.call(\"start\", node, node.__data__, self.index, self.group);\n    if (self.state !== STARTING) return; // interrupted\n    self.state = STARTED;\n\n    // Initialize the tween, deleting null tween.\n    tween = new Array(n = self.tween.length);\n    for (i = 0, j = -1; i < n; ++i) {\n      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {\n        tween[++j] = o;\n      }\n    }\n    tween.length = j + 1;\n  }\n\n  function tick(elapsed) {\n    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),\n        i = -1,\n        n = tween.length;\n\n    while (++i < n) {\n      tween[i].call(null, t);\n    }\n\n    // Dispatch the end event.\n    if (self.state === ENDING) {\n      self.on.call(\"end\", node, node.__data__, self.index, self.group);\n      stop();\n    }\n  }\n\n  function stop() {\n    self.state = ENDED;\n    self.timer.stop();\n    delete schedules[id];\n    for (var i in schedules) return; // eslint-disable-line no-unused-vars\n    delete node.__transition;\n  }\n}\n\nvar interrupt = function(node, name) {\n  var schedules = node.__transition,\n      schedule,\n      active,\n      empty = true,\n      i;\n\n  if (!schedules) return;\n\n  name = name == null ? null : name + \"\";\n\n  for (i in schedules) {\n    if ((schedule = schedules[i]).name !== name) { empty = false; continue; }\n    active = schedule.state > STARTING && schedule.state < ENDING;\n    schedule.state = ENDED;\n    schedule.timer.stop();\n    if (active) schedule.on.call(\"interrupt\", node, node.__data__, schedule.index, schedule.group);\n    delete schedules[i];\n  }\n\n  if (empty) delete node.__transition;\n};\n\nvar selection_interrupt = function(name) {\n  return this.each(function() {\n    interrupt(this, name);\n  });\n};\n\nfunction tweenRemove(id, name) {\n  var tween0, tween1;\n  return function() {\n    var schedule = set(this, id),\n        tween = schedule.tween;\n\n    // If this node shared tween with the previous node,\n    // just assign the updated shared tween and we’re done!\n    // Otherwise, copy-on-write.\n    if (tween !== tween0) {\n      tween1 = tween0 = tween;\n      for (var i = 0, n = tween1.length; i < n; ++i) {\n        if (tween1[i].name === name) {\n          tween1 = tween1.slice();\n          tween1.splice(i, 1);\n          break;\n        }\n      }\n    }\n\n    schedule.tween = tween1;\n  };\n}\n\nfunction tweenFunction(id, name, value) {\n  var tween0, tween1;\n  if (typeof value !== \"function\") throw new Error;\n  return function() {\n    var schedule = set(this, id),\n        tween = schedule.tween;\n\n    // If this node shared tween with the previous node,\n    // just assign the updated shared tween and we’re done!\n    // Otherwise, copy-on-write.\n    if (tween !== tween0) {\n      tween1 = (tween0 = tween).slice();\n      for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {\n        if (tween1[i].name === name) {\n          tween1[i] = t;\n          break;\n        }\n      }\n      if (i === n) tween1.push(t);\n    }\n\n    schedule.tween = tween1;\n  };\n}\n\nvar transition_tween = function(name, value) {\n  var id = this._id;\n\n  name += \"\";\n\n  if (arguments.length < 2) {\n    var tween = get(this.node(), id).tween;\n    for (var i = 0, n = tween.length, t; i < n; ++i) {\n      if ((t = tween[i]).name === name) {\n        return t.value;\n      }\n    }\n    return null;\n  }\n\n  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));\n};\n\nfunction tweenValue(transition, name, value) {\n  var id = transition._id;\n\n  transition.each(function() {\n    var schedule = set(this, id);\n    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);\n  });\n\n  return function(node) {\n    return get(node, id).value[name];\n  };\n}\n\nvar interpolate = function(a, b) {\n  var c;\n  return (typeof b === \"number\" ? d3Interpolate.interpolateNumber\n      : b instanceof d3Color.color ? d3Interpolate.interpolateRgb\n      : (c = d3Color.color(b)) ? (b = c, d3Interpolate.interpolateRgb)\n      : d3Interpolate.interpolateString)(a, b);\n};\n\nfunction attrRemove(name) {\n  return function() {\n    this.removeAttribute(name);\n  };\n}\n\nfunction attrRemoveNS(fullname) {\n  return function() {\n    this.removeAttributeNS(fullname.space, fullname.local);\n  };\n}\n\nfunction attrConstant(name, interpolate$$1, value1) {\n  var value00,\n      interpolate0;\n  return function() {\n    var value0 = this.getAttribute(name);\n    return value0 === value1 ? null\n        : value0 === value00 ? interpolate0\n        : interpolate0 = interpolate$$1(value00 = value0, value1);\n  };\n}\n\nfunction attrConstantNS(fullname, interpolate$$1, value1) {\n  var value00,\n      interpolate0;\n  return function() {\n    var value0 = this.getAttributeNS(fullname.space, fullname.local);\n    return value0 === value1 ? null\n        : value0 === value00 ? interpolate0\n        : interpolate0 = interpolate$$1(value00 = value0, value1);\n  };\n}\n\nfunction attrFunction(name, interpolate$$1, value) {\n  var value00,\n      value10,\n      interpolate0;\n  return function() {\n    var value0, value1 = value(this);\n    if (value1 == null) return void this.removeAttribute(name);\n    value0 = this.getAttribute(name);\n    return value0 === value1 ? null\n        : value0 === value00 && value1 === value10 ? interpolate0\n        : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);\n  };\n}\n\nfunction attrFunctionNS(fullname, interpolate$$1, value) {\n  var value00,\n      value10,\n      interpolate0;\n  return function() {\n    var value0, value1 = value(this);\n    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);\n    value0 = this.getAttributeNS(fullname.space, fullname.local);\n    return value0 === value1 ? null\n        : value0 === value00 && value1 === value10 ? interpolate0\n        : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);\n  };\n}\n\nvar transition_attr = function(name, value) {\n  var fullname = d3Selection.namespace(name), i = fullname === \"transform\" ? d3Interpolate.interpolateTransformSvg : interpolate;\n  return this.attrTween(name, typeof value === \"function\"\n      ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, tweenValue(this, \"attr.\" + name, value))\n      : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname)\n      : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value + \"\"));\n};\n\nfunction attrTweenNS(fullname, value) {\n  function tween() {\n    var node = this, i = value.apply(node, arguments);\n    return i && function(t) {\n      node.setAttributeNS(fullname.space, fullname.local, i(t));\n    };\n  }\n  tween._value = value;\n  return tween;\n}\n\nfunction attrTween(name, value) {\n  function tween() {\n    var node = this, i = value.apply(node, arguments);\n    return i && function(t) {\n      node.setAttribute(name, i(t));\n    };\n  }\n  tween._value = value;\n  return tween;\n}\n\nvar transition_attrTween = function(name, value) {\n  var key = \"attr.\" + name;\n  if (arguments.length < 2) return (key = this.tween(key)) && key._value;\n  if (value == null) return this.tween(key, null);\n  if (typeof value !== \"function\") throw new Error;\n  var fullname = d3Selection.namespace(name);\n  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));\n};\n\nfunction delayFunction(id, value) {\n  return function() {\n    init(this, id).delay = +value.apply(this, arguments);\n  };\n}\n\nfunction delayConstant(id, value) {\n  return value = +value, function() {\n    init(this, id).delay = value;\n  };\n}\n\nvar transition_delay = function(value) {\n  var id = this._id;\n\n  return arguments.length\n      ? this.each((typeof value === \"function\"\n          ? delayFunction\n          : delayConstant)(id, value))\n      : get(this.node(), id).delay;\n};\n\nfunction durationFunction(id, value) {\n  return function() {\n    set(this, id).duration = +value.apply(this, arguments);\n  };\n}\n\nfunction durationConstant(id, value) {\n  return value = +value, function() {\n    set(this, id).duration = value;\n  };\n}\n\nvar transition_duration = function(value) {\n  var id = this._id;\n\n  return arguments.length\n      ? this.each((typeof value === \"function\"\n          ? durationFunction\n          : durationConstant)(id, value))\n      : get(this.node(), id).duration;\n};\n\nfunction easeConstant(id, value) {\n  if (typeof value !== \"function\") throw new Error;\n  return function() {\n    set(this, id).ease = value;\n  };\n}\n\nvar transition_ease = function(value) {\n  var id = this._id;\n\n  return arguments.length\n      ? this.each(easeConstant(id, value))\n      : get(this.node(), id).ease;\n};\n\nvar transition_filter = function(match) {\n  if (typeof match !== \"function\") match = d3Selection.matcher(match);\n\n  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {\n    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {\n      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return new Transition(subgroups, this._parents, this._name, this._id);\n};\n\nvar transition_merge = function(transition) {\n  if (transition._id !== this._id) throw new Error;\n\n  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {\n    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {\n      if (node = group0[i] || group1[i]) {\n        merge[i] = node;\n      }\n    }\n  }\n\n  for (; j < m0; ++j) {\n    merges[j] = groups0[j];\n  }\n\n  return new Transition(merges, this._parents, this._name, this._id);\n};\n\nfunction start(name) {\n  return (name + \"\").trim().split(/^|\\s+/).every(function(t) {\n    var i = t.indexOf(\".\");\n    if (i >= 0) t = t.slice(0, i);\n    return !t || t === \"start\";\n  });\n}\n\nfunction onFunction(id, name, listener) {\n  var on0, on1, sit = start(name) ? init : set;\n  return function() {\n    var schedule = sit(this, id),\n        on = schedule.on;\n\n    // If this node shared a dispatch with the previous node,\n    // just assign the updated shared dispatch and we’re done!\n    // Otherwise, copy-on-write.\n    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);\n\n    schedule.on = on1;\n  };\n}\n\nvar transition_on = function(name, listener) {\n  var id = this._id;\n\n  return arguments.length < 2\n      ? get(this.node(), id).on.on(name)\n      : this.each(onFunction(id, name, listener));\n};\n\nfunction removeFunction(id) {\n  return function() {\n    var parent = this.parentNode;\n    for (var i in this.__transition) if (+i !== id) return;\n    if (parent) parent.removeChild(this);\n  };\n}\n\nvar transition_remove = function() {\n  return this.on(\"end.remove\", removeFunction(this._id));\n};\n\nvar transition_select = function(select) {\n  var name = this._name,\n      id = this._id;\n\n  if (typeof select !== \"function\") select = d3Selection.selector(select);\n\n  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {\n    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {\n      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {\n        if (\"__data__\" in node) subnode.__data__ = node.__data__;\n        subgroup[i] = subnode;\n        schedule(subgroup[i], name, id, i, subgroup, get(node, id));\n      }\n    }\n  }\n\n  return new Transition(subgroups, this._parents, name, id);\n};\n\nvar transition_selectAll = function(select) {\n  var name = this._name,\n      id = this._id;\n\n  if (typeof select !== \"function\") select = d3Selection.selectorAll(select);\n\n  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {\n    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {\n      if (node = group[i]) {\n        for (var children = select.call(node, node.__data__, i, group), child, inherit = get(node, id), k = 0, l = children.length; k < l; ++k) {\n          if (child = children[k]) {\n            schedule(child, name, id, k, children, inherit);\n          }\n        }\n        subgroups.push(children);\n        parents.push(node);\n      }\n    }\n  }\n\n  return new Transition(subgroups, parents, name, id);\n};\n\nvar Selection = d3Selection.selection.prototype.constructor;\n\nvar transition_selection = function() {\n  return new Selection(this._groups, this._parents);\n};\n\nfunction styleRemove(name, interpolate$$1) {\n  var value00,\n      value10,\n      interpolate0;\n  return function() {\n    var value0 = d3Selection.style(this, name),\n        value1 = (this.style.removeProperty(name), d3Selection.style(this, name));\n    return value0 === value1 ? null\n        : value0 === value00 && value1 === value10 ? interpolate0\n        : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);\n  };\n}\n\nfunction styleRemoveEnd(name) {\n  return function() {\n    this.style.removeProperty(name);\n  };\n}\n\nfunction styleConstant(name, interpolate$$1, value1) {\n  var value00,\n      interpolate0;\n  return function() {\n    var value0 = d3Selection.style(this, name);\n    return value0 === value1 ? null\n        : value0 === value00 ? interpolate0\n        : interpolate0 = interpolate$$1(value00 = value0, value1);\n  };\n}\n\nfunction styleFunction(name, interpolate$$1, value) {\n  var value00,\n      value10,\n      interpolate0;\n  return function() {\n    var value0 = d3Selection.style(this, name),\n        value1 = value(this);\n    if (value1 == null) value1 = (this.style.removeProperty(name), d3Selection.style(this, name));\n    return value0 === value1 ? null\n        : value0 === value00 && value1 === value10 ? interpolate0\n        : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);\n  };\n}\n\nvar transition_style = function(name, value, priority) {\n  var i = (name += \"\") === \"transform\" ? d3Interpolate.interpolateTransformCss : interpolate;\n  return value == null ? this\n          .styleTween(name, styleRemove(name, i))\n          .on(\"end.style.\" + name, styleRemoveEnd(name))\n      : this.styleTween(name, typeof value === \"function\"\n          ? styleFunction(name, i, tweenValue(this, \"style.\" + name, value))\n          : styleConstant(name, i, value + \"\"), priority);\n};\n\nfunction styleTween(name, value, priority) {\n  function tween() {\n    var node = this, i = value.apply(node, arguments);\n    return i && function(t) {\n      node.style.setProperty(name, i(t), priority);\n    };\n  }\n  tween._value = value;\n  return tween;\n}\n\nvar transition_styleTween = function(name, value, priority) {\n  var key = \"style.\" + (name += \"\");\n  if (arguments.length < 2) return (key = this.tween(key)) && key._value;\n  if (value == null) return this.tween(key, null);\n  if (typeof value !== \"function\") throw new Error;\n  return this.tween(key, styleTween(name, value, priority == null ? \"\" : priority));\n};\n\nfunction textConstant(value) {\n  return function() {\n    this.textContent = value;\n  };\n}\n\nfunction textFunction(value) {\n  return function() {\n    var value1 = value(this);\n    this.textContent = value1 == null ? \"\" : value1;\n  };\n}\n\nvar transition_text = function(value) {\n  return this.tween(\"text\", typeof value === \"function\"\n      ? textFunction(tweenValue(this, \"text\", value))\n      : textConstant(value == null ? \"\" : value + \"\"));\n};\n\nvar transition_transition = function() {\n  var name = this._name,\n      id0 = this._id,\n      id1 = newId();\n\n  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {\n    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {\n      if (node = group[i]) {\n        var inherit = get(node, id0);\n        schedule(node, name, id1, i, group, {\n          time: inherit.time + inherit.delay + inherit.duration,\n          delay: 0,\n          duration: inherit.duration,\n          ease: inherit.ease\n        });\n      }\n    }\n  }\n\n  return new Transition(groups, this._parents, name, id1);\n};\n\nvar id = 0;\n\nfunction Transition(groups, parents, name, id) {\n  this._groups = groups;\n  this._parents = parents;\n  this._name = name;\n  this._id = id;\n}\n\nfunction transition(name) {\n  return d3Selection.selection().transition(name);\n}\n\nfunction newId() {\n  return ++id;\n}\n\nvar selection_prototype = d3Selection.selection.prototype;\n\nTransition.prototype = transition.prototype = {\n  constructor: Transition,\n  select: transition_select,\n  selectAll: transition_selectAll,\n  filter: transition_filter,\n  merge: transition_merge,\n  selection: transition_selection,\n  transition: transition_transition,\n  call: selection_prototype.call,\n  nodes: selection_prototype.nodes,\n  node: selection_prototype.node,\n  size: selection_prototype.size,\n  empty: selection_prototype.empty,\n  each: selection_prototype.each,\n  on: transition_on,\n  attr: transition_attr,\n  attrTween: transition_attrTween,\n  style: transition_style,\n  styleTween: transition_styleTween,\n  text: transition_text,\n  remove: transition_remove,\n  tween: transition_tween,\n  delay: transition_delay,\n  duration: transition_duration,\n  ease: transition_ease\n};\n\nvar defaultTiming = {\n  time: null, // Set on use.\n  delay: 0,\n  duration: 250,\n  ease: d3Ease.easeCubicInOut\n};\n\nfunction inherit(node, id) {\n  var timing;\n  while (!(timing = node.__transition) || !(timing = timing[id])) {\n    if (!(node = node.parentNode)) {\n      return defaultTiming.time = d3Timer.now(), defaultTiming;\n    }\n  }\n  return timing;\n}\n\nvar selection_transition = function(name) {\n  var id,\n      timing;\n\n  if (name instanceof Transition) {\n    id = name._id, name = name._name;\n  } else {\n    id = newId(), (timing = defaultTiming).time = d3Timer.now(), name = name == null ? null : name + \"\";\n  }\n\n  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {\n    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {\n      if (node = group[i]) {\n        schedule(node, name, id, i, group, timing || inherit(node, id));\n      }\n    }\n  }\n\n  return new Transition(groups, this._parents, name, id);\n};\n\nd3Selection.selection.prototype.interrupt = selection_interrupt;\nd3Selection.selection.prototype.transition = selection_transition;\n\nvar root = [null];\n\nvar active = function(node, name) {\n  var schedules = node.__transition,\n      schedule,\n      i;\n\n  if (schedules) {\n    name = name == null ? null : name + \"\";\n    for (i in schedules) {\n      if ((schedule = schedules[i]).state > SCHEDULED && schedule.name === name) {\n        return new Transition([[node]], root, name, +i);\n      }\n    }\n  }\n\n  return null;\n};\n\nexports.transition = transition;\nexports.active = active;\nexports.interrupt = interrupt;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/d3-transition/build/d3-transition.js\n// module id = 368\n// module chunks = 234182462816062","// https://d3js.org/d3-zoom/ Version 1.7.1. Copyright 2017 Mike Bostock.\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-dispatch'), require('d3-drag'), require('d3-interpolate'), require('d3-selection'), require('d3-transition')) :\n\ttypeof define === 'function' && define.amd ? define(['exports', 'd3-dispatch', 'd3-drag', 'd3-interpolate', 'd3-selection', 'd3-transition'], factory) :\n\t(factory((global.d3 = global.d3 || {}),global.d3,global.d3,global.d3,global.d3,global.d3));\n}(this, (function (exports,d3Dispatch,d3Drag,d3Interpolate,d3Selection,d3Transition) { 'use strict';\n\nvar constant = function(x) {\n  return function() {\n    return x;\n  };\n};\n\nfunction ZoomEvent(target, type, transform) {\n  this.target = target;\n  this.type = type;\n  this.transform = transform;\n}\n\nfunction Transform(k, x, y) {\n  this.k = k;\n  this.x = x;\n  this.y = y;\n}\n\nTransform.prototype = {\n  constructor: Transform,\n  scale: function(k) {\n    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);\n  },\n  translate: function(x, y) {\n    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);\n  },\n  apply: function(point) {\n    return [point[0] * this.k + this.x, point[1] * this.k + this.y];\n  },\n  applyX: function(x) {\n    return x * this.k + this.x;\n  },\n  applyY: function(y) {\n    return y * this.k + this.y;\n  },\n  invert: function(location) {\n    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];\n  },\n  invertX: function(x) {\n    return (x - this.x) / this.k;\n  },\n  invertY: function(y) {\n    return (y - this.y) / this.k;\n  },\n  rescaleX: function(x) {\n    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));\n  },\n  rescaleY: function(y) {\n    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));\n  },\n  toString: function() {\n    return \"translate(\" + this.x + \",\" + this.y + \") scale(\" + this.k + \")\";\n  }\n};\n\nvar identity = new Transform(1, 0, 0);\n\ntransform.prototype = Transform.prototype;\n\nfunction transform(node) {\n  return node.__zoom || identity;\n}\n\nfunction nopropagation() {\n  d3Selection.event.stopImmediatePropagation();\n}\n\nvar noevent = function() {\n  d3Selection.event.preventDefault();\n  d3Selection.event.stopImmediatePropagation();\n};\n\n// Ignore right-click, since that should open the context menu.\nfunction defaultFilter() {\n  return !d3Selection.event.button;\n}\n\nfunction defaultExtent() {\n  var e = this, w, h;\n  if (e instanceof SVGElement) {\n    e = e.ownerSVGElement || e;\n    w = e.width.baseVal.value;\n    h = e.height.baseVal.value;\n  } else {\n    w = e.clientWidth;\n    h = e.clientHeight;\n  }\n  return [[0, 0], [w, h]];\n}\n\nfunction defaultTransform() {\n  return this.__zoom || identity;\n}\n\nfunction defaultWheelDelta() {\n  return -d3Selection.event.deltaY * (d3Selection.event.deltaMode ? 120 : 1) / 500;\n}\n\nfunction defaultTouchable() {\n  return \"ontouchstart\" in this;\n}\n\nfunction defaultConstrain(transform$$1, extent, translateExtent) {\n  var dx0 = transform$$1.invertX(extent[0][0]) - translateExtent[0][0],\n      dx1 = transform$$1.invertX(extent[1][0]) - translateExtent[1][0],\n      dy0 = transform$$1.invertY(extent[0][1]) - translateExtent[0][1],\n      dy1 = transform$$1.invertY(extent[1][1]) - translateExtent[1][1];\n  return transform$$1.translate(\n    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),\n    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)\n  );\n}\n\nvar zoom = function() {\n  var filter = defaultFilter,\n      extent = defaultExtent,\n      constrain = defaultConstrain,\n      wheelDelta = defaultWheelDelta,\n      touchable = defaultTouchable,\n      scaleExtent = [0, Infinity],\n      translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]],\n      duration = 250,\n      interpolate = d3Interpolate.interpolateZoom,\n      gestures = [],\n      listeners = d3Dispatch.dispatch(\"start\", \"zoom\", \"end\"),\n      touchstarting,\n      touchending,\n      touchDelay = 500,\n      wheelDelay = 150,\n      clickDistance2 = 0;\n\n  function zoom(selection) {\n    selection\n        .property(\"__zoom\", defaultTransform)\n        .on(\"wheel.zoom\", wheeled)\n        .on(\"mousedown.zoom\", mousedowned)\n        .on(\"dblclick.zoom\", dblclicked)\n      .filter(touchable)\n        .on(\"touchstart.zoom\", touchstarted)\n        .on(\"touchmove.zoom\", touchmoved)\n        .on(\"touchend.zoom touchcancel.zoom\", touchended)\n        .style(\"touch-action\", \"none\")\n        .style(\"-webkit-tap-highlight-color\", \"rgba(0,0,0,0)\");\n  }\n\n  zoom.transform = function(collection, transform$$1) {\n    var selection = collection.selection ? collection.selection() : collection;\n    selection.property(\"__zoom\", defaultTransform);\n    if (collection !== selection) {\n      schedule(collection, transform$$1);\n    } else {\n      selection.interrupt().each(function() {\n        gesture(this, arguments)\n            .start()\n            .zoom(null, typeof transform$$1 === \"function\" ? transform$$1.apply(this, arguments) : transform$$1)\n            .end();\n      });\n    }\n  };\n\n  zoom.scaleBy = function(selection, k) {\n    zoom.scaleTo(selection, function() {\n      var k0 = this.__zoom.k,\n          k1 = typeof k === \"function\" ? k.apply(this, arguments) : k;\n      return k0 * k1;\n    });\n  };\n\n  zoom.scaleTo = function(selection, k) {\n    zoom.transform(selection, function() {\n      var e = extent.apply(this, arguments),\n          t0 = this.__zoom,\n          p0 = centroid(e),\n          p1 = t0.invert(p0),\n          k1 = typeof k === \"function\" ? k.apply(this, arguments) : k;\n      return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);\n    });\n  };\n\n  zoom.translateBy = function(selection, x, y) {\n    zoom.transform(selection, function() {\n      return constrain(this.__zoom.translate(\n        typeof x === \"function\" ? x.apply(this, arguments) : x,\n        typeof y === \"function\" ? y.apply(this, arguments) : y\n      ), extent.apply(this, arguments), translateExtent);\n    });\n  };\n\n  zoom.translateTo = function(selection, x, y) {\n    zoom.transform(selection, function() {\n      var e = extent.apply(this, arguments),\n          t = this.__zoom,\n          p = centroid(e);\n      return constrain(identity.translate(p[0], p[1]).scale(t.k).translate(\n        typeof x === \"function\" ? -x.apply(this, arguments) : -x,\n        typeof y === \"function\" ? -y.apply(this, arguments) : -y\n      ), e, translateExtent);\n    });\n  };\n\n  function scale(transform$$1, k) {\n    k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));\n    return k === transform$$1.k ? transform$$1 : new Transform(k, transform$$1.x, transform$$1.y);\n  }\n\n  function translate(transform$$1, p0, p1) {\n    var x = p0[0] - p1[0] * transform$$1.k, y = p0[1] - p1[1] * transform$$1.k;\n    return x === transform$$1.x && y === transform$$1.y ? transform$$1 : new Transform(transform$$1.k, x, y);\n  }\n\n  function centroid(extent) {\n    return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];\n  }\n\n  function schedule(transition, transform$$1, center) {\n    transition\n        .on(\"start.zoom\", function() { gesture(this, arguments).start(); })\n        .on(\"interrupt.zoom end.zoom\", function() { gesture(this, arguments).end(); })\n        .tween(\"zoom\", function() {\n          var that = this,\n              args = arguments,\n              g = gesture(that, args),\n              e = extent.apply(that, args),\n              p = center || centroid(e),\n              w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),\n              a = that.__zoom,\n              b = typeof transform$$1 === \"function\" ? transform$$1.apply(that, args) : transform$$1,\n              i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));\n          return function(t) {\n            if (t === 1) t = b; // Avoid rounding error on end.\n            else { var l = i(t), k = w / l[2]; t = new Transform(k, p[0] - l[0] * k, p[1] - l[1] * k); }\n            g.zoom(null, t);\n          };\n        });\n  }\n\n  function gesture(that, args) {\n    for (var i = 0, n = gestures.length, g; i < n; ++i) {\n      if ((g = gestures[i]).that === that) {\n        return g;\n      }\n    }\n    return new Gesture(that, args);\n  }\n\n  function Gesture(that, args) {\n    this.that = that;\n    this.args = args;\n    this.index = -1;\n    this.active = 0;\n    this.extent = extent.apply(that, args);\n  }\n\n  Gesture.prototype = {\n    start: function() {\n      if (++this.active === 1) {\n        this.index = gestures.push(this) - 1;\n        this.emit(\"start\");\n      }\n      return this;\n    },\n    zoom: function(key, transform$$1) {\n      if (this.mouse && key !== \"mouse\") this.mouse[1] = transform$$1.invert(this.mouse[0]);\n      if (this.touch0 && key !== \"touch\") this.touch0[1] = transform$$1.invert(this.touch0[0]);\n      if (this.touch1 && key !== \"touch\") this.touch1[1] = transform$$1.invert(this.touch1[0]);\n      this.that.__zoom = transform$$1;\n      this.emit(\"zoom\");\n      return this;\n    },\n    end: function() {\n      if (--this.active === 0) {\n        gestures.splice(this.index, 1);\n        this.index = -1;\n        this.emit(\"end\");\n      }\n      return this;\n    },\n    emit: function(type) {\n      d3Selection.customEvent(new ZoomEvent(zoom, type, this.that.__zoom), listeners.apply, listeners, [type, this.that, this.args]);\n    }\n  };\n\n  function wheeled() {\n    if (!filter.apply(this, arguments)) return;\n    var g = gesture(this, arguments),\n        t = this.__zoom,\n        k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),\n        p = d3Selection.mouse(this);\n\n    // If the mouse is in the same location as before, reuse it.\n    // If there were recent wheel events, reset the wheel idle timeout.\n    if (g.wheel) {\n      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {\n        g.mouse[1] = t.invert(g.mouse[0] = p);\n      }\n      clearTimeout(g.wheel);\n    }\n\n    // If this wheel event won’t trigger a transform change, ignore it.\n    else if (t.k === k) return;\n\n    // Otherwise, capture the mouse point and location at the start.\n    else {\n      g.mouse = [p, t.invert(p)];\n      d3Transition.interrupt(this);\n      g.start();\n    }\n\n    noevent();\n    g.wheel = setTimeout(wheelidled, wheelDelay);\n    g.zoom(\"mouse\", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));\n\n    function wheelidled() {\n      g.wheel = null;\n      g.end();\n    }\n  }\n\n  function mousedowned() {\n    if (touchending || !filter.apply(this, arguments)) return;\n    var g = gesture(this, arguments),\n        v = d3Selection.select(d3Selection.event.view).on(\"mousemove.zoom\", mousemoved, true).on(\"mouseup.zoom\", mouseupped, true),\n        p = d3Selection.mouse(this),\n        x0 = d3Selection.event.clientX,\n        y0 = d3Selection.event.clientY;\n\n    d3Drag.dragDisable(d3Selection.event.view);\n    nopropagation();\n    g.mouse = [p, this.__zoom.invert(p)];\n    d3Transition.interrupt(this);\n    g.start();\n\n    function mousemoved() {\n      noevent();\n      if (!g.moved) {\n        var dx = d3Selection.event.clientX - x0, dy = d3Selection.event.clientY - y0;\n        g.moved = dx * dx + dy * dy > clickDistance2;\n      }\n      g.zoom(\"mouse\", constrain(translate(g.that.__zoom, g.mouse[0] = d3Selection.mouse(g.that), g.mouse[1]), g.extent, translateExtent));\n    }\n\n    function mouseupped() {\n      v.on(\"mousemove.zoom mouseup.zoom\", null);\n      d3Drag.dragEnable(d3Selection.event.view, g.moved);\n      noevent();\n      g.end();\n    }\n  }\n\n  function dblclicked() {\n    if (!filter.apply(this, arguments)) return;\n    var t0 = this.__zoom,\n        p0 = d3Selection.mouse(this),\n        p1 = t0.invert(p0),\n        k1 = t0.k * (d3Selection.event.shiftKey ? 0.5 : 2),\n        t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, arguments), translateExtent);\n\n    noevent();\n    if (duration > 0) d3Selection.select(this).transition().duration(duration).call(schedule, t1, p0);\n    else d3Selection.select(this).call(zoom.transform, t1);\n  }\n\n  function touchstarted() {\n    if (!filter.apply(this, arguments)) return;\n    var g = gesture(this, arguments),\n        touches = d3Selection.event.changedTouches,\n        started,\n        n = touches.length, i, t, p;\n\n    nopropagation();\n    for (i = 0; i < n; ++i) {\n      t = touches[i], p = d3Selection.touch(this, touches, t.identifier);\n      p = [p, this.__zoom.invert(p), t.identifier];\n      if (!g.touch0) g.touch0 = p, started = true;\n      else if (!g.touch1) g.touch1 = p;\n    }\n\n    // If this is a dbltap, reroute to the (optional) dblclick.zoom handler.\n    if (touchstarting) {\n      touchstarting = clearTimeout(touchstarting);\n      if (!g.touch1) {\n        g.end();\n        p = d3Selection.select(this).on(\"dblclick.zoom\");\n        if (p) p.apply(this, arguments);\n        return;\n      }\n    }\n\n    if (started) {\n      touchstarting = setTimeout(function() { touchstarting = null; }, touchDelay);\n      d3Transition.interrupt(this);\n      g.start();\n    }\n  }\n\n  function touchmoved() {\n    var g = gesture(this, arguments),\n        touches = d3Selection.event.changedTouches,\n        n = touches.length, i, t, p, l;\n\n    noevent();\n    if (touchstarting) touchstarting = clearTimeout(touchstarting);\n    for (i = 0; i < n; ++i) {\n      t = touches[i], p = d3Selection.touch(this, touches, t.identifier);\n      if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;\n      else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;\n    }\n    t = g.that.__zoom;\n    if (g.touch1) {\n      var p0 = g.touch0[0], l0 = g.touch0[1],\n          p1 = g.touch1[0], l1 = g.touch1[1],\n          dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,\n          dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;\n      t = scale(t, Math.sqrt(dp / dl));\n      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];\n      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];\n    }\n    else if (g.touch0) p = g.touch0[0], l = g.touch0[1];\n    else return;\n    g.zoom(\"touch\", constrain(translate(t, p, l), g.extent, translateExtent));\n  }\n\n  function touchended() {\n    var g = gesture(this, arguments),\n        touches = d3Selection.event.changedTouches,\n        n = touches.length, i, t;\n\n    nopropagation();\n    if (touchending) clearTimeout(touchending);\n    touchending = setTimeout(function() { touchending = null; }, touchDelay);\n    for (i = 0; i < n; ++i) {\n      t = touches[i];\n      if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;\n      else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;\n    }\n    if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;\n    if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);\n    else g.end();\n  }\n\n  zoom.wheelDelta = function(_) {\n    return arguments.length ? (wheelDelta = typeof _ === \"function\" ? _ : constant(+_), zoom) : wheelDelta;\n  };\n\n  zoom.filter = function(_) {\n    return arguments.length ? (filter = typeof _ === \"function\" ? _ : constant(!!_), zoom) : filter;\n  };\n\n  zoom.touchable = function(_) {\n    return arguments.length ? (touchable = typeof _ === \"function\" ? _ : constant(!!_), zoom) : touchable;\n  };\n\n  zoom.extent = function(_) {\n    return arguments.length ? (extent = typeof _ === \"function\" ? _ : constant([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;\n  };\n\n  zoom.scaleExtent = function(_) {\n    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];\n  };\n\n  zoom.translateExtent = function(_) {\n    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];\n  };\n\n  zoom.constrain = function(_) {\n    return arguments.length ? (constrain = _, zoom) : constrain;\n  };\n\n  zoom.duration = function(_) {\n    return arguments.length ? (duration = +_, zoom) : duration;\n  };\n\n  zoom.interpolate = function(_) {\n    return arguments.length ? (interpolate = _, zoom) : interpolate;\n  };\n\n  zoom.on = function() {\n    var value = listeners.on.apply(listeners, arguments);\n    return value === listeners ? zoom : value;\n  };\n\n  zoom.clickDistance = function(_) {\n    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);\n  };\n\n  return zoom;\n};\n\nexports.zoom = zoom;\nexports.zoomTransform = transform;\nexports.zoomIdentity = identity;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/d3-zoom/build/d3-zoom.js\n// module id = 369\n// module chunks = 234182462816062","// https://github.com/topojson/topojson-client Version 3.0.0. Copyright 2017 Mike Bostock.\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(factory((global.topojson = global.topojson || {})));\n}(this, (function (exports) { 'use strict';\n\nvar identity = function(x) {\n  return x;\n};\n\nvar transform = function(transform) {\n  if (transform == null) return identity;\n  var x0,\n      y0,\n      kx = transform.scale[0],\n      ky = transform.scale[1],\n      dx = transform.translate[0],\n      dy = transform.translate[1];\n  return function(input, i) {\n    if (!i) x0 = y0 = 0;\n    var j = 2, n = input.length, output = new Array(n);\n    output[0] = (x0 += input[0]) * kx + dx;\n    output[1] = (y0 += input[1]) * ky + dy;\n    while (j < n) output[j] = input[j], ++j;\n    return output;\n  };\n};\n\nvar bbox = function(topology) {\n  var t = transform(topology.transform), key,\n      x0 = Infinity, y0 = x0, x1 = -x0, y1 = -x0;\n\n  function bboxPoint(p) {\n    p = t(p);\n    if (p[0] < x0) x0 = p[0];\n    if (p[0] > x1) x1 = p[0];\n    if (p[1] < y0) y0 = p[1];\n    if (p[1] > y1) y1 = p[1];\n  }\n\n  function bboxGeometry(o) {\n    switch (o.type) {\n      case \"GeometryCollection\": o.geometries.forEach(bboxGeometry); break;\n      case \"Point\": bboxPoint(o.coordinates); break;\n      case \"MultiPoint\": o.coordinates.forEach(bboxPoint); break;\n    }\n  }\n\n  topology.arcs.forEach(function(arc) {\n    var i = -1, n = arc.length, p;\n    while (++i < n) {\n      p = t(arc[i], i);\n      if (p[0] < x0) x0 = p[0];\n      if (p[0] > x1) x1 = p[0];\n      if (p[1] < y0) y0 = p[1];\n      if (p[1] > y1) y1 = p[1];\n    }\n  });\n\n  for (key in topology.objects) {\n    bboxGeometry(topology.objects[key]);\n  }\n\n  return [x0, y0, x1, y1];\n};\n\nvar reverse = function(array, n) {\n  var t, j = array.length, i = j - n;\n  while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;\n};\n\nvar feature = function(topology, o) {\n  return o.type === \"GeometryCollection\"\n      ? {type: \"FeatureCollection\", features: o.geometries.map(function(o) { return feature$1(topology, o); })}\n      : feature$1(topology, o);\n};\n\nfunction feature$1(topology, o) {\n  var id = o.id,\n      bbox = o.bbox,\n      properties = o.properties == null ? {} : o.properties,\n      geometry = object(topology, o);\n  return id == null && bbox == null ? {type: \"Feature\", properties: properties, geometry: geometry}\n      : bbox == null ? {type: \"Feature\", id: id, properties: properties, geometry: geometry}\n      : {type: \"Feature\", id: id, bbox: bbox, properties: properties, geometry: geometry};\n}\n\nfunction object(topology, o) {\n  var transformPoint = transform(topology.transform),\n      arcs = topology.arcs;\n\n  function arc(i, points) {\n    if (points.length) points.pop();\n    for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {\n      points.push(transformPoint(a[k], k));\n    }\n    if (i < 0) reverse(points, n);\n  }\n\n  function point(p) {\n    return transformPoint(p);\n  }\n\n  function line(arcs) {\n    var points = [];\n    for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);\n    if (points.length < 2) points.push(points[0]); // This should never happen per the specification.\n    return points;\n  }\n\n  function ring(arcs) {\n    var points = line(arcs);\n    while (points.length < 4) points.push(points[0]); // This may happen if an arc has only two points.\n    return points;\n  }\n\n  function polygon(arcs) {\n    return arcs.map(ring);\n  }\n\n  function geometry(o) {\n    var type = o.type, coordinates;\n    switch (type) {\n      case \"GeometryCollection\": return {type: type, geometries: o.geometries.map(geometry)};\n      case \"Point\": coordinates = point(o.coordinates); break;\n      case \"MultiPoint\": coordinates = o.coordinates.map(point); break;\n      case \"LineString\": coordinates = line(o.arcs); break;\n      case \"MultiLineString\": coordinates = o.arcs.map(line); break;\n      case \"Polygon\": coordinates = polygon(o.arcs); break;\n      case \"MultiPolygon\": coordinates = o.arcs.map(polygon); break;\n      default: return null;\n    }\n    return {type: type, coordinates: coordinates};\n  }\n\n  return geometry(o);\n}\n\nvar stitch = function(topology, arcs) {\n  var stitchedArcs = {},\n      fragmentByStart = {},\n      fragmentByEnd = {},\n      fragments = [],\n      emptyIndex = -1;\n\n  // Stitch empty arcs first, since they may be subsumed by other arcs.\n  arcs.forEach(function(i, j) {\n    var arc = topology.arcs[i < 0 ? ~i : i], t;\n    if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {\n      t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;\n    }\n  });\n\n  arcs.forEach(function(i) {\n    var e = ends(i),\n        start = e[0],\n        end = e[1],\n        f, g;\n\n    if (f = fragmentByEnd[start]) {\n      delete fragmentByEnd[f.end];\n      f.push(i);\n      f.end = end;\n      if (g = fragmentByStart[end]) {\n        delete fragmentByStart[g.start];\n        var fg = g === f ? f : f.concat(g);\n        fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;\n      } else {\n        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n      }\n    } else if (f = fragmentByStart[end]) {\n      delete fragmentByStart[f.start];\n      f.unshift(i);\n      f.start = start;\n      if (g = fragmentByEnd[start]) {\n        delete fragmentByEnd[g.end];\n        var gf = g === f ? f : g.concat(f);\n        fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;\n      } else {\n        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n      }\n    } else {\n      f = [i];\n      fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;\n    }\n  });\n\n  function ends(i) {\n    var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;\n    if (topology.transform) p1 = [0, 0], arc.forEach(function(dp) { p1[0] += dp[0], p1[1] += dp[1]; });\n    else p1 = arc[arc.length - 1];\n    return i < 0 ? [p1, p0] : [p0, p1];\n  }\n\n  function flush(fragmentByEnd, fragmentByStart) {\n    for (var k in fragmentByEnd) {\n      var f = fragmentByEnd[k];\n      delete fragmentByStart[f.start];\n      delete f.start;\n      delete f.end;\n      f.forEach(function(i) { stitchedArcs[i < 0 ? ~i : i] = 1; });\n      fragments.push(f);\n    }\n  }\n\n  flush(fragmentByEnd, fragmentByStart);\n  flush(fragmentByStart, fragmentByEnd);\n  arcs.forEach(function(i) { if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]); });\n\n  return fragments;\n};\n\nvar mesh = function(topology) {\n  return object(topology, meshArcs.apply(this, arguments));\n};\n\nfunction meshArcs(topology, object$$1, filter) {\n  var arcs, i, n;\n  if (arguments.length > 1) arcs = extractArcs(topology, object$$1, filter);\n  else for (i = 0, arcs = new Array(n = topology.arcs.length); i < n; ++i) arcs[i] = i;\n  return {type: \"MultiLineString\", arcs: stitch(topology, arcs)};\n}\n\nfunction extractArcs(topology, object$$1, filter) {\n  var arcs = [],\n      geomsByArc = [],\n      geom;\n\n  function extract0(i) {\n    var j = i < 0 ? ~i : i;\n    (geomsByArc[j] || (geomsByArc[j] = [])).push({i: i, g: geom});\n  }\n\n  function extract1(arcs) {\n    arcs.forEach(extract0);\n  }\n\n  function extract2(arcs) {\n    arcs.forEach(extract1);\n  }\n\n  function extract3(arcs) {\n    arcs.forEach(extract2);\n  }\n\n  function geometry(o) {\n    switch (geom = o, o.type) {\n      case \"GeometryCollection\": o.geometries.forEach(geometry); break;\n      case \"LineString\": extract1(o.arcs); break;\n      case \"MultiLineString\": case \"Polygon\": extract2(o.arcs); break;\n      case \"MultiPolygon\": extract3(o.arcs); break;\n    }\n  }\n\n  geometry(object$$1);\n\n  geomsByArc.forEach(filter == null\n      ? function(geoms) { arcs.push(geoms[0].i); }\n      : function(geoms) { if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i); });\n\n  return arcs;\n}\n\nfunction planarRingArea(ring) {\n  var i = -1, n = ring.length, a, b = ring[n - 1], area = 0;\n  while (++i < n) a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0];\n  return Math.abs(area); // Note: doubled area!\n}\n\nvar merge = function(topology) {\n  return object(topology, mergeArcs.apply(this, arguments));\n};\n\nfunction mergeArcs(topology, objects) {\n  var polygonsByArc = {},\n      polygons = [],\n      groups = [];\n\n  objects.forEach(geometry);\n\n  function geometry(o) {\n    switch (o.type) {\n      case \"GeometryCollection\": o.geometries.forEach(geometry); break;\n      case \"Polygon\": extract(o.arcs); break;\n      case \"MultiPolygon\": o.arcs.forEach(extract); break;\n    }\n  }\n\n  function extract(polygon) {\n    polygon.forEach(function(ring) {\n      ring.forEach(function(arc) {\n        (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);\n      });\n    });\n    polygons.push(polygon);\n  }\n\n  function area(ring) {\n    return planarRingArea(object(topology, {type: \"Polygon\", arcs: [ring]}).coordinates[0]);\n  }\n\n  polygons.forEach(function(polygon) {\n    if (!polygon._) {\n      var group = [],\n          neighbors = [polygon];\n      polygon._ = 1;\n      groups.push(group);\n      while (polygon = neighbors.pop()) {\n        group.push(polygon);\n        polygon.forEach(function(ring) {\n          ring.forEach(function(arc) {\n            polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon) {\n              if (!polygon._) {\n                polygon._ = 1;\n                neighbors.push(polygon);\n              }\n            });\n          });\n        });\n      }\n    }\n  });\n\n  polygons.forEach(function(polygon) {\n    delete polygon._;\n  });\n\n  return {\n    type: \"MultiPolygon\",\n    arcs: groups.map(function(polygons) {\n      var arcs = [], n;\n\n      // Extract the exterior (unique) arcs.\n      polygons.forEach(function(polygon) {\n        polygon.forEach(function(ring) {\n          ring.forEach(function(arc) {\n            if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {\n              arcs.push(arc);\n            }\n          });\n        });\n      });\n\n      // Stitch the arcs into one or more rings.\n      arcs = stitch(topology, arcs);\n\n      // If more than one ring is returned,\n      // at most one of these rings can be the exterior;\n      // choose the one with the greatest absolute area.\n      if ((n = arcs.length) > 1) {\n        for (var i = 1, k = area(arcs[0]), ki, t; i < n; ++i) {\n          if ((ki = area(arcs[i])) > k) {\n            t = arcs[0], arcs[0] = arcs[i], arcs[i] = t, k = ki;\n          }\n        }\n      }\n\n      return arcs;\n    })\n  };\n}\n\nvar bisect = function(a, x) {\n  var lo = 0, hi = a.length;\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (a[mid] < x) lo = mid + 1;\n    else hi = mid;\n  }\n  return lo;\n};\n\nvar neighbors = function(objects) {\n  var indexesByArc = {}, // arc index -> array of object indexes\n      neighbors = objects.map(function() { return []; });\n\n  function line(arcs, i) {\n    arcs.forEach(function(a) {\n      if (a < 0) a = ~a;\n      var o = indexesByArc[a];\n      if (o) o.push(i);\n      else indexesByArc[a] = [i];\n    });\n  }\n\n  function polygon(arcs, i) {\n    arcs.forEach(function(arc) { line(arc, i); });\n  }\n\n  function geometry(o, i) {\n    if (o.type === \"GeometryCollection\") o.geometries.forEach(function(o) { geometry(o, i); });\n    else if (o.type in geometryType) geometryType[o.type](o.arcs, i);\n  }\n\n  var geometryType = {\n    LineString: line,\n    MultiLineString: polygon,\n    Polygon: polygon,\n    MultiPolygon: function(arcs, i) { arcs.forEach(function(arc) { polygon(arc, i); }); }\n  };\n\n  objects.forEach(geometry);\n\n  for (var i in indexesByArc) {\n    for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {\n      for (var k = j + 1; k < m; ++k) {\n        var ij = indexes[j], ik = indexes[k], n;\n        if ((n = neighbors[ij])[i = bisect(n, ik)] !== ik) n.splice(i, 0, ik);\n        if ((n = neighbors[ik])[i = bisect(n, ij)] !== ij) n.splice(i, 0, ij);\n      }\n    }\n  }\n\n  return neighbors;\n};\n\nvar untransform = function(transform) {\n  if (transform == null) return identity;\n  var x0,\n      y0,\n      kx = transform.scale[0],\n      ky = transform.scale[1],\n      dx = transform.translate[0],\n      dy = transform.translate[1];\n  return function(input, i) {\n    if (!i) x0 = y0 = 0;\n    var j = 2,\n        n = input.length,\n        output = new Array(n),\n        x1 = Math.round((input[0] - dx) / kx),\n        y1 = Math.round((input[1] - dy) / ky);\n    output[0] = x1 - x0, x0 = x1;\n    output[1] = y1 - y0, y0 = y1;\n    while (j < n) output[j] = input[j], ++j;\n    return output;\n  };\n};\n\nvar quantize = function(topology, transform) {\n  if (topology.transform) throw new Error(\"already quantized\");\n\n  if (!transform || !transform.scale) {\n    if (!((n = Math.floor(transform)) >= 2)) throw new Error(\"n must be ≥2\");\n    box = topology.bbox || bbox(topology);\n    var x0 = box[0], y0 = box[1], x1 = box[2], y1 = box[3], n;\n    transform = {scale: [x1 - x0 ? (x1 - x0) / (n - 1) : 1, y1 - y0 ? (y1 - y0) / (n - 1) : 1], translate: [x0, y0]};\n  } else {\n    box = topology.bbox;\n  }\n\n  var t = untransform(transform), box, key, inputs = topology.objects, outputs = {};\n\n  function quantizePoint(point) {\n    return t(point);\n  }\n\n  function quantizeGeometry(input) {\n    var output;\n    switch (input.type) {\n      case \"GeometryCollection\": output = {type: \"GeometryCollection\", geometries: input.geometries.map(quantizeGeometry)}; break;\n      case \"Point\": output = {type: \"Point\", coordinates: quantizePoint(input.coordinates)}; break;\n      case \"MultiPoint\": output = {type: \"MultiPoint\", coordinates: input.coordinates.map(quantizePoint)}; break;\n      default: return input;\n    }\n    if (input.id != null) output.id = input.id;\n    if (input.bbox != null) output.bbox = input.bbox;\n    if (input.properties != null) output.properties = input.properties;\n    return output;\n  }\n\n  function quantizeArc(input) {\n    var i = 0, j = 1, n = input.length, p, output = new Array(n); // pessimistic\n    output[0] = t(input[0], 0);\n    while (++i < n) if ((p = t(input[i], i))[0] || p[1]) output[j++] = p; // non-coincident points\n    if (j === 1) output[j++] = [0, 0]; // an arc must have at least two points\n    output.length = j;\n    return output;\n  }\n\n  for (key in inputs) outputs[key] = quantizeGeometry(inputs[key]);\n\n  return {\n    type: \"Topology\",\n    bbox: box,\n    transform: transform,\n    objects: outputs,\n    arcs: topology.arcs.map(quantizeArc)\n  };\n};\n\nexports.bbox = bbox;\nexports.feature = feature;\nexports.mesh = mesh;\nexports.meshArcs = meshArcs;\nexports.merge = merge;\nexports.mergeArcs = mergeArcs;\nexports.neighbors = neighbors;\nexports.quantize = quantize;\nexports.transform = transform;\nexports.untransform = untransform;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/topojson-client/dist/topojson-client.js\n// module id = 226\n// module chunks = 115685857604607 234182462816062","var v1 = require('./v1');\nvar v4 = require('./v4');\n\nvar uuid = v4;\nuuid.v1 = v1;\nuuid.v4 = v4;\n\nmodule.exports = uuid;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/uuid/index.js\n// module id = 71\n// module chunks = 90760845664978 115685857604607 234182462816062","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  return bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]];\n}\n\nmodule.exports = bytesToUuid;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/uuid/lib/bytesToUuid.js\n// module id = 34\n// module chunks = 90760845664978 115685857604607 234182462816062","// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\n\n// getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\nvar getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues.bind(crypto)) ||\n                      (typeof(msCrypto) != 'undefined' && msCrypto.getRandomValues.bind(msCrypto));\nif (getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\n  module.exports = function whatwgRNG() {\n    getRandomValues(rnds8);\n    return rnds8;\n  };\n} else {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var rnds = new Array(16);\n\n  module.exports = function mathRNG() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/uuid/lib/rng-browser.js\n// module id = 35\n// module chunks = 90760845664978 115685857604607 234182462816062","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nvar _nodeId;\nvar _clockseq;\n\n// Previous uuid creation time\nvar _lastMSecs = 0;\nvar _lastNSecs = 0;\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n\n  options = options || {};\n  var node = options.node || _nodeId;\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\n  // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n  if (node == null || clockseq == null) {\n    var seedBytes = rng();\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [\n        seedBytes[0] | 0x01,\n        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]\n      ];\n    }\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  }\n\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : bytesToUuid(b);\n}\n\nmodule.exports = v1;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/uuid/v1.js\n// module id = 109\n// module chunks = 90760845664978 115685857604607 234182462816062","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/uuid/v4.js\n// module id = 110\n// module chunks = 90760845664978 115685857604607 234182462816062","import React, { Component } from 'react'\r\nimport { zoom as d3Zoom } from 'd3-zoom'\r\nimport { select as d3Select, event } from 'd3-selection'\r\nimport PropTypes from 'prop-types'\r\nimport WorldMap from './WorldMap'\r\n\r\nclass GlobeViewChart extends Component {\r\n  state = {\r\n    transform: null,\r\n  }\r\n  componentDidMount() {\r\n    d3Select(this.worldmap).call(\r\n      d3Zoom()\r\n        .scaleExtent([0.5, 10])\r\n        .on('zoom', this.onZoomHandler)\r\n    )\r\n  }\r\n  onZoomHandler = () => {\r\n    if (event.type === 'zoom') {\r\n      this.setState({ transform: event.transform })\r\n    }\r\n  }\r\n  showToolTipInfo = value => {\r\n    const { showToolTip } = this.props\r\n    showToolTip(value)\r\n  }\r\n  hideToolTipInfo = () => {\r\n    const { hideToolTip } = this.props\r\n    hideToolTip()\r\n  }\r\n\r\n  render() {\r\n    const { globeData, meteorsInfo, svgWidth, svgHeight } = this.props\r\n    const { transform } = this.state\r\n    return (\r\n      <svg\r\n        width={svgWidth}\r\n        height={svgHeight}\r\n        ref={el => {\r\n          this.worldmap = el\r\n        }}\r\n        viewBox={`0 0 ${svgWidth} ${svgHeight}`}\r\n        preserveAspectRatio=\"xMidYMid meet\">\r\n        <g\r\n          transform={\r\n            transform !== null\r\n              ? `translate(${transform.x}, ${transform.y}) scale(${\r\n                  transform.k\r\n                })`\r\n              : null\r\n          }>\r\n          <WorldMap\r\n            width={svgWidth}\r\n            height={500}\r\n            world={globeData}\r\n            meteorfall={meteorsInfo}\r\n            pointEnter={this.showToolTipInfo}\r\n            pointExit={this.hideToolTipInfo}\r\n          />\r\n        </g>\r\n      </svg>\r\n    )\r\n  }\r\n}\r\nGlobeViewChart.propTypes = {\r\n  svgWidth: PropTypes.number,\r\n  svgHeight: PropTypes.number,\r\n  showToolTip: PropTypes.func,\r\n  hideToolTip: PropTypes.func,\r\n  globeData: PropTypes.arrayOf(\r\n    PropTypes.shape({\r\n      dpath: PropTypes.string,\r\n      fillInfo: PropTypes.string,\r\n    })\r\n  ),\r\n  meteorsInfo: PropTypes.arrayOf(\r\n    PropTypes.shape({\r\n      date: PropTypes.string,\r\n      fillOp: PropTypes.number,\r\n      latitude: PropTypes.number,\r\n      longitude: PropTypes.number,\r\n      mass: PropTypes.number,\r\n      name: PropTypes.string,\r\n      radius: PropTypes.number,\r\n      meteorClass: PropTypes.string,\r\n    })\r\n  ),\r\n}\r\nexport default GlobeViewChart\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/Challenges/GlobeChartView/GlobeViewChart.js","import { geoMercator, geoPath } from 'd3-geo'\r\nimport React, { Component } from 'react'\r\nimport { feature } from 'topojson-client'\r\nimport Utilities from '../../../Utils/Utilities'\r\nimport Preload from '../../Preloader/index'\r\nimport GlobeViewChart from './GlobeViewChart'\r\nimport MeteorToolTip from './MeteorToolTip'\r\nimport styles from './globe-style.module.css'\r\n\r\nclass GlobeViewContainer extends Component {\r\n  // #region component methods\r\n  state = {\r\n    isLoading: true,\r\n    isError: false,\r\n    isToolTipActive: false,\r\n    meteorInfo: {},\r\n    chartWidth: 0,\r\n    chartHeight: 0,\r\n    meteors: [],\r\n    globeMap: [],\r\n    mapData: [],\r\n    meteorData: [],\r\n  }\r\n  componentDidMount() {\r\n    if (typeof window !== 'undefined') {\r\n      this.setChartDimensions()\r\n      window.addEventListener('resize', this.setChartDimensions)\r\n    }\r\n    setTimeout(() => {\r\n      const storedMap = JSON.parse(Utilities.getStorageData('globeMap'))\r\n      const meteorsData = JSON.parse(Utilities.getStorageData('meteors'))\r\n      if (!storedMap) {\r\n        this.fetchData()\r\n        this.fetchDataMeteor()\r\n      } else {\r\n        const updatedMap = storedMap.map((d, i) => {\r\n          return {\r\n            dpath: geoPath().projection(this.project())(d),\r\n            fillInfo: `rgba(38,50,56,${(1 / storedMap.length) * i})`,\r\n          }\r\n        })\r\n        const meteorPoints = meteorsData.map(d => {\r\n          return {\r\n            name: d.properties.name,\r\n            mass: parseInt(d.properties.mass, 10),\r\n            date: d.properties.year,\r\n            meteorClass: d.properties.recclass,\r\n            radius: this.calculateRadius(parseInt(d.properties.mass, 10)),\r\n            latitude: this.project()([\r\n              Number(d.properties.reclong),\r\n              Number(d.properties.reclat),\r\n            ])[0],\r\n            longitude: this.project()([\r\n              Number(d.properties.reclong),\r\n              Number(d.properties.reclat),\r\n            ])[1],\r\n            fillOp: parseInt(d.properties.mass, 10) <= 179687.5 ? 1 : 0.5,\r\n          }\r\n        })\r\n        this.setState({\r\n          meteors: meteorPoints,\r\n          meteorData: meteorsData,\r\n          globeMap: updatedMap,\r\n          mapData: storedMap,\r\n        })\r\n        /* this.setState(prevState=>({\r\n                    globeMap:storedMap,\r\n                    meteors:meteorsData,\r\n                    meteors:meteorPoints,\r\n                    globeMap:updatedMap,\r\n                })); */\r\n      }\r\n    }, 2500)\r\n  }\r\n  componentWillUnmount() {\r\n    if (typeof window !== 'undefined') {\r\n      window.removeEventListener('resize', this.setChartDimensions)\r\n    }\r\n  }\r\n  // #endregion\r\n\r\n  // #region chart dimensioning\r\n  setChartWidth = value => {\r\n    return value * 0.8\r\n  }\r\n  setChartDimensions = () => {\r\n    const { chartWidth } = this.state\r\n    let currentWidth = 0\r\n    let currentHeight = 0\r\n    if (this.chartContainer) {\r\n      currentWidth = this.chartContainer.getBoundingClientRect().width\r\n      currentHeight = this.chartContainer.getBoundingClientRect().height\r\n\r\n      currentWidth =\r\n        this.chartContainer.getBoundingClientRect().width <= 768\r\n          ? this.setChartWidth(\r\n              this.chartContainer.getBoundingClientRect().width\r\n            )\r\n          : this.chartContainer.getBoundingClientRect().width\r\n      currentHeight =\r\n        this.chartContainer.getBoundingClientRect().width <= 768\r\n          ? this.setChartWidth(\r\n              this.chartContainer.getBoundingClientRect().height\r\n            )\r\n          : this.chartContainer.getBoundingClientRect().height\r\n\r\n      if (currentWidth !== chartWidth) {\r\n        this.setState({\r\n          chartWidth: currentWidth,\r\n          chartHeight: currentHeight,\r\n        })\r\n      }\r\n    } else {\r\n      currentWidth = window.innerWidth >= 960 ? 900 : window.innerWidth\r\n      currentHeight = this.setChartWidth(window.innerHeight)\r\n      if (currentWidth !== chartWidth) {\r\n        this.setState({\r\n          chartWidth: currentWidth,\r\n          chartHeight: currentHeight,\r\n        })\r\n      }\r\n    }\r\n    this.updateMap()\r\n  }\r\n  project() {\r\n    const { chartWidth, chartHeight } = this.state\r\n    if (chartWidth < 768) {\r\n      return geoMercator()\r\n        .scale(chartWidth)\r\n        .translate([chartWidth / 2, chartHeight / 2])\r\n    }\r\n    return geoMercator()\r\n      .scale(100)\r\n      .translate([chartWidth / 2, chartHeight / 2])\r\n  }\r\n  updateMap = () => {\r\n    const { mapData, meteorData } = this.state\r\n    const updatedMap = mapData.map((d, i) => {\r\n      return {\r\n        dpath: geoPath().projection(this.project())(d),\r\n        fillInfo: `rgba(38,50,56,${(1 / mapData.length) * i})`,\r\n      }\r\n    })\r\n    const meteorPoints = meteorData.map(d => {\r\n      return {\r\n        name: d.properties.name,\r\n        mass: parseInt(d.properties.mass, 10),\r\n        date: d.properties.year,\r\n        meteorClass: d.properties.recclass,\r\n        radius: this.calculateRadius(parseInt(d.properties.mass, 10)),\r\n        latitude: this.project()([\r\n          Number(d.properties.reclong),\r\n          Number(d.properties.reclat),\r\n        ])[0],\r\n        longitude: this.project()([\r\n          Number(d.properties.reclong),\r\n          Number(d.properties.reclat),\r\n        ])[1],\r\n        fillOp: parseInt(d.properties.mass, 10) <= 179687.5 ? 1 : 0.5,\r\n      }\r\n    })\r\n    this.setState({ meteors: meteorPoints, globeMap: updatedMap })\r\n  }\r\n  calculateRadius = value => {\r\n    const range = 179687.5\r\n\r\n    switch (true) {\r\n      case value <= range:\r\n        return 2\r\n      case value <= range * 2:\r\n        return 4\r\n      case value <= range * 3:\r\n        return 6\r\n      case value <= range * 20:\r\n        return 8\r\n      case value <= range * 100:\r\n        return 8\r\n      default:\r\n        return 12\r\n    }\r\n  }\r\n  // #endregion\r\n\r\n  // #region fetch data\r\n  fetchDataMeteor() {\r\n    fetch('https://data.nasa.gov/resource/y77d-th95.geojson')\r\n      .then(response => {\r\n        return response.json()\r\n      })\r\n      .then(result => {\r\n        const meteorPoints = result.features.map(d => {\r\n          return {\r\n            name: d.properties.name,\r\n            mass: parseInt(d.properties.mass, 10),\r\n            date: d.properties.year,\r\n            meteorClass: d.properties.recclass,\r\n            radius: this.calculateRadius(parseInt(d.properties.mass, 10)),\r\n            latitude: this.project()([\r\n              Number(d.properties.reclong),\r\n              Number(d.properties.reclat),\r\n            ])[0],\r\n            longitude: this.project()([\r\n              Number(d.properties.reclong),\r\n              Number(d.properties.reclat),\r\n            ])[1],\r\n            fillOp: parseInt(d.properties.mass, 10) <= 179687.5 ? 1 : 0.5,\r\n          }\r\n        })\r\n        Utilities.setStorageData('meteors', result.features)\r\n        this.setState({\r\n          meteors: meteorPoints,\r\n          meteorData: result.features,\r\n        })\r\n      })\r\n      .catch(err => {\r\n        console.log('====================================')\r\n        console.log(\r\n          `error getting the meteors data:${JSON.stringify(err, null, 2)}`\r\n        )\r\n        console.log('====================================')\r\n        this.setState({ isError: true })\r\n      })\r\n  }\r\n\r\n  fetchData() {\r\n    fetch('https://d3js.org/world-50m.v1.json')\r\n      .then(response => {\r\n        return response.json()\r\n      })\r\n      .then(result => {\r\n        const pathsGlobe = feature(result, result.objects.countries).features\r\n\r\n        console.log('====================================')\r\n        console.log(\r\n          `pathsglobe features=>${JSON.stringify(pathsGlobe, null, 2)}`\r\n        )\r\n        console.log('====================================')\r\n\r\n        const formattedMap = pathsGlobe.map((d, i) => {\r\n          return {\r\n            dpath: geoPath().projection(this.project())(d),\r\n            fillInfo: `rgba(38,50,56,${(1 / pathsGlobe.length) * i})`,\r\n          }\r\n        })\r\n        Utilities.setStorageData('globeMap', pathsGlobe)\r\n        this.setState({\r\n          globeMap: formattedMap,\r\n          mapData: pathsGlobe,\r\n        })\r\n      })\r\n      .catch(err => {\r\n        console.log('====================================')\r\n        console.log(\r\n          `error getting the chart data:${JSON.stringify(err, null, 2)}`\r\n        )\r\n        console.log('====================================')\r\n        this.setState({ isError: true })\r\n      })\r\n  }\r\n  // #endregion\r\n\r\n  // #region visibility\r\n  activateToolTip = value => {\r\n    this.setState({ isToolTipActive: true, meteorInfo: value })\r\n  }\r\n  disableToolTip = () => {\r\n    this.setState({ isToolTipActive: false, meteorInfo: {} })\r\n  }\r\n  handlePreloadShutdown = () => {\r\n    this.setState({\r\n      isLoading: false,\r\n    })\r\n  }\r\n  // #endregion\r\n\r\n  // #region render\r\n  render() {\r\n    const {\r\n      isError,\r\n      isLoading,\r\n      globeMap,\r\n      meteors,\r\n      isToolTipActive,\r\n      meteorInfo,\r\n      chartWidth,\r\n      chartHeight,\r\n    } = this.state\r\n    if (isError) {\r\n      return (\r\n        <div className={styles.globeTitle}>\r\n          Lights up the sirens.....Something went wrong\r\n        </div>\r\n      )\r\n    }\r\n    if (isLoading) {\r\n      return (\r\n        <Preload\r\n          chartName=\"world\"\r\n          turnDownPreload={this.handlePreloadShutdown}\r\n        />\r\n      )\r\n    }\r\n\r\n    if (globeMap.length) {\r\n      return (\r\n        <div\r\n          ref={el => {\r\n            this.chartContainer = el\r\n          }}>\r\n          <div className={styles.globeTitle}>Meteor hits across the globe</div>\r\n          <div className={styles.containerGlobe}>\r\n            <div>\r\n              <GlobeViewChart\r\n                svgWidth={chartWidth}\r\n                svgHeight={chartHeight}\r\n                globeData={globeMap}\r\n                meteorsInfo={meteors}\r\n                showToolTip={this.activateToolTip}\r\n                hideToolTip={this.disableToolTip}\r\n              />\r\n            </div>\r\n            <div>\r\n              <MeteorToolTip data={isToolTipActive ? meteorInfo : null} />\r\n            </div>\r\n          </div>\r\n        </div>\r\n      )\r\n    }\r\n  }\r\n  // #endregion\r\n}\r\nexport default GlobeViewContainer\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/Challenges/GlobeChartView/GlobeViewContainer.js","import React, { PureComponent } from 'react'\r\nimport PropTypes from 'prop-types'\r\n\r\nclass MeteorPoint extends PureComponent {\r\n  onEnter = () => {\r\n    const { data, meteorPointEnter } = this.props\r\n    meteorPointEnter({\r\n      name: data.meteorname,\r\n      meteorclass: data.meteorclass,\r\n      dateofhit: data.datefell.substring(0, 4),\r\n      meteormass: data.mass,\r\n      latitude: Number(data.rectangleLat).toFixed(4),\r\n      longitude: Number(data.rectangleLong).toFixed(4),\r\n    })\r\n  }\r\n  onExit = () => {\r\n    const { meteorPointExit } = this.props\r\n    meteorPointExit()\r\n  }\r\n  render() {\r\n    const { data } = this.props\r\n    return (\r\n      <circle\r\n        key={`marker_${data.circleId} `}\r\n        fill=\"#E91E63\"\r\n        fillOpacity={data.circleFill}\r\n        stroke=\"#FFFFFF\"\r\n        className=\"marker\"\r\n        cx={data.rectangleLat}\r\n        cy={data.rectangleLong}\r\n        r={data.circleArea}\r\n        onMouseOver={this.onEnter}\r\n        onFocus={this.onEnter}\r\n        onMouseOut={this.onExit}\r\n        onBlur={this.onExit}\r\n      />\r\n    )\r\n  }\r\n}\r\nMeteorPoint.propTypes = {\r\n  data: PropTypes.shape({\r\n    meteorname: PropTypes.string,\r\n    meteorclass: PropTypes.string,\r\n    datefell: PropTypes.string,\r\n    mass: PropTypes.number,\r\n    rectangleLat: PropTypes.number,\r\n    rectangleLong: PropTypes.number,\r\n    circleId: PropTypes.number,\r\n    circleArea: PropTypes.number,\r\n    circleFill: PropTypes.number,\r\n  }),\r\n  meteorPointEnter: PropTypes.func,\r\n  meteorPointExit: PropTypes.func,\r\n}\r\nexport default MeteorPoint\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/Challenges/GlobeChartView/MeteorPoint.js","import PropTypes from 'prop-types'\r\nimport React from 'react'\r\nimport styles from './globe-style.module.css'\r\n\r\nconst showMeteorInfo = () => {\r\n  return (\r\n    <p>\r\n      <span className={styles.tooltipText}>\r\n        Mouse over map to show information\r\n      </span>\r\n    </p>\r\n  )\r\n}\r\nconst showMeteorData = value => {\r\n  return (\r\n    <p>\r\n      <span className={styles.tooltipText}>\r\n        In {value.dateofhit} a meteor with mass of {value.meteormass} and class{' '}\r\n        {value.meteorclass} fell on latitude {value.latitude} longitude{' '}\r\n        {value.longitude}\r\n      </span>\r\n    </p>\r\n  )\r\n}\r\n\r\nconst MeteorToolTip = ({ data }) => {\r\n  return (\r\n    <div className={styles.containerToolTip}>\r\n      {data ? showMeteorData(data) : showMeteorInfo()}\r\n    </div>\r\n  )\r\n}\r\nMeteorToolTip.propTypes = {\r\n  data: PropTypes.shape({\r\n    name: PropTypes.string,\r\n    meteorclass: PropTypes.string,\r\n    dateofhit: PropTypes.string,\r\n    meteormass: PropTypes.number,\r\n    latitude: PropTypes.string,\r\n    longitude: PropTypes.string,\r\n  }),\r\n}\r\nexport default MeteorToolTip\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/Challenges/GlobeChartView/MeteorToolTip.js","import PropTypes from 'prop-types'\r\nimport uuid from 'uuid'\r\nimport React, { PureComponent } from 'react'\r\nimport MeteorPoint from './MeteorPoint'\r\n\r\nclass WorldMap extends PureComponent {\r\n  onPointHover = value => {\r\n    const { pointEnter } = this.props\r\n    pointEnter(value)\r\n  }\r\n  onPointLeave = () => {\r\n    const { pointExit } = this.props\r\n    pointExit()\r\n  }\r\n  render() {\r\n    const { world, meteorfall } = this.props\r\n\r\n    const parsedWorld = world.map(d => (\r\n      <path\r\n        key={`path:${uuid.v4()}`}\r\n        d={d.dpath}\r\n        fill={d.fillInfo}\r\n        stroke=\"#FFFFFF\"\r\n        strokeWidth={0.5}\r\n      />\r\n    ))\r\n\r\n    const meteorsData = meteorfall.map((m, x) => (\r\n      <MeteorPoint\r\n        key={`mpoint_${m.name}_class_${m.meteorclass}`}\r\n        data={{\r\n          meteorname: m.name,\r\n          meteorclass: m.meteorClass,\r\n          datefell: m.date,\r\n          mass: m.mass,\r\n          rectangleLat: m.latitude,\r\n          rectangleLong: m.longitude,\r\n          circleId: x,\r\n          circleArea: m.radius,\r\n          circleFill: m.fillOp,\r\n        }}\r\n        meteorPointEnter={this.onPointHover}\r\n        meteorPointExit={this.onPointLeave}\r\n      />\r\n    ))\r\n    return (\r\n      <g>\r\n        {parsedWorld}\r\n        {meteorsData}\r\n      </g>\r\n    )\r\n  }\r\n}\r\nWorldMap.propTypes = {\r\n  world: PropTypes.arrayOf(\r\n    PropTypes.shape({\r\n      dpath: PropTypes.string,\r\n      fillInfo: PropTypes.string,\r\n    })\r\n  ),\r\n  pointEnter: PropTypes.func,\r\n  pointExit: PropTypes.func,\r\n  meteorfall: PropTypes.arrayOf(\r\n    PropTypes.shape({\r\n      date: PropTypes.string,\r\n      fillOp: PropTypes.number,\r\n      latitude: PropTypes.number,\r\n      longitude: PropTypes.number,\r\n      mass: PropTypes.number,\r\n      name: PropTypes.string,\r\n      radius: PropTypes.number,\r\n      meteorClass: PropTypes.string,\r\n    })\r\n  ),\r\n}\r\nexport default WorldMap\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/Challenges/GlobeChartView/WorldMap.js","// removed by extract-text-webpack-plugin\nmodule.exports = {\"containerGlobe\":\"src-components-Challenges-GlobeChartView----globe-style-module---containerGlobe---3awqv\",\"globeTitle\":\"src-components-Challenges-GlobeChartView----globe-style-module---globeTitle---clqfa\",\"tooltipText\":\"src-components-Challenges-GlobeChartView----globe-style-module---tooltipText---1ZgBU\",\"containerToolTip\":\"src-components-Challenges-GlobeChartView----globe-style-module---containerToolTip---2qW53\"};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/Challenges/GlobeChartView/globe-style.module.css\n// module id = 254\n// module chunks = 234182462816062","import React from 'react'\r\nimport Helmet from 'react-helmet'\r\nimport GlobeViewContainer from '../components/Challenges/GlobeChartView/GlobeViewContainer'\r\n\r\nconst GlobeGraphPage = () => {\r\n  return (\r\n    <div>\r\n      <Helmet\r\n        title=\"Super Duper Globe Map\"\r\n        meta={[\r\n          {\r\n            name: 'description',\r\n            content: 'freeCodeCamp DataVis Challenges,Globe Map,meteors',\r\n          },\r\n          {\r\n            name: 'keywords',\r\n            content: 'react, gatsby,challenges,d3,globe map',\r\n          },\r\n          { name: 'author', content: 'jonniebigodes' },\r\n        ]}\r\n      />\r\n      <GlobeViewContainer />\r\n    </div>\r\n  )\r\n}\r\nexport default GlobeGraphPage\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/pages/globeview.js"],"sourceRoot":""}